package org.utbot.framework.plugin.api

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import org.utbot.framework.plugin.api.util.UtContext
import org.utbot.framework.plugin.api.util.doubleWrapperClassId
import org.utbot.framework.plugin.api.util.id
import org.utbot.framework.plugin.api.util.voidClassId
import org.utbot.framework.plugin.api.util.withUtContext
import org.utbot.fuzzer.FuzzedMethodDescription
import org.utbot.fuzzer.objects.create
import org.utbot.fuzzer.objects.replaceWithMock
import org.utbot.fuzzer.objects.toFuzzerMockable
import org.utbot.fuzzer.providers.ObjectModelProvider

class MockOfObjectModelProviderTest {

    class Some {
        @Suppress("unused")
        var another: Some? = null
    }

    @Test
    fun `no mock is generated by default`() = withContext {
        val description = FuzzedMethodDescription("test", voidClassId, listOf(Some::class.id))
        val provider = ObjectModelProvider(TestIdentityPreservingIdGenerator)
        val results = provider.generate(description).map { it.value.model }.map {
            replaceWithMock(it) { m -> description.shouldMock(m) }
        }.toList()
        assertEquals(2, results.size)
        results.forEach { model ->
            assertInstanceOf(UtAssembleModel::class.java, model)
        }
        assertEquals(0, (results[1] as UtAssembleModel).modificationsChain.size)
        assertEquals(1, (results[0] as UtAssembleModel).modificationsChain.size)
    }

    @Test
    fun `mock is generated`() = withContext {
        val description = FuzzedMethodDescription("test", voidClassId, listOf(Some::class.id)).apply {
            shouldMock = { true }
        }
        val provider = ObjectModelProvider(TestIdentityPreservingIdGenerator)
        val results = provider.generate(description).map { it.value.model }.map {
            replaceWithMock(it) { m -> description.shouldMock(m) }
        }.toList()
        assertEquals(2, results.size)
        results.forEach { model ->
            assertInstanceOf(UtCompositeModel::class.java, model)
            assertTrue((model as UtCompositeModel).isMock)
        }
    }

    @Test
    fun `mock is generated for several recursion level`() = withContext {
        val description = FuzzedMethodDescription("test", voidClassId, listOf(Some::class.id)).apply {
            shouldMock = { true }
        }
        val provider = ObjectModelProvider(TestIdentityPreservingIdGenerator, recursionDepthLeft = 2)
        val results = provider.generate(description).map { it.value.model }.map {
            replaceWithMock(it) { m -> description.shouldMock(m) }
        }.toList()
        assertEquals(2, results.size)
        results.forEach { model ->
            assertInstanceOf(UtCompositeModel::class.java, model)
            assertTrue((model as UtCompositeModel).isMock)
        }
        val modelWithFieldChanger = results[0] as UtCompositeModel
        assertEquals(1, modelWithFieldChanger.mocks.size)
        val entry = modelWithFieldChanger.mocks.entries.single()
        assertEquals("getAnother", entry.key.name)
        assertEquals(Some::class.id, entry.key.returnType)
        assertEquals(1, entry.value.size)
        assertInstanceOf(UtCompositeModel::class.java, entry.value.single())
    }

    @Test
    fun `check field replaced with concrete values`() {
        val customModel = Any::class.id.create {
            using empty constructor
            call instance field("some") with UtNullModel(Nothing::class.id)
        }
        val replacedModel = replaceWithMock(customModel) { true }
        assertInstanceOf(UtCompositeModel::class.java, replacedModel)
        replacedModel as UtCompositeModel
        assertEquals(0, replacedModel.mocks.size)
        val fields = replacedModel.fields
        assertEquals(1, fields.size)
        val entry = fields.entries.single()
        assertEquals("some", entry.key.name)
        assertEquals(UtNullModel(Nothing::class.id), entry.value)
    }

    @Test
    fun `check method replaced with mock values`() {
        val customModel = Any::class.id.create {
            using empty constructor
            call instance method("some").toFuzzerMockable {
                yield(MethodId(classId, "another", doubleWrapperClassId, emptyList()) to listOf(UtPrimitiveModel(2.0)))
            } with values(UtNullModel(Nothing::class.id))
        }
        val replacedModel = replaceWithMock(customModel) { true }
        assertInstanceOf(UtCompositeModel::class.java, replacedModel)
        replacedModel as UtCompositeModel
        assertEquals(0, replacedModel.fields.size)
        val mocks = replacedModel.mocks
        assertEquals(1, replacedModel.mocks.size)
        val (executableId, models) = mocks.entries.single()
        assertEquals("another", executableId.name)
        assertEquals(doubleWrapperClassId, executableId.returnType)
        assertEquals(0, executableId.parameters.size)
        assertEquals(1, models.size)
        assertInstanceOf(UtPrimitiveModel::class.java, models.single())
        assertEquals(2.0, (models.single() as UtPrimitiveModel).value)
    }

    private fun <T> withContext(block: () -> T) {
        withUtContext(UtContext(this::class.java.classLoader)) {
            block()
        }
    }

}