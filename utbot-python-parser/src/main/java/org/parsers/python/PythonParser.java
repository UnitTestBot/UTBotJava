/* Generated by: JavaCC 21 Parser Generator. PythonParser.java */
package org.parsers.python;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Map;
import java.util.concurrent.CancellationException;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.charset.Charset;
import org.parsers.python.ast.Module;
import org.parsers.python.ast.SignedNumber;
import org.parsers.python.ast.Strings;
import org.parsers.python.ast.Slice;
import org.parsers.python.ast.Slices;
import org.parsers.python.ast.Statement;
import org.parsers.python.ast.SimpleStatement;
import org.parsers.python.ast.SmallStatement;
import org.parsers.python.ast.CompoundStatement;
import org.parsers.python.ast.ReturnStatement;
import org.parsers.python.ast.GlobalStatement;
import org.parsers.python.ast.NonlocalStatement;
import org.parsers.python.ast.AssertStatement;
import org.parsers.python.ast.RaiseStatement;
import org.parsers.python.ast.Block;
import org.parsers.python.ast.ElseBlock;
import org.parsers.python.ast.ExceptBlock;
import org.parsers.python.ast.IfStatement;
import org.parsers.python.ast.FinallyBlock;
import org.parsers.python.ast.WhileStatement;
import org.parsers.python.ast.WithStatement;
import org.parsers.python.ast.WithItem;
import org.parsers.python.ast.ForStatement;
import org.parsers.python.ast.TryStatement;
import org.parsers.python.ast.DelStatement;
import org.parsers.python.ast.NamedExpression;
import org.parsers.python.ast.DottedName;
import org.parsers.python.ast.ImportStatement;
import org.parsers.python.ast.ImportFromTargets;
import org.parsers.python.ast.StarNamedExpression;
import org.parsers.python.ast.StarExpression;
import org.parsers.python.ast.StarExpressions;
import org.parsers.python.ast.StarNamedExpressions;
import org.parsers.python.ast.BitwiseOr;
import org.parsers.python.ast.BitwiseXor;
import org.parsers.python.ast.BitwiseAnd;
import org.parsers.python.ast.ShiftExpression;
import org.parsers.python.ast.AdditiveExpression;
import org.parsers.python.ast.MultiplicativeExpression;
import org.parsers.python.ast.UnaryExpression;
import org.parsers.python.ast.Power;
import org.parsers.python.ast.Tuple;
import org.parsers.python.ast.Group;
import org.parsers.python.ast.AwaitPrimary;
import org.parsers.python.ast.DotName;
import org.parsers.python.ast.SliceExpression;
import org.parsers.python.ast.GenExpression;
import org.parsers.python.ast.FunctionCall;
import org.parsers.python.ast.YieldExpression;
import org.parsers.python.ast.YieldStatement;
import org.parsers.python.ast.AnnotatedRhs;
import org.parsers.python.ast.Decorators;
import org.parsers.python.ast.Annotation;
import org.parsers.python.ast.InvocationArguments;
import org.parsers.python.ast.Argument;
import org.parsers.python.ast.KeyValuePair;
import org.parsers.python.ast.DoubleStarredKeyValuePair;
import org.parsers.python.ast.DoubleStarredKeyValuePairs;
import org.parsers.python.ast.Dict;
import org.parsers.python.ast.DictComp;
import org.parsers.python.ast.Set;
import org.parsers.python.ast.SetComp;
import org.parsers.python.ast.ClassDefinition;
import org.parsers.python.ast.FunctionDefinition;
import org.parsers.python.ast.LambdaDefinition;
import org.parsers.python.ast.Expression;
import org.parsers.python.ast.Disjunction;
import org.parsers.python.ast.Conjunction;
import org.parsers.python.ast.Inversion;
import org.parsers.python.ast.Comparison;
import org.parsers.python.ast.StarTarget;
import org.parsers.python.ast.StarTargets;
import org.parsers.python.ast.ForIfClause;
import org.parsers.python.ast.GenExp;
import org.parsers.python.ast.List;
import org.parsers.python.ast.ListComp;
import org.parsers.python.ast.StarEtc;
import org.parsers.python.ast.ParamMaybeDefault;
import org.parsers.python.ast.KeyWords;
import org.parsers.python.ast.Parameters;
import org.parsers.python.ast.SimpleAssignTarget;
import org.parsers.python.ast.Assignment;
import org.parsers.python.ast.MatchStatement;
import org.parsers.python.ast.CaseBlock;
import org.parsers.python.ast.Patterns;
import org.parsers.python.ast.StarPattern;
import org.parsers.python.ast.ClosedPattern;
import org.parsers.python.ast.GroupPattern;
import org.parsers.python.ast.KeyValuePattern;
import org.parsers.python.ast.ItemsPattern;
import org.parsers.python.ast.MappingPattern;
import org.parsers.python.ast.DoubleStarPattern;
import org.parsers.python.ast.LiteralPattern;
import org.parsers.python.ast.MaybeSequencePattern;
import org.parsers.python.ast.OpenSequencePattern;
import org.parsers.python.ast.SequencePattern;
import org.parsers.python.ast.ClassPattern;
import org.parsers.python.ast.PositionalPatterns;
import org.parsers.python.ast.KeywordPattern;
import org.parsers.python.ast.KeywordPatterns;
import org.parsers.python.ast.OrPattern;
import org.parsers.python.ast.Pattern;
import org.parsers.python.ast.SubjectExpression;
import org.parsers.python.ast.Attribute;
import static org.parsers.python.PythonConstants.TokenType.*;
@SuppressWarnings("unused")
public class PythonParser implements PythonConstants {
    static final int UNLIMITED= Integer.MAX_VALUE;
    // The last token successfully "consumed"
    Token lastConsumedToken;
    private TokenType nextTokenType;
    private Token currentLookaheadToken;
    private int remainingLookahead;
    private boolean scanToEnd, hitFailure;
    private String currentlyParsedProduction, currentLookaheadProduction;
    private int lookaheadRoutineNesting, nonTerminalNesting;
    private boolean cancelled;
    public void cancel() {
        cancelled= true;
    }

    public boolean isCancelled() {
        return cancelled;
    }

    /** Generated Lexer. */
    public PythonLexer token_source;
    public void setInputSource(String inputSource) {
        token_source.setInputSource(inputSource);
    }

    String getInputSource() {
        return token_source.getInputSource();
    }

    //=================================
    // Generated constructors
    //=================================
    public PythonParser(String inputSource, CharSequence content) {
        this(new PythonLexer(inputSource, content));
    }

    public PythonParser(CharSequence content) {
        this("input", content);
    }

    /**
   * @param inputSource just the name of the input source (typically the filename) that 
   * will be used in error messages and so on.
   * @param path The location (typically the filename) from which to get the input to parse
   */
    public PythonParser(String inputSource, Path path) throws IOException {
        this(inputSource, PythonLexer.stringFromBytes(Files.readAllBytes(path)));
    }

    public PythonParser(String inputSource, Path path, Charset charset) throws IOException {
        this(inputSource, PythonLexer.stringFromBytes(Files.readAllBytes(path), charset));
    }

    /**
   * @param path The location (typically the filename) from which to get the input to parse
   */
    public PythonParser(Path path) throws IOException {
        this(path.toString(), path);
    }

    /**
   * @Deprecated Use the constructor that takes a #java.nio.files.Path or just 
   * a String (i.e. CharSequence) directly.
   */
    public PythonParser(java.io.InputStream stream) {
        this(new InputStreamReader(stream));
    }

    /**
   * @Deprecated Use the constructor that takes a #java.nio.files.Path or just 
   * a String (i.e. CharSequence) directly.
   */
    public PythonParser(Reader reader) {
        this(new PythonLexer("input", reader));
    }

    /** Constructor with user supplied Lexer. */
    public PythonParser(PythonLexer lexer) {
        token_source= lexer;
        lastConsumedToken= lexer.DUMMY_START_TOKEN;
        lastConsumedToken.setTokenSource(lexer);
    }

    // If the next token is cached, it returns that
    // Otherwise, it goes to the token_source, i.e. the Lexer.
    final private Token nextToken(final Token tok) {
        Token result= token_source.getNextToken(tok);
        while (result.isUnparsed()) {
            result= token_source.getNextToken(result);
        }
        nextTokenType= null;
        return result;
    }

    /**
   * @return the next Token off the stream. This is the same as #getToken(1)
   */
    final public Token getNextToken() {
        return getToken(1);
    }

    /**
 * @param index how many tokens to look ahead
 * @return the specific regular (i.e. parsed) Token index ahead/behind in the stream. 
 * If we are in a lookahead, it looks ahead from the currentLookaheadToken
 * Otherwise, it is the lastConsumedToken. If you pass in a negative
 * number it goes backward.
 */
    final public Token getToken(final int index) {
        Token t= currentLookaheadToken== null?lastConsumedToken:
        currentLookaheadToken;
        for (int i= 0; i<index; i++) {
            t= nextToken(t);
        }
        for (int i= 0; i> index; i--) {
            t= t.getPrevious();
            if (t== null) break;
        }
        return t;
    }

    private final TokenType nextTokenType() {
        if (nextTokenType== null) {
            nextTokenType= nextToken(lastConsumedToken).getType();
        }
        return nextTokenType;
    }

    boolean activateTokenTypes(TokenType...types) {
        boolean result= false;
        for (TokenType tt : types) {
            result|=token_source.activeTokenTypes.add(tt);
        }
        token_source.reset(getToken(0));
        nextTokenType= null;
        return result;
    }

    boolean deactivateTokenTypes(TokenType...types) {
        boolean result= false;
        for (TokenType tt : types) {
            result|=token_source.activeTokenTypes.remove(tt);
        }
        token_source.reset(getToken(0));
        nextTokenType= null;
        return result;
    }

    private static HashMap<TokenType[], EnumSet<TokenType> > enumSetCache= new HashMap<> ();
    private static EnumSet<TokenType> tokenTypeSet(TokenType first, TokenType...rest) {
        TokenType[] key= new TokenType[1+rest.length];
        key[0]= first;
        if (rest.length> 0) {
            System.arraycopy(rest, 0, key, 1, rest.length);
        }
        Arrays.sort(key);
        if (enumSetCache.containsKey(key)) {
            return enumSetCache.get(key);
        }
        EnumSet<TokenType> result= (rest.length== 0)?EnumSet.of(first):
        EnumSet.of(first, rest);
        enumSetCache.put(key, result);
        return result;
    }

    // Python.javacc:22:1
    final public Module Module() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Module";
        Module Module1= null;
        if (buildTree) {
            Module1= new Module();
            openNodeScope(Module1);
        }
        ParseException parseException1= null;
        int callStackSize2= parsingStack.size();
        try {
            // Code for ZeroOrMore specified at Python.javacc:23:4
            while (true) {
                if (!(first_set$Python_javacc$23$5.contains(nextTokenType()))) break;
                // Code for NonTerminal specified at Python.javacc:23:5
                pushOntoCallStack("Module", "Python.javacc", 23, 5);
                try {
                    Statement();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for EndOfFile specified at Python.javacc:24:4
            consumeToken(EOF);
            // Code for CodeBlock specified at Python.javacc:25:4
            return Module1;
        }
        catch(ParseException e) {
            parseException1= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2);
            if (Module1!=null) {
                if (parseException1== null) {
                    closeNodeScope(Module1, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> Number_FIRST_SET= tokenTypeSet(DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX);
    // Python.javacc:28:1
    final public void Number() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Number";
        // Code for ExpansionChoice specified at Python.javacc:29:3
        if (nextTokenType()== HEXNUMBER) {
            // Code for RegexpRef specified at Python.javacc:29:3
            consumeToken(HEXNUMBER);
        }
        else if (nextTokenType()== BINNUMBER) {
            // Code for RegexpRef specified at Python.javacc:29:17
            consumeToken(BINNUMBER);
        }
        else if (nextTokenType()== OCTNUMBER) {
            // Code for RegexpRef specified at Python.javacc:29:31
            consumeToken(OCTNUMBER);
        }
        else if (nextTokenType()== DECNUMBER) {
            // Code for RegexpRef specified at Python.javacc:29:45
            consumeToken(DECNUMBER);
        }
        else if (nextTokenType()== FLOAT) {
            // Code for RegexpRef specified at Python.javacc:29:59
            consumeToken(FLOAT);
        }
        else if (nextTokenType()== COMPLEX) {
            // Code for RegexpRef specified at Python.javacc:29:69
            consumeToken(COMPLEX);
        }
        else  {
            pushOntoCallStack("Number", "Python.javacc", 29, 3);
            throw new ParseException(this, Number_FIRST_SET, parsingStack);
        }
    }

    // Python.javacc:32:1
    final public void SignedNumber() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "SignedNumber";
        SignedNumber SignedNumber2= null;
        if (buildTree) {
            SignedNumber2= new SignedNumber();
            openNodeScope(SignedNumber2);
        }
        ParseException parseException58= null;
        int callStackSize59= parsingStack.size();
        try {
            // Code for ZeroOrOne specified at Python.javacc:33:3
            if (nextTokenType()== MINUS) {
                // Code for RegexpStringLiteral specified at Python.javacc:33:4
                consumeToken(MINUS);
            }
            // Code for NonTerminal specified at Python.javacc:34:3
            pushOntoCallStack("SignedNumber", "Python.javacc", 34, 3);
            try {
                Number();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at Python.javacc:35:3
            if (nextTokenType()== MINUS||nextTokenType== PLUS) {
                if (nextTokenType()== PLUS) {
                    // Code for RegexpStringLiteral specified at Python.javacc:35:5
                    consumeToken(PLUS);
                }
                else if (nextTokenType()== MINUS) {
                    // Code for RegexpStringLiteral specified at Python.javacc:35:9
                    consumeToken(MINUS);
                }
                else  {
                    pushOntoCallStack("SignedNumber", "Python.javacc", 35, 5);
                    throw new ParseException(this, first_set$Python_javacc$35$5, parsingStack);
                }
                // Code for RegexpRef specified at Python.javacc:35:14
                consumeToken(COMPLEX);
            }
        }
        catch(ParseException e) {
            parseException58= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize59);
            if (SignedNumber2!=null) {
                if (parseException58== null) {
                    closeNodeScope(SignedNumber2, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:38:1
    final public void Strings() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Strings";
        Strings Strings3= null;
        if (buildTree) {
            Strings3= new Strings();
            openNodeScope(Strings3);
        }
        ParseException parseException98= null;
        int callStackSize99= parsingStack.size();
        try {
            // Code for OneOrMore specified at Python.javacc:38:11
            while (true) {
                // Code for RegexpRef specified at Python.javacc:38:12
                consumeToken(STRING_LITERAL);
                if (!(nextTokenType()== STRING_LITERAL)) break;
            }
        }
        catch(ParseException e) {
            parseException98= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize99);
            if (Strings3!=null) {
                if (parseException98== null) {
                    closeNodeScope(Strings3, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> AtomicExpression_FIRST_SET= AtomicExpression_FIRST_SET_init();
    static private EnumSet<TokenType> AtomicExpression_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, ELLIPSIS, FALSE, NONE, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:40:1
    final public void AtomicExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "AtomicExpression";
        // Code for ExpansionChoice specified at Python.javacc:41:5
        if (nextTokenType()== NAME) {
            // Code for RegexpRef specified at Python.javacc:41:5
            consumeToken(NAME);
        }
        else if (first_set$Python_javacc$43$5.contains(nextTokenType())) {
            // Code for NonTerminal specified at Python.javacc:43:5
            pushOntoCallStack("AtomicExpression", "Python.javacc", 43, 5);
            try {
                Number();
            }
            finally {
                popCallStack();
            }
        }
        else if (nextTokenType()== STRING_LITERAL) {
            // Code for NonTerminal specified at Python.javacc:45:5
            pushOntoCallStack("AtomicExpression", "Python.javacc", 45, 5);
            try {
                Strings();
            }
            finally {
                popCallStack();
            }
        }
        else if (nextTokenType()== TRUE) {
            // Code for RegexpStringLiteral specified at Python.javacc:47:5
            consumeToken(TRUE);
        }
        else if (nextTokenType()== FALSE) {
            // Code for RegexpStringLiteral specified at Python.javacc:49:5
            consumeToken(FALSE);
        }
        else if (nextTokenType()== NONE) {
            // Code for RegexpStringLiteral specified at Python.javacc:51:5
            consumeToken(NONE);
        }
        else if (nextTokenType()== PEG_PARSER) {
            // Code for RegexpStringLiteral specified at Python.javacc:53:5
            consumeToken(PEG_PARSER);
        }
        else if (nextTokenType()== LPAREN) {
            if (scan$Python_javacc$55$6()) {
                // Code for NonTerminal specified at Python.javacc:55:6
                pushOntoCallStack("AtomicExpression", "Python.javacc", 55, 6);
                try {
                    Tuple();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$Python_javacc$55$14()) {
                // Code for NonTerminal specified at Python.javacc:55:14
                pushOntoCallStack("AtomicExpression", "Python.javacc", 55, 14);
                try {
                    GenExp();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== LPAREN) {
                // Code for NonTerminal specified at Python.javacc:55:23
                pushOntoCallStack("AtomicExpression", "Python.javacc", 55, 23);
                try {
                    Group();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("AtomicExpression", "Python.javacc", 55, 6);
                throw new ParseException(this, first_set$Python_javacc$55$6, parsingStack);
            }
        }
        else if (nextTokenType()== LBRACKET) {
            if (scan$Python_javacc$57$6()) {
                // Code for NonTerminal specified at Python.javacc:57:6
                pushOntoCallStack("AtomicExpression", "Python.javacc", 57, 6);
                try {
                    ListComp();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== LBRACKET) {
                // Code for NonTerminal specified at Python.javacc:57:17
                pushOntoCallStack("AtomicExpression", "Python.javacc", 57, 17);
                try {
                    List();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("AtomicExpression", "Python.javacc", 57, 6);
                throw new ParseException(this, first_set$Python_javacc$57$6, parsingStack);
            }
        }
        else if (nextTokenType()== LBRACE) {
            if (scan$Python_javacc$59$6()) {
                // Code for NonTerminal specified at Python.javacc:59:6
                pushOntoCallStack("AtomicExpression", "Python.javacc", 59, 6);
                try {
                    SetComp();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$Python_javacc$59$16()) {
                // Code for NonTerminal specified at Python.javacc:59:16
                pushOntoCallStack("AtomicExpression", "Python.javacc", 59, 16);
                try {
                    DictComp();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$Python_javacc$59$27()) {
                // Code for NonTerminal specified at Python.javacc:59:27
                pushOntoCallStack("AtomicExpression", "Python.javacc", 59, 27);
                try {
                    Dict();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== LBRACE) {
                // Code for NonTerminal specified at Python.javacc:59:34
                pushOntoCallStack("AtomicExpression", "Python.javacc", 59, 34);
                try {
                    Set();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("AtomicExpression", "Python.javacc", 59, 6);
                throw new ParseException(this, first_set$Python_javacc$59$6, parsingStack);
            }
        }
        else if (nextTokenType()== ELLIPSIS) {
            // Code for RegexpStringLiteral specified at Python.javacc:61:5
            consumeToken(ELLIPSIS);
        }
        else  {
            pushOntoCallStack("AtomicExpression", "Python.javacc", 41, 5);
            throw new ParseException(this, AtomicExpression_FIRST_SET, parsingStack);
        }
    }

    static private final EnumSet<TokenType> Slice_FIRST_SET= Slice_FIRST_SET_init();
    static private EnumSet<TokenType> Slice_FIRST_SET_init() {
        return tokenTypeSet(COLON, LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:64:1
    final public void Slice() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Slice";
        // Code for ExpansionChoice specified at Python.javacc:65:5
        Slice Slice4= null;
        if (buildTree) {
            Slice4= new Slice();
            openNodeScope(Slice4);
        }
        ParseException parseException236= null;
        int callStackSize237= parsingStack.size();
        try {
            if (scan$Python_javacc$65$5()) {
                // Code for ZeroOrOne specified at Python.javacc:65:5
                if (first_set$Python_javacc$65$6.contains(nextTokenType())) {
                    // Code for NonTerminal specified at Python.javacc:65:6
                    pushOntoCallStack("Slice", "Python.javacc", 65, 6);
                    try {
                        Expression();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for RegexpStringLiteral specified at Python.javacc:65:18
                consumeToken(COLON);
                // Code for ZeroOrOne specified at Python.javacc:65:27
                if (first_set$Python_javacc$65$28.contains(nextTokenType())) {
                    // Code for NonTerminal specified at Python.javacc:65:28
                    pushOntoCallStack("Slice", "Python.javacc", 65, 28);
                    try {
                        Expression();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for ZeroOrOne specified at Python.javacc:65:40
                if (nextTokenType()== COLON) {
                    // Code for RegexpStringLiteral specified at Python.javacc:65:41
                    consumeToken(COLON);
                    // Code for ZeroOrOne specified at Python.javacc:65:45
                    if (first_set$Python_javacc$65$46.contains(nextTokenType())) {
                        // Code for NonTerminal specified at Python.javacc:65:46
                        pushOntoCallStack("Slice", "Python.javacc", 65, 46);
                        try {
                            Expression();
                        }
                        finally {
                            popCallStack();
                        }
                    }
                }
            }
            else if (first_set$Python_javacc$67$5.contains(nextTokenType())) {
                // Code for ZeroOrOne specified at Python.javacc:67:5
                if (scan$Python_javacc$67$6()) {
                    // Code for RegexpRef specified at Python.javacc:67:9
                    consumeToken(NAME);
                    // Code for RegexpStringLiteral specified at Python.javacc:67:16
                    consumeToken(COLONEQUALS);
                }
                // Code for NonTerminal specified at Python.javacc:67:22
                pushOntoCallStack("Slice", "Python.javacc", 67, 22);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("Slice", "Python.javacc", 65, 5);
                throw new ParseException(this, Slice_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException236= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize237);
            if (Slice4!=null) {
                if (parseException236== null) {
                    closeNodeScope(Slice4, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:70:1
    final public void Slices() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Slices";
        Slices Slices5= null;
        if (buildTree) {
            Slices5= new Slices();
            openNodeScope(Slices5);
        }
        ParseException parseException299= null;
        int callStackSize300= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:70:10
            consumeToken(LBRACKET);
            // Code for NonTerminal specified at Python.javacc:70:14
            pushOntoCallStack("Slices", "Python.javacc", 70, 14);
            try {
                Slice();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:70:20
            while (true) {
                if (!(scan$Python_javacc$70$21())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:70:21
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:70:31
                pushOntoCallStack("Slices", "Python.javacc", 70, 31);
                try {
                    Slice();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:70:39
            if (nextTokenType()== COMMA) {
                // Code for RegexpStringLiteral specified at Python.javacc:70:40
                consumeToken(COMMA);
            }
            // Code for RegexpStringLiteral specified at Python.javacc:70:45
            consumeToken(RBRACKET);
        }
        catch(ParseException e) {
            parseException299= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize300);
            if (Slices5!=null) {
                if (parseException299== null) {
                    closeNodeScope(Slices5, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> Statement_FIRST_SET= Statement_FIRST_SET_init();
    static private EnumSet<TokenType> Statement_FIRST_SET_init() {
        return tokenTypeSet(AT, LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, _ASSERT, ASYNC, AWAIT, BREAK, CLASS, CONTINUE, DEF, DEL, FOR, FROM, GLOBAL, IF, FALSE, IMPORT, LAMBDA, MATCH, NONLOCAL, NONE, NOT, PASS, PEG_PARSER, RAISE, RETURN, TRUE, TRY, WHILE, WITH, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:72:1
    final public void Statement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Statement";
        // Code for ExpansionChoice specified at Python.javacc:73:4
        Statement Statement6= null;
        if (buildTree) {
            Statement6= new Statement();
            openNodeScope(Statement6);
        }
        ParseException parseException332= null;
        int callStackSize333= parsingStack.size();
        try {
            if (scan$Python_javacc$73$4()) {
                // Code for NonTerminal specified at Python.javacc:73:4
                pushOntoCallStack("Statement", "Python.javacc", 73, 4);
                try {
                    MatchStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$75$4.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:75:4
                pushOntoCallStack("Statement", "Python.javacc", 75, 4);
                try {
                    SimpleStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$77$4.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:77:4
                pushOntoCallStack("Statement", "Python.javacc", 77, 4);
                try {
                    CompoundStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("Statement", "Python.javacc", 73, 4);
                throw new ParseException(this, Statement_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException332= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize333);
            if (Statement6!=null) {
                if (parseException332== null) {
                    closeNodeScope(Statement6, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:80:1
    final public void SimpleStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "SimpleStatement";
        SimpleStatement SimpleStatement7= null;
        if (buildTree) {
            SimpleStatement7= new SimpleStatement();
            openNodeScope(SimpleStatement7);
        }
        ParseException parseException353= null;
        int callStackSize354= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:80:24
            pushOntoCallStack("SimpleStatement", "Python.javacc", 80, 24);
            try {
                SmallStatement();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:80:39
            while (true) {
                if (!(scan$Python_javacc$80$40())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:80:40
                consumeToken(SEMICOLON);
                // Code for NonTerminal specified at Python.javacc:80:50
                pushOntoCallStack("SimpleStatement", "Python.javacc", 80, 50);
                try {
                    SmallStatement();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:80:67
            if (nextTokenType()== SEMICOLON) {
                // Code for RegexpStringLiteral specified at Python.javacc:80:68
                consumeToken(SEMICOLON);
            }
            // Code for RegexpRef specified at Python.javacc:80:73
            consumeToken(NEWLINE);
        }
        catch(ParseException e) {
            parseException353= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize354);
            if (SimpleStatement7!=null) {
                if (parseException353== null) {
                    closeNodeScope(SimpleStatement7, nodeArity()> 2);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> SmallStatement_FIRST_SET= SmallStatement_FIRST_SET_init();
    static private EnumSet<TokenType> SmallStatement_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, _ASSERT, AWAIT, BREAK, CONTINUE, DEL, FROM, GLOBAL, FALSE, IMPORT, LAMBDA, NONLOCAL, NONE, NOT, PASS, PEG_PARSER, RAISE, RETURN, TRUE, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:82:1
    final public void SmallStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "SmallStatement";
        // Code for ExpansionChoice specified at Python.javacc:83:4
        SmallStatement SmallStatement8= null;
        if (buildTree) {
            SmallStatement8= new SmallStatement();
            openNodeScope(SmallStatement8);
        }
        ParseException parseException383= null;
        int callStackSize384= parsingStack.size();
        try {
            if (scan$Python_javacc$83$4()) {
                // Code for NonTerminal specified at Python.javacc:83:4
                pushOntoCallStack("SmallStatement", "Python.javacc", 83, 4);
                try {
                    Assignment();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$85$4.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:85:4
                pushOntoCallStack("SmallStatement", "Python.javacc", 85, 4);
                try {
                    StarExpressions();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== RETURN) {
                // Code for NonTerminal specified at Python.javacc:87:4
                pushOntoCallStack("SmallStatement", "Python.javacc", 87, 4);
                try {
                    ReturnStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== FROM||nextTokenType== IMPORT) {
                // Code for NonTerminal specified at Python.javacc:89:4
                pushOntoCallStack("SmallStatement", "Python.javacc", 89, 4);
                try {
                    ImportStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== GLOBAL) {
                // Code for NonTerminal specified at Python.javacc:91:4
                pushOntoCallStack("SmallStatement", "Python.javacc", 91, 4);
                try {
                    GlobalStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== NONLOCAL) {
                // Code for NonTerminal specified at Python.javacc:93:4
                pushOntoCallStack("SmallStatement", "Python.javacc", 93, 4);
                try {
                    NonlocalStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== BREAK) {
                // Code for RegexpStringLiteral specified at Python.javacc:95:4
                consumeToken(BREAK);
            }
            else if (nextTokenType()== CONTINUE) {
                // Code for RegexpStringLiteral specified at Python.javacc:97:4
                consumeToken(CONTINUE);
            }
            else if (nextTokenType()== PASS) {
                // Code for RegexpStringLiteral specified at Python.javacc:99:4
                consumeToken(PASS);
            }
            else if (nextTokenType()== DEL) {
                // Code for NonTerminal specified at Python.javacc:101:4
                pushOntoCallStack("SmallStatement", "Python.javacc", 101, 4);
                try {
                    DelStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== _ASSERT) {
                // Code for NonTerminal specified at Python.javacc:103:4
                pushOntoCallStack("SmallStatement", "Python.javacc", 103, 4);
                try {
                    AssertStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== RAISE) {
                // Code for NonTerminal specified at Python.javacc:105:4
                pushOntoCallStack("SmallStatement", "Python.javacc", 105, 4);
                try {
                    RaiseStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== YIELD) {
                // Code for NonTerminal specified at Python.javacc:107:4
                pushOntoCallStack("SmallStatement", "Python.javacc", 107, 4);
                try {
                    YieldStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("SmallStatement", "Python.javacc", 83, 4);
                throw new ParseException(this, SmallStatement_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException383= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize384);
            if (SmallStatement8!=null) {
                if (parseException383== null) {
                    closeNodeScope(SmallStatement8, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> CompoundStatement_FIRST_SET= CompoundStatement_FIRST_SET_init();
    static private EnumSet<TokenType> CompoundStatement_FIRST_SET_init() {
        return tokenTypeSet(AT, ASYNC, CLASS, DEF, FOR, IF, TRY, WHILE, WITH);
    }

    // Python.javacc:110:1
    final public void CompoundStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "CompoundStatement";
        // Code for ExpansionChoice specified at Python.javacc:111:5
        CompoundStatement CompoundStatement9= null;
        if (buildTree) {
            CompoundStatement9= new CompoundStatement();
            openNodeScope(CompoundStatement9);
        }
        ParseException parseException464= null;
        int callStackSize465= parsingStack.size();
        try {
            if (scan$Python_javacc$111$5()) {
                // Code for NonTerminal specified at Python.javacc:111:5
                pushOntoCallStack("CompoundStatement", "Python.javacc", 111, 5);
                try {
                    FunctionDefinition();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== IF) {
                // Code for NonTerminal specified at Python.javacc:113:5
                pushOntoCallStack("CompoundStatement", "Python.javacc", 113, 5);
                try {
                    IfStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$Python_javacc$115$5()) {
                // Code for NonTerminal specified at Python.javacc:115:5
                pushOntoCallStack("CompoundStatement", "Python.javacc", 115, 5);
                try {
                    ClassDefinition();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$Python_javacc$117$5()) {
                // Code for NonTerminal specified at Python.javacc:117:5
                pushOntoCallStack("CompoundStatement", "Python.javacc", 117, 5);
                try {
                    WithStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== WHILE) {
                // Code for NonTerminal specified at Python.javacc:119:5
                pushOntoCallStack("CompoundStatement", "Python.javacc", 119, 5);
                try {
                    WhileStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$Python_javacc$121$5()) {
                // Code for NonTerminal specified at Python.javacc:121:5
                pushOntoCallStack("CompoundStatement", "Python.javacc", 121, 5);
                try {
                    ForStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== TRY) {
                // Code for NonTerminal specified at Python.javacc:123:5
                pushOntoCallStack("CompoundStatement", "Python.javacc", 123, 5);
                try {
                    TryStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("CompoundStatement", "Python.javacc", 111, 5);
                throw new ParseException(this, CompoundStatement_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException464= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize465);
            if (CompoundStatement9!=null) {
                if (parseException464== null) {
                    closeNodeScope(CompoundStatement9, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:126:1
    final public void ReturnStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ReturnStatement";
        ReturnStatement ReturnStatement10= null;
        if (buildTree) {
            ReturnStatement10= new ReturnStatement();
            openNodeScope(ReturnStatement10);
        }
        ParseException parseException509= null;
        int callStackSize510= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:126:19
            consumeToken(RETURN);
            // Code for ZeroOrOne specified at Python.javacc:126:28
            if (first_set$Python_javacc$126$29.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:126:29
                pushOntoCallStack("ReturnStatement", "Python.javacc", 126, 29);
                try {
                    StarExpressions();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException509= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize510);
            if (ReturnStatement10!=null) {
                if (parseException509== null) {
                    closeNodeScope(ReturnStatement10, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:128:1
    final public void GlobalStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "GlobalStatement";
        GlobalStatement GlobalStatement11= null;
        if (buildTree) {
            GlobalStatement11= new GlobalStatement();
            openNodeScope(GlobalStatement11);
        }
        ParseException parseException524= null;
        int callStackSize525= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:128:19
            consumeToken(GLOBAL);
            // Code for RegexpRef specified at Python.javacc:128:28
            consumeToken(NAME);
            // Code for ZeroOrMore specified at Python.javacc:128:35
            while (true) {
                if (!(nextTokenType()== COMMA)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:128:36
                consumeToken(COMMA);
                // Code for RegexpRef specified at Python.javacc:128:40
                consumeToken(NAME);
            }
        }
        catch(ParseException e) {
            parseException524= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize525);
            if (GlobalStatement11!=null) {
                if (parseException524== null) {
                    closeNodeScope(GlobalStatement11, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:130:1
    final public void NonlocalStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "NonlocalStatement";
        NonlocalStatement NonlocalStatement12= null;
        if (buildTree) {
            NonlocalStatement12= new NonlocalStatement();
            openNodeScope(NonlocalStatement12);
        }
        ParseException parseException545= null;
        int callStackSize546= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:130:21
            consumeToken(NONLOCAL);
            // Code for RegexpRef specified at Python.javacc:130:32
            consumeToken(NAME);
            // Code for ZeroOrMore specified at Python.javacc:130:39
            while (true) {
                if (!(nextTokenType()== COMMA)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:130:40
                consumeToken(COMMA);
                // Code for RegexpRef specified at Python.javacc:130:44
                consumeToken(NAME);
            }
        }
        catch(ParseException e) {
            parseException545= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize546);
            if (NonlocalStatement12!=null) {
                if (parseException545== null) {
                    closeNodeScope(NonlocalStatement12, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:132:1
    final public void AssertStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "AssertStatement";
        AssertStatement AssertStatement13= null;
        if (buildTree) {
            AssertStatement13= new AssertStatement();
            openNodeScope(AssertStatement13);
        }
        ParseException parseException566= null;
        int callStackSize567= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:132:19
            consumeToken(_ASSERT);
            // Code for NonTerminal specified at Python.javacc:132:28
            pushOntoCallStack("AssertStatement", "Python.javacc", 132, 28);
            try {
                Expression();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:132:39
            while (true) {
                if (!(nextTokenType()== COMMA)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:132:40
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:132:44
                pushOntoCallStack("AssertStatement", "Python.javacc", 132, 44);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException566= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize567);
            if (AssertStatement13!=null) {
                if (parseException566== null) {
                    closeNodeScope(AssertStatement13, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:134:1
    final public void RaiseStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "RaiseStatement";
        RaiseStatement RaiseStatement14= null;
        if (buildTree) {
            RaiseStatement14= new RaiseStatement();
            openNodeScope(RaiseStatement14);
        }
        ParseException parseException587= null;
        int callStackSize588= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:134:18
            consumeToken(RAISE);
            // Code for ZeroOrOne specified at Python.javacc:134:26
            if (first_set$Python_javacc$134$28.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:134:28
                pushOntoCallStack("RaiseStatement", "Python.javacc", 134, 28);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrOne specified at Python.javacc:134:39
                if (nextTokenType()== FROM) {
                    // Code for RegexpStringLiteral specified at Python.javacc:134:40
                    consumeToken(FROM);
                    // Code for NonTerminal specified at Python.javacc:134:47
                    pushOntoCallStack("RaiseStatement", "Python.javacc", 134, 47);
                    try {
                        Expression();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
        }
        catch(ParseException e) {
            parseException587= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize588);
            if (RaiseStatement14!=null) {
                if (parseException587== null) {
                    closeNodeScope(RaiseStatement14, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> Block_FIRST_SET= Block_FIRST_SET_init();
    static private EnumSet<TokenType> Block_FIRST_SET_init() {
        return tokenTypeSet(NEWLINE, LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, _ASSERT, AWAIT, BREAK, CONTINUE, DEL, FROM, GLOBAL, FALSE, IMPORT, LAMBDA, NONLOCAL, NONE, NOT, PASS, PEG_PARSER, RAISE, RETURN, TRUE, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:136:1
    final public void Block() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Block";
        // Code for ExpansionChoice specified at Python.javacc:137:5
        Block Block15= null;
        if (buildTree) {
            Block15= new Block();
            openNodeScope(Block15);
        }
        ParseException parseException614= null;
        int callStackSize615= parsingStack.size();
        try {
            if (first_set$Python_javacc$137$5.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:137:5
                pushOntoCallStack("Block", "Python.javacc", 137, 5);
                try {
                    SimpleStatement();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== NEWLINE) {
                // Code for RegexpRef specified at Python.javacc:139:5
                consumeToken(NEWLINE);
                // Code for RegexpRef specified at Python.javacc:139:14
                consumeToken(INDENT);
                // Code for OneOrMore specified at Python.javacc:139:22
                while (true) {
                    // Code for NonTerminal specified at Python.javacc:139:23
                    pushOntoCallStack("Block", "Python.javacc", 139, 23);
                    try {
                        Statement();
                    }
                    finally {
                        popCallStack();
                    }
                    if (!(first_set$Python_javacc$139$23.contains(nextTokenType()))) break;
                }
                // Code for RegexpRef specified at Python.javacc:139:34
                consumeToken(DEDENT);
            }
            else  {
                pushOntoCallStack("Block", "Python.javacc", 137, 5);
                throw new ParseException(this, Block_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException614= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize615);
            if (Block15!=null) {
                if (parseException614== null) {
                    closeNodeScope(Block15, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:142:1
    final public void ElseBlock() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ElseBlock";
        ElseBlock ElseBlock16= null;
        if (buildTree) {
            ElseBlock16= new ElseBlock();
            openNodeScope(ElseBlock16);
        }
        ParseException parseException644= null;
        int callStackSize645= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:142:13
            consumeToken(ELSE);
            // Code for RegexpStringLiteral specified at Python.javacc:142:20
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:142:24
            pushOntoCallStack("ElseBlock", "Python.javacc", 142, 24);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException644= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize645);
            if (ElseBlock16!=null) {
                if (parseException644== null) {
                    closeNodeScope(ElseBlock16, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:144:1
    final public void ExceptBlock() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ExceptBlock";
        ExceptBlock ExceptBlock17= null;
        if (buildTree) {
            ExceptBlock17= new ExceptBlock();
            openNodeScope(ExceptBlock17);
        }
        ParseException parseException656= null;
        int callStackSize657= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:144:15
            consumeToken(EXCEPT);
            // Code for ZeroOrOne specified at Python.javacc:144:24
            if (first_set$Python_javacc$144$26.contains(nextTokenType())) {
                // Code for ZeroOrOne specified at Python.javacc:144:26
                if (nextTokenType()== STAR) {
                    // Code for RegexpStringLiteral specified at Python.javacc:144:27
                    consumeToken(STAR);
                }
                // Code for NonTerminal specified at Python.javacc:144:32
                pushOntoCallStack("ExceptBlock", "Python.javacc", 144, 32);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrOne specified at Python.javacc:144:43
                if (nextTokenType()== AS) {
                    // Code for RegexpStringLiteral specified at Python.javacc:144:44
                    consumeToken(AS);
                    // Code for RegexpRef specified at Python.javacc:144:49
                    consumeToken(NAME);
                }
            }
            // Code for RegexpStringLiteral specified at Python.javacc:144:59
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:144:63
            pushOntoCallStack("ExceptBlock", "Python.javacc", 144, 63);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException656= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize657);
            if (ExceptBlock17!=null) {
                if (parseException656== null) {
                    closeNodeScope(ExceptBlock17, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:146:1
    final public void IfStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "IfStatement";
        IfStatement IfStatement18= null;
        if (buildTree) {
            IfStatement18= new IfStatement();
            openNodeScope(IfStatement18);
        }
        ParseException parseException698= null;
        int callStackSize699= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:147:5
            consumeToken(IF);
            // Code for NonTerminal specified at Python.javacc:147:10
            pushOntoCallStack("IfStatement", "Python.javacc", 147, 10);
            try {
                NamedExpression();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:147:26
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:147:30
            pushOntoCallStack("IfStatement", "Python.javacc", 147, 30);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:148:6
            while (true) {
                if (!(nextTokenType()== ELIF)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:148:7
                consumeToken(ELIF);
                // Code for NonTerminal specified at Python.javacc:148:14
                pushOntoCallStack("IfStatement", "Python.javacc", 148, 14);
                try {
                    NamedExpression();
                }
                finally {
                    popCallStack();
                }
                // Code for RegexpStringLiteral specified at Python.javacc:148:30
                consumeToken(COLON);
                // Code for NonTerminal specified at Python.javacc:148:34
                pushOntoCallStack("IfStatement", "Python.javacc", 148, 34);
                try {
                    Block();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:149:6
            if (nextTokenType()== ELSE) {
                // Code for RegexpStringLiteral specified at Python.javacc:149:7
                consumeToken(ELSE);
                // Code for RegexpStringLiteral specified at Python.javacc:149:14
                consumeToken(COLON);
                // Code for NonTerminal specified at Python.javacc:149:18
                pushOntoCallStack("IfStatement", "Python.javacc", 149, 18);
                try {
                    Block();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException698= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize699);
            if (IfStatement18!=null) {
                if (parseException698== null) {
                    closeNodeScope(IfStatement18, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:152:1
    final public void FinallyBlock() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "FinallyBlock";
        FinallyBlock FinallyBlock19= null;
        if (buildTree) {
            FinallyBlock19= new FinallyBlock();
            openNodeScope(FinallyBlock19);
        }
        ParseException parseException746= null;
        int callStackSize747= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:152:16
            consumeToken(FINALLY);
            // Code for RegexpStringLiteral specified at Python.javacc:152:26
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:152:30
            pushOntoCallStack("FinallyBlock", "Python.javacc", 152, 30);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException746= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize747);
            if (FinallyBlock19!=null) {
                if (parseException746== null) {
                    closeNodeScope(FinallyBlock19, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:154:1
    final public void WhileStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "WhileStatement";
        WhileStatement WhileStatement20= null;
        if (buildTree) {
            WhileStatement20= new WhileStatement();
            openNodeScope(WhileStatement20);
        }
        ParseException parseException758= null;
        int callStackSize759= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:154:18
            consumeToken(WHILE);
            // Code for NonTerminal specified at Python.javacc:154:26
            pushOntoCallStack("WhileStatement", "Python.javacc", 154, 26);
            try {
                NamedExpression();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:154:42
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:154:46
            pushOntoCallStack("WhileStatement", "Python.javacc", 154, 46);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at Python.javacc:154:52
            if (nextTokenType()== ELSE) {
                // Code for NonTerminal specified at Python.javacc:154:53
                pushOntoCallStack("WhileStatement", "Python.javacc", 154, 53);
                try {
                    ElseBlock();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException758= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize759);
            if (WhileStatement20!=null) {
                if (parseException758== null) {
                    closeNodeScope(WhileStatement20, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:156:1
    final public void WithStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "WithStatement";
        WithStatement WithStatement21= null;
        if (buildTree) {
            WithStatement21= new WithStatement();
            openNodeScope(WithStatement21);
        }
        ParseException parseException782= null;
        int callStackSize783= parsingStack.size();
        try {
            // Code for ZeroOrOne specified at Python.javacc:157:5
            if (nextTokenType()== ASYNC) {
                // Code for RegexpStringLiteral specified at Python.javacc:157:6
                consumeToken(ASYNC);
            }
            // Code for RegexpStringLiteral specified at Python.javacc:157:15
            consumeToken(WITH);
            if (scan$Python_javacc$159$9()) {
                // Code for NonTerminal specified at Python.javacc:159:44
                pushOntoCallStack("WithStatement", "Python.javacc", 159, 44);
                try {
                    WithItemsInParentheses();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$161$9.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:161:9
                pushOntoCallStack("WithStatement", "Python.javacc", 161, 9);
                try {
                    WithItem();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrMore specified at Python.javacc:161:18
                while (true) {
                    if (!(nextTokenType()== COMMA)) break;
                    // Code for RegexpStringLiteral specified at Python.javacc:161:19
                    consumeToken(COMMA);
                    // Code for NonTerminal specified at Python.javacc:161:23
                    pushOntoCallStack("WithStatement", "Python.javacc", 161, 23);
                    try {
                        WithItem();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            else  {
                pushOntoCallStack("WithStatement", "Python.javacc", 159, 9);
                throw new ParseException(this, first_set$Python_javacc$159$9, parsingStack);
            }
            // Code for RegexpStringLiteral specified at Python.javacc:163:5
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:163:9
            pushOntoCallStack("WithStatement", "Python.javacc", 163, 9);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException782= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize783);
            if (WithStatement21!=null) {
                if (parseException782== null) {
                    closeNodeScope(WithStatement21, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:166:1
    final public void WithItemsInParentheses() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "WithItemsInParentheses";
        // Code for RegexpStringLiteral specified at Python.javacc:166:31
        consumeToken(LPAREN);
        // Code for NonTerminal specified at Python.javacc:166:35
        pushOntoCallStack("WithItemsInParentheses", "Python.javacc", 166, 35);
        try {
            WithItem();
        }
        finally {
            popCallStack();
        }
        // Code for ZeroOrMore specified at Python.javacc:166:44
        while (true) {
            if (!(scan$Python_javacc$166$45())) break;
            // Code for RegexpStringLiteral specified at Python.javacc:166:52
            consumeToken(COMMA);
            // Code for NonTerminal specified at Python.javacc:166:56
            pushOntoCallStack("WithItemsInParentheses", "Python.javacc", 166, 56);
            try {
                WithItem();
            }
            finally {
                popCallStack();
            }
        }
        // Code for ZeroOrOne specified at Python.javacc:166:67
        if (nextTokenType()== COMMA) {
            // Code for RegexpStringLiteral specified at Python.javacc:166:68
            consumeToken(COMMA);
        }
        // Code for RegexpStringLiteral specified at Python.javacc:166:73
        consumeToken(RPAREN);
    }

    // Python.javacc:168:1
    final public void WithItem() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "WithItem";
        WithItem WithItem22= null;
        if (buildTree) {
            WithItem22= new WithItem();
            openNodeScope(WithItem22);
        }
        ParseException parseException864= null;
        int callStackSize865= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:168:12
            pushOntoCallStack("WithItem", "Python.javacc", 168, 12);
            try {
                Expression();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at Python.javacc:168:23
            if (nextTokenType()== AS) {
                // Code for RegexpStringLiteral specified at Python.javacc:168:24
                consumeToken(AS);
                // Code for NonTerminal specified at Python.javacc:168:29
                pushOntoCallStack("WithItem", "Python.javacc", 168, 29);
                try {
                    StarTarget();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException864= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize865);
            if (WithItem22!=null) {
                if (parseException864== null) {
                    closeNodeScope(WithItem22, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:170:1
    final public void ForStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ForStatement";
        ForStatement ForStatement23= null;
        if (buildTree) {
            ForStatement23= new ForStatement();
            openNodeScope(ForStatement23);
        }
        ParseException parseException882= null;
        int callStackSize883= parsingStack.size();
        try {
            // Code for ZeroOrOne specified at Python.javacc:171:4
            if (nextTokenType()== ASYNC) {
                // Code for RegexpStringLiteral specified at Python.javacc:171:5
                consumeToken(ASYNC);
            }
            // Code for RegexpStringLiteral specified at Python.javacc:171:14
            consumeToken(FOR);
            // Code for NonTerminal specified at Python.javacc:172:4
            pushOntoCallStack("ForStatement", "Python.javacc", 172, 4);
            try {
                StarTargets();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:172:16
            consumeToken(IN);
            // Code for NonTerminal specified at Python.javacc:172:21
            pushOntoCallStack("ForStatement", "Python.javacc", 172, 21);
            try {
                StarExpressions();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:172:37
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:173:4
            pushOntoCallStack("ForStatement", "Python.javacc", 173, 4);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at Python.javacc:173:10
            if (nextTokenType()== ELSE) {
                // Code for NonTerminal specified at Python.javacc:173:11
                pushOntoCallStack("ForStatement", "Python.javacc", 173, 11);
                try {
                    ElseBlock();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException882= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize883);
            if (ForStatement23!=null) {
                if (parseException882== null) {
                    closeNodeScope(ForStatement23, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:176:1
    final public void TryStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "TryStatement";
        TryStatement TryStatement24= null;
        if (buildTree) {
            TryStatement24= new TryStatement();
            openNodeScope(TryStatement24);
        }
        ParseException parseException921= null;
        int callStackSize922= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:177:4
            consumeToken(TRY);
            // Code for RegexpStringLiteral specified at Python.javacc:177:10
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:177:14
            pushOntoCallStack("TryStatement", "Python.javacc", 177, 14);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
            if (nextTokenType()== FINALLY) {
                // Code for NonTerminal specified at Python.javacc:179:8
                pushOntoCallStack("TryStatement", "Python.javacc", 179, 8);
                try {
                    FinallyBlock();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== EXCEPT) {
                // Code for OneOrMore specified at Python.javacc:181:9
                while (true) {
                    // Code for NonTerminal specified at Python.javacc:181:10
                    pushOntoCallStack("TryStatement", "Python.javacc", 181, 10);
                    try {
                        ExceptBlock();
                    }
                    finally {
                        popCallStack();
                    }
                    if (!(nextTokenType()== EXCEPT)) break;
                }
                // Code for ZeroOrOne specified at Python.javacc:181:24
                if (nextTokenType()== ELSE) {
                    // Code for NonTerminal specified at Python.javacc:181:25
                    pushOntoCallStack("TryStatement", "Python.javacc", 181, 25);
                    try {
                        ElseBlock();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for ZeroOrOne specified at Python.javacc:181:36
                if (nextTokenType()== FINALLY) {
                    // Code for NonTerminal specified at Python.javacc:181:37
                    pushOntoCallStack("TryStatement", "Python.javacc", 181, 37);
                    try {
                        FinallyBlock();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            else  {
                pushOntoCallStack("TryStatement", "Python.javacc", 179, 8);
                throw new ParseException(this, first_set$Python_javacc$179$8, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException921= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize922);
            if (TryStatement24!=null) {
                if (parseException921== null) {
                    closeNodeScope(TryStatement24, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:185:1
    final public void DelStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "DelStatement";
        DelStatement DelStatement25= null;
        if (buildTree) {
            DelStatement25= new DelStatement();
            openNodeScope(DelStatement25);
        }
        ParseException parseException977= null;
        int callStackSize978= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:185:16
            consumeToken(DEL);
            // Code for NonTerminal specified at Python.javacc:185:22
            pushOntoCallStack("DelStatement", "Python.javacc", 185, 22);
            try {
                PrimaryExpression();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:185:40
            while (true) {
                if (!(scan$Python_javacc$185$41())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:185:48
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:185:52
                pushOntoCallStack("DelStatement", "Python.javacc", 185, 52);
                try {
                    PrimaryExpression();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:185:72
            if (nextTokenType()== COMMA) {
                // Code for RegexpStringLiteral specified at Python.javacc:185:73
                consumeToken(COMMA);
            }
        }
        catch(ParseException e) {
            parseException977= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize978);
            if (DelStatement25!=null) {
                if (parseException977== null) {
                    closeNodeScope(DelStatement25, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:187:1
    final public void NamedExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "NamedExpression";
        NamedExpression NamedExpression26= null;
        if (buildTree) {
            NamedExpression26= new NamedExpression();
            openNodeScope(NamedExpression26);
        }
        ParseException parseException1007= null;
        int callStackSize1008= parsingStack.size();
        try {
            // Code for ZeroOrOne specified at Python.javacc:187:19
            if (scan$Python_javacc$187$21()) {
                // Code for RegexpRef specified at Python.javacc:187:24
                consumeToken(NAME);
                // Code for RegexpStringLiteral specified at Python.javacc:187:31
                consumeToken(COLONEQUALS);
            }
            // Code for NonTerminal specified at Python.javacc:187:38
            pushOntoCallStack("NamedExpression", "Python.javacc", 187, 38);
            try {
                Expression();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException1007= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1008);
            if (NamedExpression26!=null) {
                if (parseException1007== null) {
                    closeNodeScope(NamedExpression26, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:189:1
    final public void DottedName() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "DottedName";
        DottedName DottedName27= null;
        if (buildTree) {
            DottedName27= new DottedName();
            openNodeScope(DottedName27);
        }
        ParseException parseException1025= null;
        int callStackSize1026= parsingStack.size();
        try {
            // Code for RegexpRef specified at Python.javacc:189:14
            consumeToken(NAME);
            // Code for ZeroOrMore specified at Python.javacc:189:21
            while (true) {
                if (!(scan$Python_javacc$189$22())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:189:25
                consumeToken(DOT);
                // Code for RegexpRef specified at Python.javacc:189:29
                consumeToken(NAME);
            }
        }
        catch(ParseException e) {
            parseException1025= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1026);
            if (DottedName27!=null) {
                if (parseException1025== null) {
                    closeNodeScope(DottedName27, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> ImportStatement_FIRST_SET= tokenTypeSet(FROM, IMPORT);
    // Python.javacc:191:1
    final public void ImportStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ImportStatement";
        // Code for ExpansionChoice specified at Python.javacc:191:19
        ImportStatement ImportStatement28= null;
        if (buildTree) {
            ImportStatement28= new ImportStatement();
            openNodeScope(ImportStatement28);
        }
        ParseException parseException1043= null;
        int callStackSize1044= parsingStack.size();
        try {
            if (nextTokenType()== IMPORT) {
                // Code for NonTerminal specified at Python.javacc:191:19
                pushOntoCallStack("ImportStatement", "Python.javacc", 191, 19);
                try {
                    ImportName();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$Python_javacc$191$32()) {
                // Code for NonTerminal specified at Python.javacc:191:32
                pushOntoCallStack("ImportStatement", "Python.javacc", 191, 32);
                try {
                    ImportFrom1();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$Python_javacc$191$46()) {
                // Code for NonTerminal specified at Python.javacc:191:46
                pushOntoCallStack("ImportStatement", "Python.javacc", 191, 46);
                try {
                    ImportFrom2();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("ImportStatement", "Python.javacc", 191, 19);
                throw new ParseException(this, ImportStatement_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException1043= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1044);
            if (ImportStatement28!=null) {
                if (parseException1043== null) {
                    closeNodeScope(ImportStatement28, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:193:1
    final public void ImportName() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ImportName";
        // Code for RegexpStringLiteral specified at Python.javacc:193:19
        consumeToken(IMPORT);
        // Code for NonTerminal specified at Python.javacc:193:28
        pushOntoCallStack("ImportName", "Python.javacc", 193, 28);
        try {
            DottedName();
        }
        finally {
            popCallStack();
        }
        // Code for ZeroOrOne specified at Python.javacc:193:39
        if (nextTokenType()== AS) {
            // Code for RegexpStringLiteral specified at Python.javacc:193:40
            consumeToken(AS);
            // Code for RegexpRef specified at Python.javacc:193:45
            consumeToken(NAME);
        }
        // Code for ZeroOrMore specified at Python.javacc:193:53
        while (true) {
            if (!(nextTokenType()== COMMA)) break;
            // Code for RegexpStringLiteral specified at Python.javacc:193:54
            consumeToken(COMMA);
            // Code for NonTerminal specified at Python.javacc:193:58
            pushOntoCallStack("ImportName", "Python.javacc", 193, 58);
            try {
                DottedName();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at Python.javacc:193:69
            if (nextTokenType()== AS) {
                // Code for RegexpStringLiteral specified at Python.javacc:193:70
                consumeToken(AS);
                // Code for RegexpRef specified at Python.javacc:193:75
                consumeToken(NAME);
            }
        }
    }

    // Python.javacc:195:1
    final public void ImportFrom1() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ImportFrom1";
        // Code for RegexpStringLiteral specified at Python.javacc:195:20
        consumeToken(FROM);
        // Code for ZeroOrMore specified at Python.javacc:195:27
        while (true) {
            // Code for ExpansionChoice specified at Python.javacc:195:28
            if (nextTokenType()== DOT) {
                // Code for RegexpStringLiteral specified at Python.javacc:195:28
                consumeToken(DOT);
            }
            else if (nextTokenType()== ELLIPSIS) {
                // Code for RegexpStringLiteral specified at Python.javacc:195:34
                consumeToken(ELLIPSIS);
            }
            else  {
                break;
            }
        }
        // Code for NonTerminal specified at Python.javacc:195:42
        pushOntoCallStack("ImportFrom1", "Python.javacc", 195, 42);
        try {
            DottedName();
        }
        finally {
            popCallStack();
        }
        // Code for RegexpStringLiteral specified at Python.javacc:195:58
        consumeToken(IMPORT);
        // Code for NonTerminal specified at Python.javacc:195:68
        pushOntoCallStack("ImportFrom1", "Python.javacc", 195, 68);
        try {
            ImportFromTargets();
        }
        finally {
            popCallStack();
        }
    }

    // Python.javacc:197:1
    final public void ImportFrom2() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ImportFrom2";
        // Code for RegexpStringLiteral specified at Python.javacc:197:20
        consumeToken(FROM);
        // Code for OneOrMore specified at Python.javacc:197:27
        boolean inFirst0= true;
        while (true) {
            // Code for ExpansionChoice specified at Python.javacc:197:28
            if (nextTokenType()== DOT) {
                // Code for RegexpStringLiteral specified at Python.javacc:197:28
                consumeToken(DOT);
            }
            else if (nextTokenType()== ELLIPSIS) {
                // Code for RegexpStringLiteral specified at Python.javacc:197:34
                consumeToken(ELLIPSIS);
            }
            else if (inFirst0) {
                pushOntoCallStack("ImportFrom2", "Python.javacc", 197, 28);
                throw new ParseException(this, first_set$Python_javacc$197$28, parsingStack);
            }
            else  {
                break;
            }
            inFirst0= false;
        }
        // Code for RegexpStringLiteral specified at Python.javacc:197:42
        consumeToken(IMPORT);
        // Code for NonTerminal specified at Python.javacc:197:56
        pushOntoCallStack("ImportFrom2", "Python.javacc", 197, 56);
        try {
            ImportFromTargets();
        }
        finally {
            popCallStack();
        }
    }

    static private final EnumSet<TokenType> ImportFromTargets_FIRST_SET= tokenTypeSet(LPAREN, STAR, NAME);
    // Python.javacc:199:1
    final public void ImportFromTargets() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ImportFromTargets";
        // Code for ExpansionChoice specified at Python.javacc:200:4
        ImportFromTargets ImportFromTargets29= null;
        if (buildTree) {
            ImportFromTargets29= new ImportFromTargets();
            openNodeScope(ImportFromTargets29);
        }
        ParseException parseException1172= null;
        int callStackSize1173= parsingStack.size();
        try {
            if (nextTokenType()== STAR) {
                // Code for RegexpStringLiteral specified at Python.javacc:200:4
                consumeToken(STAR);
            }
            else if (nextTokenType()== NAME) {
                // Code for RegexpRef specified at Python.javacc:202:4
                consumeToken(NAME);
                // Code for ZeroOrOne specified at Python.javacc:202:11
                if (nextTokenType()== AS) {
                    // Code for RegexpStringLiteral specified at Python.javacc:202:12
                    consumeToken(AS);
                    // Code for RegexpRef specified at Python.javacc:202:17
                    consumeToken(NAME);
                }
                // Code for ZeroOrMore specified at Python.javacc:202:25
                while (true) {
                    if (!(scan$Python_javacc$202$26())) break;
                    // Code for RegexpStringLiteral specified at Python.javacc:202:26
                    consumeToken(COMMA);
                    // Code for RegexpRef specified at Python.javacc:202:30
                    consumeToken(NAME);
                    // Code for ZeroOrOne specified at Python.javacc:202:42
                    if (nextTokenType()== AS) {
                        // Code for RegexpStringLiteral specified at Python.javacc:202:43
                        consumeToken(AS);
                        // Code for RegexpRef specified at Python.javacc:202:48
                        consumeToken(NAME);
                    }
                }
                // Code for ZeroOrOne specified at Python.javacc:202:58
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:202:59
                    consumeToken(COMMA);
                }
            }
            else if (nextTokenType()== LPAREN) {
                // Code for RegexpStringLiteral specified at Python.javacc:204:4
                consumeToken(LPAREN);
                // Code for RegexpRef specified at Python.javacc:204:8
                consumeToken(NAME);
                // Code for ZeroOrOne specified at Python.javacc:204:15
                if (nextTokenType()== AS) {
                    // Code for RegexpStringLiteral specified at Python.javacc:204:16
                    consumeToken(AS);
                    // Code for RegexpRef specified at Python.javacc:204:21
                    consumeToken(NAME);
                }
                // Code for ZeroOrMore specified at Python.javacc:204:29
                while (true) {
                    if (!(scan$Python_javacc$204$30())) break;
                    // Code for RegexpStringLiteral specified at Python.javacc:204:30
                    consumeToken(COMMA);
                    // Code for RegexpRef specified at Python.javacc:204:34
                    consumeToken(NAME);
                    // Code for ZeroOrOne specified at Python.javacc:204:46
                    if (nextTokenType()== AS) {
                        // Code for RegexpStringLiteral specified at Python.javacc:204:47
                        consumeToken(AS);
                        // Code for RegexpRef specified at Python.javacc:204:52
                        consumeToken(NAME);
                    }
                }
                // Code for ZeroOrOne specified at Python.javacc:204:62
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:204:63
                    consumeToken(COMMA);
                }
                // Code for RegexpStringLiteral specified at Python.javacc:204:68
                consumeToken(RPAREN);
                // Code for ZeroOrOne specified at Python.javacc:204:72
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:204:73
                    consumeToken(COMMA);
                }
            }
            else  {
                pushOntoCallStack("ImportFromTargets", "Python.javacc", 200, 4);
                throw new ParseException(this, ImportFromTargets_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException1172= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1173);
            if (ImportFromTargets29!=null) {
                if (parseException1172== null) {
                    closeNodeScope(ImportFromTargets29, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> StarNamedExpression_FIRST_SET= StarNamedExpression_FIRST_SET_init();
    static private EnumSet<TokenType> StarNamedExpression_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:207:1
    final public void StarNamedExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "StarNamedExpression";
        // Code for ExpansionChoice specified at Python.javacc:208:6
        StarNamedExpression StarNamedExpression30= null;
        if (buildTree) {
            StarNamedExpression30= new StarNamedExpression();
            openNodeScope(StarNamedExpression30);
        }
        ParseException parseException1298= null;
        int callStackSize1299= parsingStack.size();
        try {
            if (nextTokenType()== STAR) {
                // Code for RegexpStringLiteral specified at Python.javacc:208:6
                consumeToken(STAR);
                // Code for NonTerminal specified at Python.javacc:208:10
                pushOntoCallStack("StarNamedExpression", "Python.javacc", 208, 10);
                try {
                    BitwiseOr();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$210$6.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:210:6
                pushOntoCallStack("StarNamedExpression", "Python.javacc", 210, 6);
                try {
                    NamedExpression();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("StarNamedExpression", "Python.javacc", 208, 6);
                throw new ParseException(this, StarNamedExpression_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException1298= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1299);
            if (StarNamedExpression30!=null) {
                if (parseException1298== null) {
                    closeNodeScope(StarNamedExpression30, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> StarExpression_FIRST_SET= StarExpression_FIRST_SET_init();
    static private EnumSet<TokenType> StarExpression_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:213:1
    final public void StarExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "StarExpression";
        // Code for ExpansionChoice specified at Python.javacc:214:5
        StarExpression StarExpression31= null;
        if (buildTree) {
            StarExpression31= new StarExpression();
            openNodeScope(StarExpression31);
        }
        ParseException parseException1316= null;
        int callStackSize1317= parsingStack.size();
        try {
            if (nextTokenType()== STAR) {
                // Code for RegexpStringLiteral specified at Python.javacc:214:5
                consumeToken(STAR);
                // Code for NonTerminal specified at Python.javacc:214:9
                pushOntoCallStack("StarExpression", "Python.javacc", 214, 9);
                try {
                    BitwiseOr();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$216$5.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:216:5
                pushOntoCallStack("StarExpression", "Python.javacc", 216, 5);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("StarExpression", "Python.javacc", 214, 5);
                throw new ParseException(this, StarExpression_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException1316= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1317);
            if (StarExpression31!=null) {
                if (parseException1316== null) {
                    closeNodeScope(StarExpression31, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:219:1
    final public void StarExpressions() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "StarExpressions";
        StarExpressions StarExpressions32= null;
        if (buildTree) {
            StarExpressions32= new StarExpressions();
            openNodeScope(StarExpressions32);
        }
        ParseException parseException1334= null;
        int callStackSize1335= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:219:19
            pushOntoCallStack("StarExpressions", "Python.javacc", 219, 19);
            try {
                StarExpression();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:219:34
            while (true) {
                if (!(scan$Python_javacc$219$35())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:219:35
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:219:45
                pushOntoCallStack("StarExpressions", "Python.javacc", 219, 45);
                try {
                    StarExpression();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:219:62
            if (nextTokenType()== COMMA) {
                // Code for RegexpStringLiteral specified at Python.javacc:219:63
                consumeToken(COMMA);
            }
        }
        catch(ParseException e) {
            parseException1334= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1335);
            if (StarExpressions32!=null) {
                if (parseException1334== null) {
                    closeNodeScope(StarExpressions32, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:221:1
    final public void StarNamedExpressions() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "StarNamedExpressions";
        StarNamedExpressions StarNamedExpressions33= null;
        if (buildTree) {
            StarNamedExpressions33= new StarNamedExpressions();
            openNodeScope(StarNamedExpressions33);
        }
        ParseException parseException1361= null;
        int callStackSize1362= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:221:24
            pushOntoCallStack("StarNamedExpressions", "Python.javacc", 221, 24);
            try {
                StarNamedExpression();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:221:44
            while (true) {
                if (!(scan$Python_javacc$221$45())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:221:45
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:221:55
                pushOntoCallStack("StarNamedExpressions", "Python.javacc", 221, 55);
                try {
                    StarNamedExpression();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:221:77
            if (nextTokenType()== COMMA) {
                // Code for RegexpStringLiteral specified at Python.javacc:221:78
                consumeToken(COMMA);
            }
        }
        catch(ParseException e) {
            parseException1361= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1362);
            if (StarNamedExpressions33!=null) {
                if (parseException1361== null) {
                    closeNodeScope(StarNamedExpressions33, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:223:1
    final public void BitwiseOr() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "BitwiseOr";
        BitwiseOr BitwiseOr34= null;
        if (buildTree) {
            BitwiseOr34= new BitwiseOr();
            openNodeScope(BitwiseOr34);
        }
        ParseException parseException1388= null;
        int callStackSize1389= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:223:13
            pushOntoCallStack("BitwiseOr", "Python.javacc", 223, 13);
            try {
                BitwiseXor();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:223:24
            while (true) {
                if (!(nextTokenType()== BIT_OR)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:223:25
                consumeToken(BIT_OR);
                // Code for NonTerminal specified at Python.javacc:223:29
                pushOntoCallStack("BitwiseOr", "Python.javacc", 223, 29);
                try {
                    BitwiseXor();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException1388= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1389);
            if (BitwiseOr34!=null) {
                if (parseException1388== null) {
                    closeNodeScope(BitwiseOr34, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:225:1
    final public void BitwiseXor() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "BitwiseXor";
        BitwiseXor BitwiseXor35= null;
        if (buildTree) {
            BitwiseXor35= new BitwiseXor();
            openNodeScope(BitwiseXor35);
        }
        ParseException parseException1406= null;
        int callStackSize1407= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:225:14
            pushOntoCallStack("BitwiseXor", "Python.javacc", 225, 14);
            try {
                BitwiseAnd();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:225:25
            while (true) {
                if (!(nextTokenType()== XOR)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:225:26
                consumeToken(XOR);
                // Code for NonTerminal specified at Python.javacc:225:30
                pushOntoCallStack("BitwiseXor", "Python.javacc", 225, 30);
                try {
                    BitwiseAnd();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException1406= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1407);
            if (BitwiseXor35!=null) {
                if (parseException1406== null) {
                    closeNodeScope(BitwiseXor35, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:227:1
    final public void BitwiseAnd() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "BitwiseAnd";
        BitwiseAnd BitwiseAnd36= null;
        if (buildTree) {
            BitwiseAnd36= new BitwiseAnd();
            openNodeScope(BitwiseAnd36);
        }
        ParseException parseException1424= null;
        int callStackSize1425= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:227:14
            pushOntoCallStack("BitwiseAnd", "Python.javacc", 227, 14);
            try {
                ShiftExpression();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:227:30
            while (true) {
                if (!(nextTokenType()== BIT_AND)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:227:31
                consumeToken(BIT_AND);
                // Code for NonTerminal specified at Python.javacc:227:35
                pushOntoCallStack("BitwiseAnd", "Python.javacc", 227, 35);
                try {
                    ShiftExpression();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException1424= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1425);
            if (BitwiseAnd36!=null) {
                if (parseException1424== null) {
                    closeNodeScope(BitwiseAnd36, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:229:1
    final public void ShiftExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ShiftExpression";
        ShiftExpression ShiftExpression37= null;
        if (buildTree) {
            ShiftExpression37= new ShiftExpression();
            openNodeScope(ShiftExpression37);
        }
        ParseException parseException1442= null;
        int callStackSize1443= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:229:19
            pushOntoCallStack("ShiftExpression", "Python.javacc", 229, 19);
            try {
                AdditiveExpression();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:229:38
            while (true) {
                if (!(nextTokenType()== LSHIFT||nextTokenType== RSHIFT)) break;
                if (nextTokenType()== LSHIFT) {
                    // Code for RegexpStringLiteral specified at Python.javacc:229:40
                    consumeToken(LSHIFT);
                }
                else if (nextTokenType()== RSHIFT) {
                    // Code for RegexpStringLiteral specified at Python.javacc:229:47
                    consumeToken(RSHIFT);
                }
                else  {
                    pushOntoCallStack("ShiftExpression", "Python.javacc", 229, 40);
                    throw new ParseException(this, first_set$Python_javacc$229$40, parsingStack);
                }
                // Code for NonTerminal specified at Python.javacc:229:53
                pushOntoCallStack("ShiftExpression", "Python.javacc", 229, 53);
                try {
                    AdditiveExpression();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException1442= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1443);
            if (ShiftExpression37!=null) {
                if (parseException1442== null) {
                    closeNodeScope(ShiftExpression37, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:231:1
    final public void AdditiveExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "AdditiveExpression";
        AdditiveExpression AdditiveExpression38= null;
        if (buildTree) {
            AdditiveExpression38= new AdditiveExpression();
            openNodeScope(AdditiveExpression38);
        }
        ParseException parseException1473= null;
        int callStackSize1474= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:231:22
            pushOntoCallStack("AdditiveExpression", "Python.javacc", 231, 22);
            try {
                MultiplicativeExpression();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:231:47
            while (true) {
                if (!(nextTokenType()== MINUS||nextTokenType== PLUS)) break;
                if (nextTokenType()== PLUS) {
                    // Code for RegexpStringLiteral specified at Python.javacc:231:49
                    consumeToken(PLUS);
                }
                else if (nextTokenType()== MINUS) {
                    // Code for RegexpStringLiteral specified at Python.javacc:231:53
                    consumeToken(MINUS);
                }
                else  {
                    pushOntoCallStack("AdditiveExpression", "Python.javacc", 231, 49);
                    throw new ParseException(this, first_set$Python_javacc$231$49, parsingStack);
                }
                // Code for NonTerminal specified at Python.javacc:231:58
                pushOntoCallStack("AdditiveExpression", "Python.javacc", 231, 58);
                try {
                    MultiplicativeExpression();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException1473= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1474);
            if (AdditiveExpression38!=null) {
                if (parseException1473== null) {
                    closeNodeScope(AdditiveExpression38, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:233:1
    final public void MultiplicativeExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MultiplicativeExpression";
        MultiplicativeExpression MultiplicativeExpression39= null;
        if (buildTree) {
            MultiplicativeExpression39= new MultiplicativeExpression();
            openNodeScope(MultiplicativeExpression39);
        }
        ParseException parseException1504= null;
        int callStackSize1505= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:233:28
            pushOntoCallStack("MultiplicativeExpression", "Python.javacc", 233, 28);
            try {
                UnaryExpression();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:233:44
            while (true) {
                if (!(first_set$Python_javacc$233$45.contains(nextTokenType()))) break;
                if (nextTokenType()== STAR) {
                    // Code for RegexpStringLiteral specified at Python.javacc:233:46
                    consumeToken(STAR);
                }
                else if (nextTokenType()== SLASH) {
                    // Code for RegexpStringLiteral specified at Python.javacc:233:50
                    consumeToken(SLASH);
                }
                else if (nextTokenType()== _TOKEN_100) {
                    // Code for RegexpStringLiteral specified at Python.javacc:233:54
                    consumeToken(_TOKEN_100);
                }
                else if (nextTokenType()== PERCENT) {
                    // Code for RegexpStringLiteral specified at Python.javacc:233:59
                    consumeToken(PERCENT);
                }
                else if (nextTokenType()== AT) {
                    // Code for RegexpStringLiteral specified at Python.javacc:233:63
                    consumeToken(AT);
                }
                else  {
                    pushOntoCallStack("MultiplicativeExpression", "Python.javacc", 233, 46);
                    throw new ParseException(this, first_set$Python_javacc$233$46, parsingStack);
                }
                // Code for NonTerminal specified at Python.javacc:233:68
                pushOntoCallStack("MultiplicativeExpression", "Python.javacc", 233, 68);
                try {
                    UnaryExpression();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException1504= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1505);
            if (MultiplicativeExpression39!=null) {
                if (parseException1504== null) {
                    closeNodeScope(MultiplicativeExpression39, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> UnaryExpression_FIRST_SET= UnaryExpression_FIRST_SET_init();
    static private EnumSet<TokenType> UnaryExpression_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, NONE, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:235:1
    final public void UnaryExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "UnaryExpression";
        // Code for ExpansionChoice specified at Python.javacc:235:19
        UnaryExpression UnaryExpression40= null;
        if (buildTree) {
            UnaryExpression40= new UnaryExpression();
            openNodeScope(UnaryExpression40);
        }
        ParseException parseException1553= null;
        int callStackSize1554= parsingStack.size();
        try {
            if (first_set$Python_javacc$235$19.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:235:19
                pushOntoCallStack("UnaryExpression", "Python.javacc", 235, 19);
                try {
                    Power();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== TILDE||nextTokenType== MINUS||nextTokenType== PLUS) {
                if (nextTokenType()== PLUS) {
                    // Code for RegexpStringLiteral specified at Python.javacc:235:28
                    consumeToken(PLUS);
                }
                else if (nextTokenType()== MINUS) {
                    // Code for RegexpStringLiteral specified at Python.javacc:235:34
                    consumeToken(MINUS);
                }
                else if (nextTokenType()== TILDE) {
                    // Code for RegexpStringLiteral specified at Python.javacc:235:40
                    consumeToken(TILDE);
                }
                else  {
                    pushOntoCallStack("UnaryExpression", "Python.javacc", 235, 28);
                    throw new ParseException(this, first_set$Python_javacc$235$28, parsingStack);
                }
                // Code for NonTerminal specified at Python.javacc:235:45
                pushOntoCallStack("UnaryExpression", "Python.javacc", 235, 45);
                try {
                    UnaryExpression();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("UnaryExpression", "Python.javacc", 235, 19);
                throw new ParseException(this, UnaryExpression_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException1553= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1554);
            if (UnaryExpression40!=null) {
                if (parseException1553== null) {
                    closeNodeScope(UnaryExpression40, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:237:1
    final public void Power() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Power";
        Power Power41= null;
        if (buildTree) {
            Power41= new Power();
            openNodeScope(Power41);
        }
        ParseException parseException1590= null;
        int callStackSize1591= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:237:9
            pushOntoCallStack("Power", "Python.javacc", 237, 9);
            try {
                AwaitPrimary();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at Python.javacc:237:22
            if (nextTokenType()== STAR_STAR) {
                // Code for RegexpStringLiteral specified at Python.javacc:237:23
                consumeToken(STAR_STAR);
                // Code for NonTerminal specified at Python.javacc:237:28
                pushOntoCallStack("Power", "Python.javacc", 237, 28);
                try {
                    UnaryExpression();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException1590= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1591);
            if (Power41!=null) {
                if (parseException1590== null) {
                    closeNodeScope(Power41, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:239:1
    final public void Tuple() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Tuple";
        Tuple Tuple42= null;
        if (buildTree) {
            Tuple42= new Tuple();
            openNodeScope(Tuple42);
        }
        ParseException parseException1608= null;
        int callStackSize1609= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:241:5
            consumeToken(LPAREN);
            // Code for ZeroOrOne specified at Python.javacc:241:9
            if (first_set$Python_javacc$241$10.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:241:10
                pushOntoCallStack("Tuple", "Python.javacc", 241, 10);
                try {
                    StarNamedExpression();
                }
                finally {
                    popCallStack();
                }
                // Code for RegexpStringLiteral specified at Python.javacc:241:30
                consumeToken(COMMA);
                // Code for ZeroOrOne specified at Python.javacc:241:34
                if (first_set$Python_javacc$241$35.contains(nextTokenType())) {
                    // Code for NonTerminal specified at Python.javacc:241:35
                    pushOntoCallStack("Tuple", "Python.javacc", 241, 35);
                    try {
                        StarNamedExpressions();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            // Code for RegexpStringLiteral specified at Python.javacc:241:58
            consumeToken(RPAREN);
        }
        catch(ParseException e) {
            parseException1608= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1609);
            if (Tuple42!=null) {
                if (parseException1608== null) {
                    closeNodeScope(Tuple42, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:244:1
    final public void Group() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Group";
        Group Group43= null;
        if (buildTree) {
            Group43= new Group();
            openNodeScope(Group43);
        }
        ParseException parseException1638= null;
        int callStackSize1639= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:244:9
            consumeToken(LPAREN);
            if (nextTokenType()== YIELD) {
                // Code for NonTerminal specified at Python.javacc:244:14
                pushOntoCallStack("Group", "Python.javacc", 244, 14);
                try {
                    YieldExpression();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$244$32.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:244:32
                pushOntoCallStack("Group", "Python.javacc", 244, 32);
                try {
                    NamedExpression();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("Group", "Python.javacc", 244, 14);
                throw new ParseException(this, first_set$Python_javacc$244$14, parsingStack);
            }
            // Code for RegexpStringLiteral specified at Python.javacc:244:49
            consumeToken(RPAREN);
        }
        catch(ParseException e) {
            parseException1638= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1639);
            if (Group43!=null) {
                if (parseException1638== null) {
                    closeNodeScope(Group43, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:246:1
    final public void AwaitPrimary() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "AwaitPrimary";
        AwaitPrimary AwaitPrimary44= null;
        if (buildTree) {
            AwaitPrimary44= new AwaitPrimary();
            openNodeScope(AwaitPrimary44);
        }
        ParseException parseException1663= null;
        int callStackSize1664= parsingStack.size();
        try {
            // Code for ZeroOrOne specified at Python.javacc:246:16
            if (nextTokenType()== AWAIT) {
                // Code for RegexpStringLiteral specified at Python.javacc:246:17
                consumeToken(AWAIT);
            }
            // Code for NonTerminal specified at Python.javacc:246:26
            pushOntoCallStack("AwaitPrimary", "Python.javacc", 246, 26);
            try {
                PrimaryExpression();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException1663= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1664);
            if (AwaitPrimary44!=null) {
                if (parseException1663== null) {
                    closeNodeScope(AwaitPrimary44, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:248:1
    final public void PrimaryExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "PrimaryExpression";
        // Code for NonTerminal specified at Python.javacc:249:4
        pushOntoCallStack("PrimaryExpression", "Python.javacc", 249, 4);
        try {
            AtomicExpression();
        }
        finally {
            popCallStack();
        }
        // Code for ZeroOrMore specified at Python.javacc:250:4
        while (true) {
            // Code for ExpansionChoice specified at Python.javacc:251:8
            if (nextTokenType()== DOT) {
                // Code for RegexpStringLiteral specified at Python.javacc:251:8
                consumeToken(DOT);
                // Code for RegexpRef specified at Python.javacc:251:12
                DotName PrimaryExpression45= null;
                if (buildTree) {
                    PrimaryExpression45= new DotName();
                    openNodeScope(PrimaryExpression45);
                }
                ParseException parseException1696= null;
                int callStackSize1697= parsingStack.size();
                try {
                    consumeToken(NAME);
                }
                catch(ParseException e) {
                    parseException1696= e;
                    throw e;
                }
                finally {
                    restoreCallStack(callStackSize1697);
                    if (PrimaryExpression45!=null) {
                        if (parseException1696== null) {
                            closeNodeScope(PrimaryExpression45, 3);
                        }
                        else  {
                            clearNodeScope();
                        }
                    }
                    this.currentlyParsedProduction= prevProduction;
                }
            }
            else if (nextTokenType()== LBRACKET) {
                // Code for NonTerminal specified at Python.javacc:253:8
                SliceExpression PrimaryExpression46= null;
                if (buildTree) {
                    PrimaryExpression46= new SliceExpression();
                    openNodeScope(PrimaryExpression46);
                }
                ParseException parseException1702= null;
                int callStackSize1703= parsingStack.size();
                try {
                    pushOntoCallStack("PrimaryExpression", "Python.javacc", 253, 8);
                    try {
                        Slices();
                    }
                    finally {
                        popCallStack();
                    }
                }
                catch(ParseException e) {
                    parseException1702= e;
                    throw e;
                }
                finally {
                    restoreCallStack(callStackSize1703);
                    if (PrimaryExpression46!=null) {
                        if (parseException1702== null) {
                            closeNodeScope(PrimaryExpression46, 2);
                        }
                        else  {
                            clearNodeScope();
                        }
                    }
                    this.currentlyParsedProduction= prevProduction;
                }
            }
            else if (scan$Python_javacc$255$8()) {
                // Code for NonTerminal specified at Python.javacc:255:8
                GenExpression PrimaryExpression47= null;
                if (buildTree) {
                    PrimaryExpression47= new GenExpression();
                    openNodeScope(PrimaryExpression47);
                }
                ParseException parseException1708= null;
                int callStackSize1709= parsingStack.size();
                try {
                    pushOntoCallStack("PrimaryExpression", "Python.javacc", 255, 8);
                    try {
                        GenExp();
                    }
                    finally {
                        popCallStack();
                    }
                }
                catch(ParseException e) {
                    parseException1708= e;
                    throw e;
                }
                finally {
                    restoreCallStack(callStackSize1709);
                    if (PrimaryExpression47!=null) {
                        if (parseException1708== null) {
                            closeNodeScope(PrimaryExpression47, 2);
                        }
                        else  {
                            clearNodeScope();
                        }
                    }
                    this.currentlyParsedProduction= prevProduction;
                }
            }
            else if (nextTokenType()== LPAREN) {
                // Code for NonTerminal specified at Python.javacc:257:8
                FunctionCall PrimaryExpression48= null;
                if (buildTree) {
                    PrimaryExpression48= new FunctionCall();
                    openNodeScope(PrimaryExpression48);
                }
                ParseException parseException1714= null;
                int callStackSize1715= parsingStack.size();
                try {
                    pushOntoCallStack("PrimaryExpression", "Python.javacc", 257, 8);
                    try {
                        InvocationArguments();
                    }
                    finally {
                        popCallStack();
                    }
                }
                catch(ParseException e) {
                    parseException1714= e;
                    throw e;
                }
                finally {
                    restoreCallStack(callStackSize1715);
                    if (PrimaryExpression48!=null) {
                        if (parseException1714== null) {
                            closeNodeScope(PrimaryExpression48, 2);
                        }
                        else  {
                            clearNodeScope();
                        }
                    }
                    this.currentlyParsedProduction= prevProduction;
                }
            }
            else  {
                break;
            }
        }
    }

    static private final EnumSet<TokenType> YieldExpression_FIRST_SET= tokenTypeSet(YIELD);
    // Python.javacc:261:1
    final public void YieldExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "YieldExpression";
        // Code for ExpansionChoice specified at Python.javacc:262:5
        YieldExpression YieldExpression49= null;
        if (buildTree) {
            YieldExpression49= new YieldExpression();
            openNodeScope(YieldExpression49);
        }
        ParseException parseException1717= null;
        int callStackSize1718= parsingStack.size();
        try {
            if (scan$Python_javacc$262$5()) {
                // Code for RegexpStringLiteral specified at Python.javacc:262:5
                consumeToken(YIELD);
                // Code for RegexpStringLiteral specified at Python.javacc:262:13
                consumeToken(FROM);
                // Code for NonTerminal specified at Python.javacc:262:25
                pushOntoCallStack("YieldExpression", "Python.javacc", 262, 25);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== YIELD) {
                // Code for RegexpStringLiteral specified at Python.javacc:264:5
                consumeToken(YIELD);
                // Code for ZeroOrOne specified at Python.javacc:264:13
                if (first_set$Python_javacc$264$14.contains(nextTokenType())) {
                    // Code for NonTerminal specified at Python.javacc:264:14
                    pushOntoCallStack("YieldExpression", "Python.javacc", 264, 14);
                    try {
                        StarExpressions();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            else  {
                pushOntoCallStack("YieldExpression", "Python.javacc", 262, 5);
                throw new ParseException(this, YieldExpression_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException1717= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1718);
            if (YieldExpression49!=null) {
                if (parseException1717== null) {
                    closeNodeScope(YieldExpression49, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:267:1
    final public void YieldStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "YieldStatement";
        YieldStatement YieldStatement50= null;
        if (buildTree) {
            YieldStatement50= new YieldStatement();
            openNodeScope(YieldStatement50);
        }
        ParseException parseException1747= null;
        int callStackSize1748= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:267:19
            pushOntoCallStack("YieldStatement", "Python.javacc", 267, 19);
            try {
                YieldExpression();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException1747= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1748);
            if (YieldStatement50!=null) {
                if (parseException1747== null) {
                    closeNodeScope(YieldStatement50, true);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> AnnotatedRhs_FIRST_SET= AnnotatedRhs_FIRST_SET_init();
    static private EnumSet<TokenType> AnnotatedRhs_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:269:1
    final public void AnnotatedRhs() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "AnnotatedRhs";
        // Code for ExpansionChoice specified at Python.javacc:269:16
        AnnotatedRhs AnnotatedRhs51= null;
        if (buildTree) {
            AnnotatedRhs51= new AnnotatedRhs();
            openNodeScope(AnnotatedRhs51);
        }
        ParseException parseException1753= null;
        int callStackSize1754= parsingStack.size();
        try {
            if (nextTokenType()== YIELD) {
                // Code for NonTerminal specified at Python.javacc:269:16
                pushOntoCallStack("AnnotatedRhs", "Python.javacc", 269, 16);
                try {
                    YieldExpression();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$269$34.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:269:34
                pushOntoCallStack("AnnotatedRhs", "Python.javacc", 269, 34);
                try {
                    StarExpressions();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("AnnotatedRhs", "Python.javacc", 269, 16);
                throw new ParseException(this, AnnotatedRhs_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException1753= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1754);
            if (AnnotatedRhs51!=null) {
                if (parseException1753== null) {
                    closeNodeScope(AnnotatedRhs51, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:271:1
    final public void Decorators() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Decorators";
        Decorators Decorators52= null;
        if (buildTree) {
            Decorators52= new Decorators();
            openNodeScope(Decorators52);
        }
        ParseException parseException1768= null;
        int callStackSize1769= parsingStack.size();
        try {
            // Code for OneOrMore specified at Python.javacc:271:14
            while (true) {
                // Code for RegexpStringLiteral specified at Python.javacc:271:15
                consumeToken(AT);
                // Code for NonTerminal specified at Python.javacc:271:19
                pushOntoCallStack("Decorators", "Python.javacc", 271, 19);
                try {
                    NamedExpression();
                }
                finally {
                    popCallStack();
                }
                // Code for RegexpRef specified at Python.javacc:271:35
                consumeToken(NEWLINE);
                if (!(nextTokenType()== AT)) break;
            }
        }
        catch(ParseException e) {
            parseException1768= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1769);
            if (Decorators52!=null) {
                if (parseException1768== null) {
                    closeNodeScope(Decorators52, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:273:1
    final public void Annotation() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Annotation";
        Annotation Annotation53= null;
        if (buildTree) {
            Annotation53= new Annotation();
            openNodeScope(Annotation53);
        }
        ParseException parseException1786= null;
        int callStackSize1787= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:273:14
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:273:18
            pushOntoCallStack("Annotation", "Python.javacc", 273, 18);
            try {
                Expression();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException1786= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1787);
            if (Annotation53!=null) {
                if (parseException1786== null) {
                    closeNodeScope(Annotation53, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:275:1
    final public void InvocationArguments() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "InvocationArguments";
        InvocationArguments InvocationArguments54= null;
        if (buildTree) {
            InvocationArguments54= new InvocationArguments();
            openNodeScope(InvocationArguments54);
        }
        ParseException parseException1795= null;
        int callStackSize1796= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:276:4
            consumeToken(LPAREN);
            // Code for ZeroOrOne specified at Python.javacc:277:4
            if (first_set$Python_javacc$278$7.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:278:7
                pushOntoCallStack("InvocationArguments", "Python.javacc", 278, 7);
                try {
                    Argument(false, false);
                }
                finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at Python.javacc:279:7
                // Variables to keep track of what we have seen,
                // and thus, what is permissible. These are 
                // defined locally so only apply when parsing, not
                // scanning ahead, so the lookahead is looser
                // than the parsing.
                boolean seenEquals= peekNode().firstChildOfType(TokenType.ASSIGN)!=null;
                boolean seenDoubleStar= peekNode().firstChildOfType(TokenType.STAR_STAR)!=null;
                // Code for ZeroOrMore specified at Python.javacc:288:7
                while (true) {
                    if (!(scan$Python_javacc$289$10())) break;
                    // Code for RegexpStringLiteral specified at Python.javacc:290:10
                    consumeToken(COMMA);
                    // Code for NonTerminal specified at Python.javacc:291:10
                    pushOntoCallStack("InvocationArguments", "Python.javacc", 291, 10);
                    try {
                        Argument(seenEquals, seenDoubleStar);
                    }
                    finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at Python.javacc:292:10
                    seenEquals|=peekNode().firstChildOfType(TokenType.ASSIGN)!=null;
                    seenDoubleStar|=peekNode().firstChildOfType(TokenType.STAR_STAR)!=null;
                }
                // Code for ZeroOrOne specified at Python.javacc:297:7
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:297:8
                    consumeToken(COMMA);
                }
            }
            // Code for RegexpStringLiteral specified at Python.javacc:299:4
            consumeToken(RPAREN);
        }
        catch(ParseException e) {
            parseException1795= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1796);
            if (InvocationArguments54!=null) {
                if (parseException1795== null) {
                    closeNodeScope(InvocationArguments54, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> Argument_FIRST_SET= Argument_FIRST_SET_init();
    static private EnumSet<TokenType> Argument_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, STAR_STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:302:1
    final public void Argument(boolean seenEquals, boolean seenDoubleStar) {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Argument";
        // Code for ExpansionChoice specified at Python.javacc:303:4
        Argument Argument55= null;
        if (buildTree) {
            Argument55= new Argument();
            openNodeScope(Argument55);
        }
        ParseException parseException1840= null;
        int callStackSize1841= parsingStack.size();
        try {
            if (scan$Python_javacc$303$4()) {
                // Code for RegexpRef specified at Python.javacc:303:4
                consumeToken(NAME);
                if ((!seenEquals)&&scan$Python_javacc$305$7()) {
                    // Code for RegexpStringLiteral specified at Python.javacc:306:7
                    consumeToken(COLONEQUALS);
                }
                else if (nextTokenType()== ASSIGN) {
                    // Code for RegexpStringLiteral specified at Python.javacc:308:7
                    consumeToken(ASSIGN);
                }
                else  {
                    pushOntoCallStack("Argument", "Python.javacc", 305, 7);
                    throw new ParseException(this, first_set$Python_javacc$305$7, parsingStack);
                }
                // Code for NonTerminal specified at Python.javacc:311:4
                pushOntoCallStack("Argument", "Python.javacc", 311, 4);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$313$4.contains(nextTokenType())) {
                // Code for ZeroOrOne specified at Python.javacc:313:4
                // Code for ExpansionChoice specified at Python.javacc:314:7
                if ((!seenDoubleStar)&&scan$Python_javacc$314$7()) {
                    // Code for RegexpStringLiteral specified at Python.javacc:314:35
                    consumeToken(STAR);
                }
                else if (nextTokenType()== STAR_STAR) {
                    // Code for RegexpStringLiteral specified at Python.javacc:316:7
                    consumeToken(STAR_STAR);
                }
                // Code for NonTerminal specified at Python.javacc:318:4
                pushOntoCallStack("Argument", "Python.javacc", 318, 4);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("Argument", "Python.javacc", 303, 4);
                throw new ParseException(this, Argument_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException1840= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1841);
            if (Argument55!=null) {
                if (parseException1840== null) {
                    closeNodeScope(Argument55, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:321:1
    final public void KeyValuePair() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "KeyValuePair";
        KeyValuePair KeyValuePair56= null;
        if (buildTree) {
            KeyValuePair56= new KeyValuePair();
            openNodeScope(KeyValuePair56);
        }
        ParseException parseException1892= null;
        int callStackSize1893= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:321:16
            pushOntoCallStack("KeyValuePair", "Python.javacc", 321, 16);
            try {
                Expression();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:321:27
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:321:31
            pushOntoCallStack("KeyValuePair", "Python.javacc", 321, 31);
            try {
                Expression();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException1892= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1893);
            if (KeyValuePair56!=null) {
                if (parseException1892== null) {
                    closeNodeScope(KeyValuePair56, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> DoubleStarredKeyValuePair_FIRST_SET= DoubleStarredKeyValuePair_FIRST_SET_init();
    static private EnumSet<TokenType> DoubleStarredKeyValuePair_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR_STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:323:1
    final public void DoubleStarredKeyValuePair() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "DoubleStarredKeyValuePair";
        // Code for ExpansionChoice specified at Python.javacc:324:5
        DoubleStarredKeyValuePair DoubleStarredKeyValuePair57= null;
        if (buildTree) {
            DoubleStarredKeyValuePair57= new DoubleStarredKeyValuePair();
            openNodeScope(DoubleStarredKeyValuePair57);
        }
        ParseException parseException1904= null;
        int callStackSize1905= parsingStack.size();
        try {
            if (nextTokenType()== STAR_STAR) {
                // Code for RegexpStringLiteral specified at Python.javacc:324:5
                consumeToken(STAR_STAR);
                // Code for NonTerminal specified at Python.javacc:324:10
                pushOntoCallStack("DoubleStarredKeyValuePair", "Python.javacc", 324, 10);
                try {
                    BitwiseOr();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$326$5.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:326:5
                pushOntoCallStack("DoubleStarredKeyValuePair", "Python.javacc", 326, 5);
                try {
                    KeyValuePair();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("DoubleStarredKeyValuePair", "Python.javacc", 324, 5);
                throw new ParseException(this, DoubleStarredKeyValuePair_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException1904= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1905);
            if (DoubleStarredKeyValuePair57!=null) {
                if (parseException1904== null) {
                    closeNodeScope(DoubleStarredKeyValuePair57, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:329:1
    final public void DoubleStarredKeyValuePairs() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "DoubleStarredKeyValuePairs";
        DoubleStarredKeyValuePairs DoubleStarredKeyValuePairs58= null;
        if (buildTree) {
            DoubleStarredKeyValuePairs58= new DoubleStarredKeyValuePairs();
            openNodeScope(DoubleStarredKeyValuePairs58);
        }
        ParseException parseException1922= null;
        int callStackSize1923= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:329:30
            pushOntoCallStack("DoubleStarredKeyValuePairs", "Python.javacc", 329, 30);
            try {
                DoubleStarredKeyValuePair();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:329:56
            while (true) {
                if (!(scan$Python_javacc$329$57())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:329:57
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:329:67
                pushOntoCallStack("DoubleStarredKeyValuePairs", "Python.javacc", 329, 67);
                try {
                    DoubleStarredKeyValuePair();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:329:95
            if (nextTokenType()== COMMA) {
                // Code for RegexpStringLiteral specified at Python.javacc:329:96
                consumeToken(COMMA);
            }
        }
        catch(ParseException e) {
            parseException1922= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1923);
            if (DoubleStarredKeyValuePairs58!=null) {
                if (parseException1922== null) {
                    closeNodeScope(DoubleStarredKeyValuePairs58, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:331:1
    final public void Dict() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Dict";
        Dict Dict59= null;
        if (buildTree) {
            Dict59= new Dict();
            openNodeScope(Dict59);
        }
        ParseException parseException1949= null;
        int callStackSize1950= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:334:5
            consumeToken(LBRACE);
            // Code for ZeroOrOne specified at Python.javacc:335:5
            if (first_set$Python_javacc$335$6.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:335:6
                pushOntoCallStack("Dict", "Python.javacc", 335, 6);
                try {
                    DoubleStarredKeyValuePairs();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for RegexpStringLiteral specified at Python.javacc:336:5
            consumeToken(RBRACE);
        }
        catch(ParseException e) {
            parseException1949= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1950);
            if (Dict59!=null) {
                if (parseException1949== null) {
                    closeNodeScope(Dict59, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:340:1
    final public void DictComp() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "DictComp";
        DictComp DictComp60= null;
        if (buildTree) {
            DictComp60= new DictComp();
            openNodeScope(DictComp60);
        }
        ParseException parseException1971= null;
        int callStackSize1972= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:340:12
            consumeToken(LBRACE);
            // Code for NonTerminal specified at Python.javacc:340:16
            pushOntoCallStack("DictComp", "Python.javacc", 340, 16);
            try {
                KeyValuePair();
            }
            finally {
                popCallStack();
            }
            // Code for OneOrMore specified at Python.javacc:340:35
            while (true) {
                // Code for NonTerminal specified at Python.javacc:340:36
                pushOntoCallStack("DictComp", "Python.javacc", 340, 36);
                try {
                    ForIfClause();
                }
                finally {
                    popCallStack();
                }
                if (!(nextTokenType()== ASYNC||nextTokenType== FOR)) break;
            }
            // Code for RegexpStringLiteral specified at Python.javacc:340:50
            consumeToken(RBRACE);
        }
        catch(ParseException e) {
            parseException1971= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1972);
            if (DictComp60!=null) {
                if (parseException1971== null) {
                    closeNodeScope(DictComp60, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:342:1
    final public void Set() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Set";
        Set Set61= null;
        if (buildTree) {
            Set61= new Set();
            openNodeScope(Set61);
        }
        ParseException parseException1992= null;
        int callStackSize1993= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:342:7
            consumeToken(LBRACE);
            // Code for NonTerminal specified at Python.javacc:342:11
            pushOntoCallStack("Set", "Python.javacc", 342, 11);
            try {
                StarNamedExpressions();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:342:32
            consumeToken(RBRACE);
        }
        catch(ParseException e) {
            parseException1992= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize1993);
            if (Set61!=null) {
                if (parseException1992== null) {
                    closeNodeScope(Set61, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:344:1
    final public void SetComp() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "SetComp";
        SetComp SetComp62= null;
        if (buildTree) {
            SetComp62= new SetComp();
            openNodeScope(SetComp62);
        }
        ParseException parseException2004= null;
        int callStackSize2005= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:344:11
            consumeToken(LBRACE);
            // Code for NonTerminal specified at Python.javacc:344:15
            pushOntoCallStack("SetComp", "Python.javacc", 344, 15);
            try {
                NamedExpression();
            }
            finally {
                popCallStack();
            }
            // Code for OneOrMore specified at Python.javacc:344:37
            while (true) {
                // Code for NonTerminal specified at Python.javacc:344:38
                pushOntoCallStack("SetComp", "Python.javacc", 344, 38);
                try {
                    ForIfClause();
                }
                finally {
                    popCallStack();
                }
                if (!(nextTokenType()== ASYNC||nextTokenType== FOR)) break;
            }
            // Code for RegexpStringLiteral specified at Python.javacc:344:52
            consumeToken(RBRACE);
        }
        catch(ParseException e) {
            parseException2004= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2005);
            if (SetComp62!=null) {
                if (parseException2004== null) {
                    closeNodeScope(SetComp62, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:346:1
    final public void ClassDefinition() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ClassDefinition";
        ClassDefinition ClassDefinition63= null;
        if (buildTree) {
            ClassDefinition63= new ClassDefinition();
            openNodeScope(ClassDefinition63);
        }
        ParseException parseException2025= null;
        int callStackSize2026= parsingStack.size();
        try {
            // Code for ZeroOrOne specified at Python.javacc:347:5
            if (nextTokenType()== AT) {
                // Code for NonTerminal specified at Python.javacc:347:6
                pushOntoCallStack("ClassDefinition", "Python.javacc", 347, 6);
                try {
                    Decorators();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for RegexpStringLiteral specified at Python.javacc:347:18
            consumeToken(CLASS);
            // Code for RegexpRef specified at Python.javacc:348:5
            consumeToken(NAME);
            // Code for ZeroOrOne specified at Python.javacc:348:12
            if (nextTokenType()== LPAREN) {
                // Code for NonTerminal specified at Python.javacc:348:13
                pushOntoCallStack("ClassDefinition", "Python.javacc", 348, 13);
                try {
                    InvocationArguments();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for RegexpStringLiteral specified at Python.javacc:349:5
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:350:5
            pushOntoCallStack("ClassDefinition", "Python.javacc", 350, 5);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException2025= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2026);
            if (ClassDefinition63!=null) {
                if (parseException2025== null) {
                    closeNodeScope(ClassDefinition63, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:353:1
    final public void FunctionDefinition() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "FunctionDefinition";
        FunctionDefinition FunctionDefinition64= null;
        if (buildTree) {
            FunctionDefinition64= new FunctionDefinition();
            openNodeScope(FunctionDefinition64);
        }
        ParseException parseException2058= null;
        int callStackSize2059= parsingStack.size();
        try {
            // Code for ZeroOrOne specified at Python.javacc:354:5
            if (nextTokenType()== AT) {
                // Code for NonTerminal specified at Python.javacc:354:6
                pushOntoCallStack("FunctionDefinition", "Python.javacc", 354, 6);
                try {
                    Decorators();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:355:5
            if (nextTokenType()== ASYNC) {
                // Code for RegexpStringLiteral specified at Python.javacc:355:6
                consumeToken(ASYNC);
            }
            // Code for RegexpStringLiteral specified at Python.javacc:356:5
            consumeToken(DEF);
            // Code for RegexpRef specified at Python.javacc:357:5
            consumeToken(NAME);
            // Code for RegexpStringLiteral specified at Python.javacc:358:5
            consumeToken(LPAREN);
            // Code for NonTerminal specified at Python.javacc:359:5
            pushOntoCallStack("FunctionDefinition", "Python.javacc", 359, 5);
            try {
                Parameters();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:360:5
            consumeToken(RPAREN);
            // Code for ZeroOrOne specified at Python.javacc:361:5
            if (nextTokenType()== RARROW) {
                // Code for RegexpStringLiteral specified at Python.javacc:361:6
                consumeToken(RARROW);
                // Code for NonTerminal specified at Python.javacc:361:11
                pushOntoCallStack("FunctionDefinition", "Python.javacc", 361, 11);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for RegexpStringLiteral specified at Python.javacc:362:5
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:362:9
            pushOntoCallStack("FunctionDefinition", "Python.javacc", 362, 9);
            try {
                Block();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException2058= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2059);
            if (FunctionDefinition64!=null) {
                if (parseException2058== null) {
                    closeNodeScope(FunctionDefinition64, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:365:1
    final public void LambdaDefinition() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "LambdaDefinition";
        LambdaDefinition LambdaDefinition65= null;
        if (buildTree) {
            LambdaDefinition65= new LambdaDefinition();
            openNodeScope(LambdaDefinition65);
        }
        ParseException parseException2112= null;
        int callStackSize2113= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:365:20
            consumeToken(LAMBDA);
            // Code for NonTerminal specified at Python.javacc:365:29
            pushOntoCallStack("LambdaDefinition", "Python.javacc", 365, 29);
            try {
                Parameters();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:365:40
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:365:44
            pushOntoCallStack("LambdaDefinition", "Python.javacc", 365, 44);
            try {
                Expression();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException2112= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2113);
            if (LambdaDefinition65!=null) {
                if (parseException2112== null) {
                    closeNodeScope(LambdaDefinition65, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> Expression_FIRST_SET= Expression_FIRST_SET_init();
    static private EnumSet<TokenType> Expression_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:371:1
    final public void Expression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Expression";
        // Code for ExpansionChoice specified at Python.javacc:371:14
        Expression Expression66= null;
        if (buildTree) {
            Expression66= new Expression();
            openNodeScope(Expression66);
        }
        ParseException parseException2127= null;
        int callStackSize2128= parsingStack.size();
        try {
            if (first_set$Python_javacc$371$14.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:371:14
                pushOntoCallStack("Expression", "Python.javacc", 371, 14);
                try {
                    Disjunction();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrOne specified at Python.javacc:371:26
                if (nextTokenType()== IF) {
                    // Code for RegexpStringLiteral specified at Python.javacc:371:27
                    consumeToken(IF);
                    // Code for NonTerminal specified at Python.javacc:371:32
                    pushOntoCallStack("Expression", "Python.javacc", 371, 32);
                    try {
                        Disjunction();
                    }
                    finally {
                        popCallStack();
                    }
                    // Code for RegexpStringLiteral specified at Python.javacc:371:44
                    consumeToken(ELSE);
                    // Code for NonTerminal specified at Python.javacc:371:51
                    pushOntoCallStack("Expression", "Python.javacc", 371, 51);
                    try {
                        Expression();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            else if (nextTokenType()== LAMBDA) {
                // Code for NonTerminal specified at Python.javacc:371:65
                pushOntoCallStack("Expression", "Python.javacc", 371, 65);
                try {
                    LambdaDefinition();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("Expression", "Python.javacc", 371, 14);
                throw new ParseException(this, Expression_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException2127= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2128);
            if (Expression66!=null) {
                if (parseException2127== null) {
                    closeNodeScope(Expression66, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:373:1
    final public void Disjunction() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Disjunction";
        Disjunction Disjunction67= null;
        if (buildTree) {
            Disjunction67= new Disjunction();
            openNodeScope(Disjunction67);
        }
        ParseException parseException2160= null;
        int callStackSize2161= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:373:15
            pushOntoCallStack("Disjunction", "Python.javacc", 373, 15);
            try {
                Conjunction();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:373:27
            while (true) {
                if (!(nextTokenType()== OR)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:373:28
                consumeToken(OR);
                // Code for NonTerminal specified at Python.javacc:373:33
                pushOntoCallStack("Disjunction", "Python.javacc", 373, 33);
                try {
                    Conjunction();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException2160= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2161);
            if (Disjunction67!=null) {
                if (parseException2160== null) {
                    closeNodeScope(Disjunction67, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:375:1
    final public void Conjunction() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Conjunction";
        Conjunction Conjunction68= null;
        if (buildTree) {
            Conjunction68= new Conjunction();
            openNodeScope(Conjunction68);
        }
        ParseException parseException2178= null;
        int callStackSize2179= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:375:15
            pushOntoCallStack("Conjunction", "Python.javacc", 375, 15);
            try {
                Inversion();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:375:25
            while (true) {
                if (!(nextTokenType()== AND)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:375:26
                consumeToken(AND);
                // Code for NonTerminal specified at Python.javacc:375:32
                pushOntoCallStack("Conjunction", "Python.javacc", 375, 32);
                try {
                    Inversion();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException2178= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2179);
            if (Conjunction68!=null) {
                if (parseException2178== null) {
                    closeNodeScope(Conjunction68, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:377:1
    final public void Inversion() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Inversion";
        Inversion Inversion69= null;
        if (buildTree) {
            Inversion69= new Inversion();
            openNodeScope(Inversion69);
        }
        ParseException parseException2196= null;
        int callStackSize2197= parsingStack.size();
        try {
            // Code for ZeroOrMore specified at Python.javacc:377:13
            while (true) {
                if (!(nextTokenType()== NOT)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:377:14
                consumeToken(NOT);
            }
            // Code for NonTerminal specified at Python.javacc:377:22
            pushOntoCallStack("Inversion", "Python.javacc", 377, 22);
            try {
                Comparison();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException2196= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2197);
            if (Inversion69!=null) {
                if (parseException2196== null) {
                    closeNodeScope(Inversion69, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:379:1
    final public void Comparison() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Comparison";
        Comparison Comparison70= null;
        if (buildTree) {
            Comparison70= new Comparison();
            openNodeScope(Comparison70);
        }
        ParseException parseException2211= null;
        int callStackSize2212= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:379:14
            pushOntoCallStack("Comparison", "Python.javacc", 379, 14);
            try {
                BitwiseOr();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:379:24
            while (true) {
                if (!(first_set$Python_javacc$379$25.contains(nextTokenType()))) break;
                // Code for NonTerminal specified at Python.javacc:379:25
                pushOntoCallStack("Comparison", "Python.javacc", 379, 25);
                try {
                    ComparisonOperator();
                }
                finally {
                    popCallStack();
                }
                // Code for NonTerminal specified at Python.javacc:379:44
                pushOntoCallStack("Comparison", "Python.javacc", 379, 44);
                try {
                    BitwiseOr();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException2211= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2212);
            if (Comparison70!=null) {
                if (parseException2211== null) {
                    closeNodeScope(Comparison70, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> ComparisonOperator_FIRST_SET= ComparisonOperator_FIRST_SET_init();
    static private EnumSet<TokenType> ComparisonOperator_FIRST_SET_init() {
        return tokenTypeSet(EQ, LE, GE, NE, GT, LT, IN, IS, NOT);
    }

    // Python.javacc:381:1
    final public void ComparisonOperator() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ComparisonOperator";
        // Code for ExpansionChoice specified at Python.javacc:382:4
        if (nextTokenType()== LT) {
            // Code for RegexpStringLiteral specified at Python.javacc:382:4
            consumeToken(LT);
        }
        else if (nextTokenType()== GT) {
            // Code for RegexpStringLiteral specified at Python.javacc:382:10
            consumeToken(GT);
        }
        else if (nextTokenType()== EQ) {
            // Code for RegexpStringLiteral specified at Python.javacc:382:16
            consumeToken(EQ);
        }
        else if (nextTokenType()== GE) {
            // Code for RegexpStringLiteral specified at Python.javacc:382:23
            consumeToken(GE);
        }
        else if (nextTokenType()== LE) {
            // Code for RegexpStringLiteral specified at Python.javacc:382:30
            consumeToken(LE);
        }
        else if (nextTokenType()== NE) {
            // Code for RegexpStringLiteral specified at Python.javacc:382:37
            consumeToken(NE);
        }
        else if (nextTokenType()== IN||nextTokenType== NOT) {
            // Code for ZeroOrOne specified at Python.javacc:384:4
            if (nextTokenType()== NOT) {
                // Code for RegexpStringLiteral specified at Python.javacc:384:5
                consumeToken(NOT);
            }
            // Code for RegexpStringLiteral specified at Python.javacc:384:12
            consumeToken(IN);
        }
        else if (nextTokenType()== IS) {
            // Code for RegexpStringLiteral specified at Python.javacc:386:4
            consumeToken(IS);
            // Code for ZeroOrOne specified at Python.javacc:386:9
            if (nextTokenType()== NOT) {
                // Code for RegexpStringLiteral specified at Python.javacc:386:10
                consumeToken(NOT);
            }
        }
        else  {
            pushOntoCallStack("ComparisonOperator", "Python.javacc", 382, 4);
            throw new ParseException(this, ComparisonOperator_FIRST_SET, parsingStack);
        }
    }

    // Python.javacc:389:1
    final public void StarTarget() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "StarTarget";
        StarTarget StarTarget71= null;
        if (buildTree) {
            StarTarget71= new StarTarget();
            openNodeScope(StarTarget71);
        }
        ParseException parseException2298= null;
        int callStackSize2299= parsingStack.size();
        try {
            // Code for ZeroOrOne specified at Python.javacc:389:14
            if (nextTokenType()== STAR) {
                // Code for RegexpStringLiteral specified at Python.javacc:389:15
                consumeToken(STAR);
            }
            // Code for NonTerminal specified at Python.javacc:389:20
            pushOntoCallStack("StarTarget", "Python.javacc", 389, 20);
            try {
                PrimaryExpression();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException2298= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2299);
            if (StarTarget71!=null) {
                if (parseException2298== null) {
                    closeNodeScope(StarTarget71, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:391:1
    final public void StarTargets() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "StarTargets";
        StarTargets StarTargets72= null;
        if (buildTree) {
            StarTargets72= new StarTargets();
            openNodeScope(StarTargets72);
        }
        ParseException parseException2313= null;
        int callStackSize2314= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:391:15
            pushOntoCallStack("StarTargets", "Python.javacc", 391, 15);
            try {
                StarTarget();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:391:26
            while (true) {
                if (!(scan$Python_javacc$391$27())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:391:27
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:391:37
                pushOntoCallStack("StarTargets", "Python.javacc", 391, 37);
                try {
                    StarTarget();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:391:50
            if (nextTokenType()== COMMA) {
                // Code for RegexpStringLiteral specified at Python.javacc:391:51
                consumeToken(COMMA);
            }
        }
        catch(ParseException e) {
            parseException2313= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2314);
            if (StarTargets72!=null) {
                if (parseException2313== null) {
                    closeNodeScope(StarTargets72, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:393:1
    final public void ForIfClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ForIfClause";
        ForIfClause ForIfClause73= null;
        if (buildTree) {
            ForIfClause73= new ForIfClause();
            openNodeScope(ForIfClause73);
        }
        ParseException parseException2340= null;
        int callStackSize2341= parsingStack.size();
        try {
            // Code for ZeroOrOne specified at Python.javacc:393:15
            if (nextTokenType()== ASYNC) {
                // Code for RegexpStringLiteral specified at Python.javacc:393:16
                consumeToken(ASYNC);
            }
            // Code for RegexpStringLiteral specified at Python.javacc:393:25
            consumeToken(FOR);
            // Code for NonTerminal specified at Python.javacc:393:31
            pushOntoCallStack("ForIfClause", "Python.javacc", 393, 31);
            try {
                StarTargets();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:393:43
            consumeToken(IN);
            // Code for NonTerminal specified at Python.javacc:393:48
            pushOntoCallStack("ForIfClause", "Python.javacc", 393, 48);
            try {
                Disjunction();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:393:60
            while (true) {
                if (!(nextTokenType()== IF)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:393:61
                consumeToken(IF);
                // Code for NonTerminal specified at Python.javacc:393:66
                pushOntoCallStack("ForIfClause", "Python.javacc", 393, 66);
                try {
                    Disjunction();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException2340= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2341);
            if (ForIfClause73!=null) {
                if (parseException2340== null) {
                    closeNodeScope(ForIfClause73, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:395:1
    final public void GenExp() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "GenExp";
        GenExp GenExp74= null;
        if (buildTree) {
            GenExp74= new GenExp();
            openNodeScope(GenExp74);
        }
        ParseException parseException2376= null;
        int callStackSize2377= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:395:10
            consumeToken(LPAREN);
            // Code for NonTerminal specified at Python.javacc:395:14
            pushOntoCallStack("GenExp", "Python.javacc", 395, 14);
            try {
                NamedExpression();
            }
            finally {
                popCallStack();
            }
            // Code for OneOrMore specified at Python.javacc:395:36
            while (true) {
                // Code for NonTerminal specified at Python.javacc:395:37
                pushOntoCallStack("GenExp", "Python.javacc", 395, 37);
                try {
                    ForIfClause();
                }
                finally {
                    popCallStack();
                }
                if (!(nextTokenType()== ASYNC||nextTokenType== FOR)) break;
            }
            // Code for RegexpStringLiteral specified at Python.javacc:395:51
            consumeToken(RPAREN);
        }
        catch(ParseException e) {
            parseException2376= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2377);
            if (GenExp74!=null) {
                if (parseException2376== null) {
                    closeNodeScope(GenExp74, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:397:1
    final public void List() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "List";
        List List75= null;
        if (buildTree) {
            List75= new List();
            openNodeScope(List75);
        }
        ParseException parseException2397= null;
        int callStackSize2398= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:397:8
            consumeToken(LBRACKET);
            // Code for ZeroOrOne specified at Python.javacc:397:12
            if (first_set$Python_javacc$397$13.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:397:13
                pushOntoCallStack("List", "Python.javacc", 397, 13);
                try {
                    StarNamedExpressions();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for RegexpStringLiteral specified at Python.javacc:397:35
            consumeToken(RBRACKET);
        }
        catch(ParseException e) {
            parseException2397= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2398);
            if (List75!=null) {
                if (parseException2397== null) {
                    closeNodeScope(List75, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:399:1
    final public void ListComp() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ListComp";
        ListComp ListComp76= null;
        if (buildTree) {
            ListComp76= new ListComp();
            openNodeScope(ListComp76);
        }
        ParseException parseException2415= null;
        int callStackSize2416= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:399:12
            consumeToken(LBRACKET);
            // Code for NonTerminal specified at Python.javacc:399:16
            pushOntoCallStack("ListComp", "Python.javacc", 399, 16);
            try {
                NamedExpression();
            }
            finally {
                popCallStack();
            }
            // Code for OneOrMore specified at Python.javacc:399:38
            while (true) {
                // Code for NonTerminal specified at Python.javacc:399:39
                pushOntoCallStack("ListComp", "Python.javacc", 399, 39);
                try {
                    ForIfClause();
                }
                finally {
                    popCallStack();
                }
                if (!(nextTokenType()== ASYNC||nextTokenType== FOR)) break;
            }
            // Code for RegexpStringLiteral specified at Python.javacc:399:53
            consumeToken(RBRACKET);
        }
        catch(ParseException e) {
            parseException2415= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2416);
            if (ListComp76!=null) {
                if (parseException2415== null) {
                    closeNodeScope(ListComp76, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> StarEtc_FIRST_SET= tokenTypeSet(STAR, STAR_STAR);
    // Python.javacc:401:1
    final public void StarEtc() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "StarEtc";
        // Code for ExpansionChoice specified at Python.javacc:402:4
        StarEtc StarEtc77= null;
        if (buildTree) {
            StarEtc77= new StarEtc();
            openNodeScope(StarEtc77);
        }
        ParseException parseException2436= null;
        int callStackSize2437= parsingStack.size();
        try {
            if (nextTokenType()== STAR_STAR) {
                // Code for NonTerminal specified at Python.javacc:402:4
                pushOntoCallStack("StarEtc", "Python.javacc", 402, 4);
                try {
                    KeyWords();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$Python_javacc$404$4()) {
                // Code for RegexpStringLiteral specified at Python.javacc:404:4
                consumeToken(STAR);
                // Code for RegexpStringLiteral specified at Python.javacc:404:8
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:404:17
                pushOntoCallStack("StarEtc", "Python.javacc", 404, 17);
                try {
                    ParamMaybeDefault();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrMore specified at Python.javacc:404:35
                while (true) {
                    if (!(scan$Python_javacc$404$36())) break;
                    // Code for RegexpStringLiteral specified at Python.javacc:404:36
                    consumeToken(COMMA);
                    // Code for NonTerminal specified at Python.javacc:404:46
                    pushOntoCallStack("StarEtc", "Python.javacc", 404, 46);
                    try {
                        ParamMaybeDefault();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for ZeroOrOne specified at Python.javacc:404:66
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:404:67
                    consumeToken(COMMA);
                    // Code for ZeroOrOne specified at Python.javacc:404:71
                    if (nextTokenType()== STAR_STAR) {
                        // Code for NonTerminal specified at Python.javacc:404:72
                        pushOntoCallStack("StarEtc", "Python.javacc", 404, 72);
                        try {
                            KeyWords();
                        }
                        finally {
                            popCallStack();
                        }
                    }
                }
            }
            else if (nextTokenType()== STAR) {
                // Code for RegexpStringLiteral specified at Python.javacc:406:4
                consumeToken(STAR);
                // Code for RegexpRef specified at Python.javacc:406:8
                consumeToken(NAME);
                // Code for ZeroOrOne specified at Python.javacc:406:15
                if (scan$Python_javacc$406$16()) {
                    // Code for RegexpStringLiteral specified at Python.javacc:406:48
                    consumeToken(COLON);
                    // Code for NonTerminal specified at Python.javacc:406:52
                    pushOntoCallStack("StarEtc", "Python.javacc", 406, 52);
                    try {
                        Expression();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for ZeroOrMore specified at Python.javacc:406:64
                while (true) {
                    if (!(scan$Python_javacc$406$65())) break;
                    // Code for RegexpStringLiteral specified at Python.javacc:406:65
                    consumeToken(COMMA);
                    // Code for NonTerminal specified at Python.javacc:406:75
                    pushOntoCallStack("StarEtc", "Python.javacc", 406, 75);
                    try {
                        ParamMaybeDefault();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for ZeroOrOne specified at Python.javacc:406:95
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:406:96
                    consumeToken(COMMA);
                    // Code for ZeroOrOne specified at Python.javacc:406:100
                    if (nextTokenType()== STAR_STAR) {
                        // Code for NonTerminal specified at Python.javacc:406:101
                        pushOntoCallStack("StarEtc", "Python.javacc", 406, 101);
                        try {
                            KeyWords();
                        }
                        finally {
                            popCallStack();
                        }
                    }
                }
            }
            else  {
                pushOntoCallStack("StarEtc", "Python.javacc", 402, 4);
                throw new ParseException(this, StarEtc_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException2436= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2437);
            if (StarEtc77!=null) {
                if (parseException2436== null) {
                    closeNodeScope(StarEtc77, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:409:1
    final public void ParamMaybeDefault() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ParamMaybeDefault";
        ParamMaybeDefault ParamMaybeDefault78= null;
        if (buildTree) {
            ParamMaybeDefault78= new ParamMaybeDefault();
            openNodeScope(ParamMaybeDefault78);
        }
        ParseException parseException2538= null;
        int callStackSize2539= parsingStack.size();
        try {
            // Code for RegexpRef specified at Python.javacc:409:21
            consumeToken(NAME);
            // Code for ZeroOrOne specified at Python.javacc:409:28
            if (nextTokenType()== COLON) {
                // Code for RegexpStringLiteral specified at Python.javacc:409:29
                consumeToken(COLON);
                // Code for NonTerminal specified at Python.javacc:409:33
                pushOntoCallStack("ParamMaybeDefault", "Python.javacc", 409, 33);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:409:45
            if (nextTokenType()== ASSIGN) {
                // Code for RegexpStringLiteral specified at Python.javacc:409:46
                consumeToken(ASSIGN);
                // Code for NonTerminal specified at Python.javacc:409:50
                pushOntoCallStack("ParamMaybeDefault", "Python.javacc", 409, 50);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException2538= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2539);
            if (ParamMaybeDefault78!=null) {
                if (parseException2538== null) {
                    closeNodeScope(ParamMaybeDefault78, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:411:1
    final public void KeyWords() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "KeyWords";
        KeyWords KeyWords79= null;
        if (buildTree) {
            KeyWords79= new KeyWords();
            openNodeScope(KeyWords79);
        }
        ParseException parseException2568= null;
        int callStackSize2569= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:412:4
            consumeToken(STAR_STAR);
            // Code for RegexpRef specified at Python.javacc:412:9
            consumeToken(NAME);
            // Code for ZeroOrOne specified at Python.javacc:413:4
            if (scan$Python_javacc$414$8()) {
                // Code for RegexpStringLiteral specified at Python.javacc:415:8
                consumeToken(COLON);
                // Code for NonTerminal specified at Python.javacc:415:12
                pushOntoCallStack("KeyWords", "Python.javacc", 415, 12);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException2568= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2569);
            if (KeyWords79!=null) {
                if (parseException2568== null) {
                    closeNodeScope(KeyWords79, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:419:1
    final public void Parameters() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Parameters";
        Parameters Parameters80= null;
        if (buildTree) {
            Parameters80= new Parameters();
            openNodeScope(Parameters80);
        }
        boolean seenDefault= false, seenSlash= false;
        ParseException parseException2589= null;
        int callStackSize2590= parsingStack.size();
        try {
            // Code for ZeroOrOne specified at Python.javacc:421:5
            if (nextTokenType()== NAME) {
                // Code for RegexpRef specified at Python.javacc:422:7
                consumeToken(NAME);
                // Code for ZeroOrOne specified at Python.javacc:425:7
                if (scan$Python_javacc$425$8()) {
                    // Code for RegexpStringLiteral specified at Python.javacc:425:38
                    consumeToken(COLON);
                    // Code for NonTerminal specified at Python.javacc:425:42
                    pushOntoCallStack("Parameters", "Python.javacc", 425, 42);
                    try {
                        Expression();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for ZeroOrOne specified at Python.javacc:426:7
                if (nextTokenType()== ASSIGN) {
                    // Code for RegexpStringLiteral specified at Python.javacc:426:8
                    consumeToken(ASSIGN);
                    // Code for NonTerminal specified at Python.javacc:426:12
                    pushOntoCallStack("Parameters", "Python.javacc", 426, 12);
                    try {
                        Expression();
                    }
                    finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at Python.javacc:426:23
                    seenDefault= true;
                }
                // Code for ZeroOrMore specified at Python.javacc:427:7
                while (true) {
                    if (!(scan$Python_javacc$427$8())) break;
                    // Code for RegexpStringLiteral specified at Python.javacc:427:8
                    consumeToken(COMMA);
                    if ((!seenSlash)&&scan$Python_javacc$430$11()) {
                        // Code for RegexpStringLiteral specified at Python.javacc:431:11
                        consumeToken(SLASH);
                        // Code for CodeBlock specified at Python.javacc:431:15
                        seenSlash= true;
                    }
                    else if (nextTokenType()== NAME) {
                        // Code for RegexpRef specified at Python.javacc:433:11
                        consumeToken(NAME);
                        // Code for ZeroOrOne specified at Python.javacc:433:18
                        if (scan$Python_javacc$433$19()) {
                            // Code for RegexpStringLiteral specified at Python.javacc:433:49
                            consumeToken(COLON);
                            // Code for NonTerminal specified at Python.javacc:433:53
                            pushOntoCallStack("Parameters", "Python.javacc", 433, 53);
                            try {
                                Expression();
                            }
                            finally {
                                popCallStack();
                            }
                        }
                        // Code for ZeroOrOne specified at Python.javacc:434:11
                        if ((seenDefault||getToken(1).getType()== TokenType.ASSIGN)&&scan$Python_javacc$437$14()) {
                            // Code for RegexpStringLiteral specified at Python.javacc:438:17
                            consumeToken(ASSIGN);
                            // Code for NonTerminal specified at Python.javacc:438:21
                            pushOntoCallStack("Parameters", "Python.javacc", 438, 21);
                            try {
                                Expression();
                            }
                            finally {
                                popCallStack();
                            }
                            // Code for CodeBlock specified at Python.javacc:438:32
                            seenDefault= true;
                        }
                    }
                    else  {
                        pushOntoCallStack("Parameters", "Python.javacc", 430, 11);
                        throw new ParseException(this, first_set$Python_javacc$430$11, parsingStack);
                    }
                }
                // Code for ZeroOrOne specified at Python.javacc:442:7
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:442:9
                    consumeToken(COMMA);
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:444:5
            if (scan$Python_javacc$445$7()) {
                // Code for NonTerminal specified at Python.javacc:445:26
                pushOntoCallStack("Parameters", "Python.javacc", 445, 26);
                try {
                    StarEtc();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:447:5
            if (nextTokenType()== COMMA) {
                // Code for RegexpStringLiteral specified at Python.javacc:447:6
                consumeToken(COMMA);
            }
        }
        catch(ParseException e) {
            parseException2589= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2590);
            if (Parameters80!=null) {
                if (parseException2589== null) {
                    closeNodeScope(Parameters80, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> AugAssign_FIRST_SET= AugAssign_FIRST_SET_init();
    static private EnumSet<TokenType> AugAssign_FIRST_SET_init() {
        return tokenTypeSet(MINUSASSIGN, PLUSASSIGN, STARASSIGN, ATASSIGN, SLASHASSIGN, REMASSIGN, ANDASSIGN, ORASSIGN, XORASSIGN, LSHIFTASSIGN, RSHIFTASSIGN, STARSTARASSIGN, SLASHSLASHASSIGN);
    }

    // Python.javacc:450:1
    final public void AugAssign() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "AugAssign";
        // Code for ExpansionChoice specified at Python.javacc:451:5
        if (nextTokenType()== PLUSASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:451:5
            consumeToken(PLUSASSIGN);
        }
        else if (nextTokenType()== MINUSASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:451:12
            consumeToken(MINUSASSIGN);
        }
        else if (nextTokenType()== STARASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:451:19
            consumeToken(STARASSIGN);
        }
        else if (nextTokenType()== ATASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:451:26
            consumeToken(ATASSIGN);
        }
        else if (nextTokenType()== SLASHASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:451:33
            consumeToken(SLASHASSIGN);
        }
        else if (nextTokenType()== REMASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:451:40
            consumeToken(REMASSIGN);
        }
        else if (nextTokenType()== ANDASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:451:47
            consumeToken(ANDASSIGN);
        }
        else if (nextTokenType()== ORASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:451:54
            consumeToken(ORASSIGN);
        }
        else if (nextTokenType()== XORASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:451:61
            consumeToken(XORASSIGN);
        }
        else if (nextTokenType()== LSHIFTASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:451:68
            consumeToken(LSHIFTASSIGN);
        }
        else if (nextTokenType()== RSHIFTASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:452:7
            consumeToken(RSHIFTASSIGN);
        }
        else if (nextTokenType()== STARSTARASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:452:15
            consumeToken(STARSTARASSIGN);
        }
        else if (nextTokenType()== SLASHSLASHASSIGN) {
            // Code for RegexpStringLiteral specified at Python.javacc:452:23
            consumeToken(SLASHSLASHASSIGN);
        }
        else  {
            pushOntoCallStack("AugAssign", "Python.javacc", 451, 5);
            throw new ParseException(this, AugAssign_FIRST_SET, parsingStack);
        }
    }

    static private final EnumSet<TokenType> SimpleAssignTarget_FIRST_SET= SimpleAssignTarget_FIRST_SET_init();
    static private EnumSet<TokenType> SimpleAssignTarget_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, ELLIPSIS, FALSE, NONE, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:455:1
    final public void SimpleAssignTarget() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "SimpleAssignTarget";
        // Code for ExpansionChoice specified at Python.javacc:456:4
        SimpleAssignTarget SimpleAssignTarget81= null;
        if (buildTree) {
            SimpleAssignTarget81= new SimpleAssignTarget();
            openNodeScope(SimpleAssignTarget81);
        }
        ParseException parseException2791= null;
        int callStackSize2792= parsingStack.size();
        try {
            if (first_set$Python_javacc$456$4.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:456:4
                pushOntoCallStack("SimpleAssignTarget", "Python.javacc", 456, 4);
                try {
                    PrimaryExpression();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== LPAREN) {
                // Code for RegexpStringLiteral specified at Python.javacc:458:4
                consumeToken(LPAREN);
                // Code for NonTerminal specified at Python.javacc:458:8
                pushOntoCallStack("SimpleAssignTarget", "Python.javacc", 458, 8);
                try {
                    SimpleAssignTarget();
                }
                finally {
                    popCallStack();
                }
                // Code for RegexpStringLiteral specified at Python.javacc:458:27
                consumeToken(RPAREN);
            }
            else  {
                pushOntoCallStack("SimpleAssignTarget", "Python.javacc", 456, 4);
                throw new ParseException(this, SimpleAssignTarget_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException2791= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2792);
            if (SimpleAssignTarget81!=null) {
                if (parseException2791== null) {
                    closeNodeScope(SimpleAssignTarget81, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:461:1
    final public void Assignment() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Assignment";
        Assignment Assignment82= null;
        if (buildTree) {
            Assignment82= new Assignment();
            openNodeScope(Assignment82);
        }
        ParseException parseException2812= null;
        int callStackSize2813= parsingStack.size();
        try {
            if (scan$Python_javacc$464$3()) {
                // Code for NonTerminal specified at Python.javacc:464:3
                pushOntoCallStack("Assignment", "Python.javacc", 464, 3);
                try {
                    SimpleAssignTarget();
                }
                finally {
                    popCallStack();
                }
                // Code for RegexpStringLiteral specified at Python.javacc:464:22
                consumeToken(COLON);
                // Code for NonTerminal specified at Python.javacc:464:31
                pushOntoCallStack("Assignment", "Python.javacc", 464, 31);
                try {
                    Expression();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrOne specified at Python.javacc:464:42
                if (nextTokenType()== ASSIGN) {
                    // Code for RegexpStringLiteral specified at Python.javacc:464:43
                    consumeToken(ASSIGN);
                    // Code for NonTerminal specified at Python.javacc:464:47
                    pushOntoCallStack("Assignment", "Python.javacc", 464, 47);
                    try {
                        AnnotatedRhs();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            else if (scan$Python_javacc$466$3()) {
                // Code for NonTerminal specified at Python.javacc:466:3
                pushOntoCallStack("Assignment", "Python.javacc", 466, 3);
                try {
                    SimpleAssignTarget();
                }
                finally {
                    popCallStack();
                }
                // Code for NonTerminal specified at Python.javacc:466:22
                pushOntoCallStack("Assignment", "Python.javacc", 466, 22);
                try {
                    AugAssign();
                }
                finally {
                    popCallStack();
                }
                if (nextTokenType()== YIELD) {
                    // Code for NonTerminal specified at Python.javacc:466:38
                    pushOntoCallStack("Assignment", "Python.javacc", 466, 38);
                    try {
                        YieldExpression();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (first_set$Python_javacc$466$56.contains(nextTokenType())) {
                    // Code for NonTerminal specified at Python.javacc:466:56
                    pushOntoCallStack("Assignment", "Python.javacc", 466, 56);
                    try {
                        StarExpressions();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else  {
                    pushOntoCallStack("Assignment", "Python.javacc", 466, 38);
                    throw new ParseException(this, first_set$Python_javacc$466$38, parsingStack);
                }
            }
            else if (scan$Python_javacc$468$3()) {
                // Code for OneOrMore specified at Python.javacc:468:3
                while (true) {
                    // Code for NonTerminal specified at Python.javacc:468:6
                    pushOntoCallStack("Assignment", "Python.javacc", 468, 6);
                    try {
                        StarTargets();
                    }
                    finally {
                        popCallStack();
                    }
                    // Code for RegexpStringLiteral specified at Python.javacc:468:18
                    consumeToken(ASSIGN);
                    if (!(scan$Python_javacc$468$4())) break;
                }
                if (nextTokenType()== YIELD) {
                    // Code for NonTerminal specified at Python.javacc:468:30
                    pushOntoCallStack("Assignment", "Python.javacc", 468, 30);
                    try {
                        YieldExpression();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else if (first_set$Python_javacc$468$48.contains(nextTokenType())) {
                    // Code for NonTerminal specified at Python.javacc:468:48
                    pushOntoCallStack("Assignment", "Python.javacc", 468, 48);
                    try {
                        StarExpressions();
                    }
                    finally {
                        popCallStack();
                    }
                }
                else  {
                    pushOntoCallStack("Assignment", "Python.javacc", 468, 30);
                    throw new ParseException(this, first_set$Python_javacc$468$30, parsingStack);
                }
            }
            else  {
                pushOntoCallStack("Assignment", "Python.javacc", 464, 3);
                throw new ParseException(this, first_set$Python_javacc$464$3, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException2812= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2813);
            if (Assignment82!=null) {
                if (parseException2812== null) {
                    closeNodeScope(Assignment82, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:475:1
    final public void MatchStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MatchStatement";
        MatchStatement MatchStatement83= null;
        if (buildTree) {
            MatchStatement83= new MatchStatement();
            openNodeScope(MatchStatement83);
        }
        ParseException parseException2899= null;
        int callStackSize2900= parsingStack.size();
        try {
            EnumSet<TokenType> previousActives2902= EnumSet.copyOf(token_source.activeTokenTypes);
            boolean somethingChanged2903= activateTokenTypes(MATCH);
            try {
                // Code for RegexpStringLiteral specified at Python.javacc:476:27
                consumeToken(MATCH);
            }
            finally {
                token_source.activeTokenTypes= previousActives2902;
                if (somethingChanged2903) {
                    token_source.reset(lastConsumedToken);
                    nextTokenType= null;
                }
            }
            // Code for NonTerminal specified at Python.javacc:477:4
            pushOntoCallStack("MatchStatement", "Python.javacc", 477, 4);
            try {
                SubjectExpression();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:478:4
            consumeToken(COLON);
            // Code for RegexpRef specified at Python.javacc:480:4
            consumeToken(NEWLINE);
            // Code for RegexpRef specified at Python.javacc:481:4
            consumeToken(INDENT);
            // Code for OneOrMore specified at Python.javacc:482:25
            EnumSet<TokenType> previousActives2923= EnumSet.copyOf(token_source.activeTokenTypes);
            boolean somethingChanged2924= activateTokenTypes(CASE);
            try {
                while (true) {
                    // Code for NonTerminal specified at Python.javacc:482:26
                    pushOntoCallStack("MatchStatement", "Python.javacc", 482, 26);
                    try {
                        CaseBlock();
                    }
                    finally {
                        popCallStack();
                    }
                    if (!(nextTokenType()== CASE)) break;
                }
            }
            finally {
                token_source.activeTokenTypes= previousActives2923;
                if (somethingChanged2924) {
                    token_source.reset(lastConsumedToken);
                    nextTokenType= null;
                }
            }
            // Code for RegexpRef specified at Python.javacc:483:4
            consumeToken(DEDENT);
        }
        catch(ParseException e) {
            parseException2899= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2900);
            if (MatchStatement83!=null) {
                if (parseException2899== null) {
                    closeNodeScope(MatchStatement83, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:486:1
    final public void CaseBlock() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "CaseBlock";
        CaseBlock CaseBlock84= null;
        if (buildTree) {
            CaseBlock84= new CaseBlock();
            openNodeScope(CaseBlock84);
        }
        ParseException parseException2937= null;
        int callStackSize2938= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:487:5
            consumeToken(CASE);
            EnumSet<TokenType> previousActives2943= EnumSet.copyOf(token_source.activeTokenTypes);
            boolean somethingChanged2944= deactivateTokenTypes(CASE);
            try {
                // Code for NonTerminal specified at Python.javacc:490:7
                pushOntoCallStack("CaseBlock", "Python.javacc", 490, 7);
                try {
                    Patterns();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrOne specified at Python.javacc:491:7
                if (nextTokenType()== IF) {
                    // Code for RegexpStringLiteral specified at Python.javacc:491:8
                    consumeToken(IF);
                    // Code for NonTerminal specified at Python.javacc:491:13
                    pushOntoCallStack("CaseBlock", "Python.javacc", 491, 13);
                    try {
                        NamedExpression();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for RegexpStringLiteral specified at Python.javacc:492:7
                consumeToken(COLON);
                // Code for NonTerminal specified at Python.javacc:493:7
                pushOntoCallStack("CaseBlock", "Python.javacc", 493, 7);
                try {
                    Block();
                }
                finally {
                    popCallStack();
                }
            }
            finally {
                token_source.activeTokenTypes= previousActives2943;
                if (somethingChanged2944) {
                    token_source.reset(lastConsumedToken);
                    nextTokenType= null;
                }
            }
        }
        catch(ParseException e) {
            parseException2937= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2938);
            if (CaseBlock84!=null) {
                if (parseException2937== null) {
                    closeNodeScope(CaseBlock84, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> Patterns_FIRST_SET= Patterns_FIRST_SET_init();
    static private EnumSet<TokenType> Patterns_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:498:1
    final public void Patterns() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Patterns";
        // Code for ExpansionChoice specified at Python.javacc:499:4
        Patterns Patterns85= null;
        if (buildTree) {
            Patterns85= new Patterns();
            openNodeScope(Patterns85);
        }
        ParseException parseException2970= null;
        int callStackSize2971= parsingStack.size();
        try {
            if (scan$Python_javacc$499$4()) {
                // Code for NonTerminal specified at Python.javacc:499:4
                pushOntoCallStack("Patterns", "Python.javacc", 499, 4);
                try {
                    OpenSequencePattern();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$501$4.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:501:4
                pushOntoCallStack("Patterns", "Python.javacc", 501, 4);
                try {
                    Pattern();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("Patterns", "Python.javacc", 499, 4);
                throw new ParseException(this, Patterns_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException2970= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2971);
            if (Patterns85!=null) {
                if (parseException2970== null) {
                    closeNodeScope(Patterns85, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:504:1
    final public void StarPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "StarPattern";
        StarPattern StarPattern86= null;
        if (buildTree) {
            StarPattern86= new StarPattern();
            openNodeScope(StarPattern86);
        }
        ParseException parseException2985= null;
        int callStackSize2986= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:505:4
            consumeToken(STAR);
            // Code for RegexpRef specified at Python.javacc:505:8
            consumeToken(NAME);
        }
        catch(ParseException e) {
            parseException2985= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize2986);
            if (StarPattern86!=null) {
                if (parseException2985== null) {
                    closeNodeScope(StarPattern86, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> MaybeStarPattern_FIRST_SET= MaybeStarPattern_FIRST_SET_init();
    static private EnumSet<TokenType> MaybeStarPattern_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:508:1
    final public void MaybeStarPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MaybeStarPattern";
        // Code for ExpansionChoice specified at Python.javacc:508:25
        if (nextTokenType()== STAR) {
            // Code for NonTerminal specified at Python.javacc:508:25
            pushOntoCallStack("MaybeStarPattern", "Python.javacc", 508, 25);
            try {
                StarPattern();
            }
            finally {
                popCallStack();
            }
        }
        else if (first_set$Python_javacc$508$39.contains(nextTokenType())) {
            // Code for NonTerminal specified at Python.javacc:508:39
            pushOntoCallStack("MaybeStarPattern", "Python.javacc", 508, 39);
            try {
                Pattern();
            }
            finally {
                popCallStack();
            }
        }
        else  {
            pushOntoCallStack("MaybeStarPattern", "Python.javacc", 508, 25);
            throw new ParseException(this, MaybeStarPattern_FIRST_SET, parsingStack);
        }
    }

    static private final EnumSet<TokenType> ClosedPattern_FIRST_SET= ClosedPattern_FIRST_SET_init();
    static private EnumSet<TokenType> ClosedPattern_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:510:1
    final public void ClosedPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ClosedPattern";
        // Code for ExpansionChoice specified at Python.javacc:511:4
        ClosedPattern ClosedPattern87= null;
        if (buildTree) {
            ClosedPattern87= new ClosedPattern();
            openNodeScope(ClosedPattern87);
        }
        ParseException parseException3009= null;
        int callStackSize3010= parsingStack.size();
        try {
            if (scan$Python_javacc$511$4()) {
                // Code for NonTerminal specified at Python.javacc:511:4
                pushOntoCallStack("ClosedPattern", "Python.javacc", 511, 4);
                try {
                    ClassPattern();
                }
                finally {
                    popCallStack();
                }
            }
            else if (first_set$Python_javacc$513$4.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:513:4
                pushOntoCallStack("ClosedPattern", "Python.javacc", 513, 4);
                try {
                    LiteralPattern();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== NAME) {
                // Code for NonTerminal specified at Python.javacc:515:4
                pushOntoCallStack("ClosedPattern", "Python.javacc", 515, 4);
                try {
                    NameOrAttribute();
                }
                finally {
                    popCallStack();
                }
            }
            else if (scan$Python_javacc$517$4()) {
                // Code for NonTerminal specified at Python.javacc:517:6
                pushOntoCallStack("ClosedPattern", "Python.javacc", 517, 6);
                try {
                    GroupPattern();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== LBRACKET||nextTokenType== LPAREN) {
                // Code for NonTerminal specified at Python.javacc:519:4
                pushOntoCallStack("ClosedPattern", "Python.javacc", 519, 4);
                try {
                    SequencePattern();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== LBRACE) {
                // Code for NonTerminal specified at Python.javacc:521:4
                pushOntoCallStack("ClosedPattern", "Python.javacc", 521, 4);
                try {
                    MappingPattern();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("ClosedPattern", "Python.javacc", 511, 4);
                throw new ParseException(this, ClosedPattern_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException3009= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3010);
            if (ClosedPattern87!=null) {
                if (parseException3009== null) {
                    closeNodeScope(ClosedPattern87, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:524:1
    final public void GroupPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "GroupPattern";
        GroupPattern GroupPattern88= null;
        if (buildTree) {
            GroupPattern88= new GroupPattern();
            openNodeScope(GroupPattern88);
        }
        ParseException parseException3048= null;
        int callStackSize3049= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:524:16
            consumeToken(LPAREN);
            // Code for NonTerminal specified at Python.javacc:524:20
            pushOntoCallStack("GroupPattern", "Python.javacc", 524, 20);
            try {
                Pattern();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:524:28
            consumeToken(RPAREN);
        }
        catch(ParseException e) {
            parseException3048= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3049);
            if (GroupPattern88!=null) {
                if (parseException3048== null) {
                    closeNodeScope(GroupPattern88, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:526:1
    final public void KeyValuePattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "KeyValuePattern";
        KeyValuePattern KeyValuePattern89= null;
        if (buildTree) {
            KeyValuePattern89= new KeyValuePattern();
            openNodeScope(KeyValuePattern89);
        }
        ParseException parseException3060= null;
        int callStackSize3061= parsingStack.size();
        try {
            if (first_set$Python_javacc$526$19.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:526:19
                pushOntoCallStack("KeyValuePattern", "Python.javacc", 526, 19);
                try {
                    LiteralPattern();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== NAME) {
                // Code for NonTerminal specified at Python.javacc:526:36
                pushOntoCallStack("KeyValuePattern", "Python.javacc", 526, 36);
                try {
                    Attribute();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("KeyValuePattern", "Python.javacc", 526, 19);
                throw new ParseException(this, first_set$Python_javacc$526$19$, parsingStack);
            }
            // Code for RegexpStringLiteral specified at Python.javacc:526:47
            consumeToken(COLON);
            // Code for NonTerminal specified at Python.javacc:526:51
            pushOntoCallStack("KeyValuePattern", "Python.javacc", 526, 51);
            try {
                Pattern();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException3060= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3061);
            if (KeyValuePattern89!=null) {
                if (parseException3060== null) {
                    closeNodeScope(KeyValuePattern89, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:528:1
    final public void ItemsPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ItemsPattern";
        ItemsPattern ItemsPattern90= null;
        if (buildTree) {
            ItemsPattern90= new ItemsPattern();
            openNodeScope(ItemsPattern90);
        }
        ParseException parseException3085= null;
        int callStackSize3086= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:528:16
            pushOntoCallStack("ItemsPattern", "Python.javacc", 528, 16);
            try {
                KeyValuePattern();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:528:32
            while (true) {
                if (!(scan$Python_javacc$528$33())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:528:33
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:528:43
                pushOntoCallStack("ItemsPattern", "Python.javacc", 528, 43);
                try {
                    KeyValuePattern();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException3085= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3086);
            if (ItemsPattern90!=null) {
                if (parseException3085== null) {
                    closeNodeScope(ItemsPattern90, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:530:1
    final public void MappingPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MappingPattern";
        MappingPattern MappingPattern91= null;
        if (buildTree) {
            MappingPattern91= new MappingPattern();
            openNodeScope(MappingPattern91);
        }
        ParseException parseException3103= null;
        int callStackSize3104= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:531:3
            consumeToken(LBRACE);
            // Code for ZeroOrOne specified at Python.javacc:532:6
            // Code for ExpansionChoice specified at Python.javacc:533:10
            if (first_set$Python_javacc$533$10.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:533:10
                pushOntoCallStack("MappingPattern", "Python.javacc", 533, 10);
                try {
                    ItemsPattern();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrOne specified at Python.javacc:533:23
                if (scan$Python_javacc$533$24()) {
                    // Code for RegexpStringLiteral specified at Python.javacc:533:24
                    consumeToken(COMMA);
                    // Code for NonTerminal specified at Python.javacc:533:34
                    pushOntoCallStack("MappingPattern", "Python.javacc", 533, 34);
                    try {
                        DoubleStarPattern();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for ZeroOrOne specified at Python.javacc:533:53
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:533:54
                    consumeToken(COMMA);
                }
            }
            else if (nextTokenType()== STAR_STAR) {
                // Code for NonTerminal specified at Python.javacc:535:10
                pushOntoCallStack("MappingPattern", "Python.javacc", 535, 10);
                try {
                    DoubleStarPattern();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrOne specified at Python.javacc:535:28
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:535:29
                    consumeToken(COMMA);
                }
            }
            // Code for RegexpStringLiteral specified at Python.javacc:537:3
            consumeToken(RBRACE);
        }
        catch(ParseException e) {
            parseException3103= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3104);
            if (MappingPattern91!=null) {
                if (parseException3103== null) {
                    closeNodeScope(MappingPattern91, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:540:1
    final public void DoubleStarPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "DoubleStarPattern";
        DoubleStarPattern DoubleStarPattern92= null;
        if (buildTree) {
            DoubleStarPattern92= new DoubleStarPattern();
            openNodeScope(DoubleStarPattern92);
        }
        ParseException parseException3160= null;
        int callStackSize3161= parsingStack.size();
        try {
            // Code for RegexpStringLiteral specified at Python.javacc:540:21
            consumeToken(STAR_STAR);
            // Code for RegexpRef specified at Python.javacc:540:26
            consumeToken(NAME);
        }
        catch(ParseException e) {
            parseException3160= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3161);
            if (DoubleStarPattern92!=null) {
                if (parseException3160== null) {
                    closeNodeScope(DoubleStarPattern92, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> LiteralPattern_FIRST_SET= LiteralPattern_FIRST_SET_init();
    static private EnumSet<TokenType> LiteralPattern_FIRST_SET_init() {
        return tokenTypeSet(MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL);
    }

    // Python.javacc:542:1
    final public void LiteralPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "LiteralPattern";
        // Code for ExpansionChoice specified at Python.javacc:543:4
        LiteralPattern LiteralPattern93= null;
        if (buildTree) {
            LiteralPattern93= new LiteralPattern();
            openNodeScope(LiteralPattern93);
        }
        ParseException parseException3169= null;
        int callStackSize3170= parsingStack.size();
        try {
            if (nextTokenType()== NONE) {
                // Code for RegexpStringLiteral specified at Python.javacc:543:4
                consumeToken(NONE);
            }
            else if (nextTokenType()== TRUE) {
                // Code for RegexpStringLiteral specified at Python.javacc:545:4
                consumeToken(TRUE);
            }
            else if (nextTokenType()== FALSE) {
                // Code for RegexpStringLiteral specified at Python.javacc:547:4
                consumeToken(FALSE);
            }
            else if (first_set$Python_javacc$549$4.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:549:4
                pushOntoCallStack("LiteralPattern", "Python.javacc", 549, 4);
                try {
                    SignedNumber();
                }
                finally {
                    popCallStack();
                }
            }
            else if (nextTokenType()== STRING_LITERAL) {
                // Code for NonTerminal specified at Python.javacc:551:4
                pushOntoCallStack("LiteralPattern", "Python.javacc", 551, 4);
                try {
                    Strings();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("LiteralPattern", "Python.javacc", 543, 4);
                throw new ParseException(this, LiteralPattern_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException3169= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3170);
            if (LiteralPattern93!=null) {
                if (parseException3169== null) {
                    closeNodeScope(LiteralPattern93, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:554:1
    final public void MaybeSequencePattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "MaybeSequencePattern";
        MaybeSequencePattern MaybeSequencePattern94= null;
        if (buildTree) {
            MaybeSequencePattern94= new MaybeSequencePattern();
            openNodeScope(MaybeSequencePattern94);
        }
        ParseException parseException3202= null;
        int callStackSize3203= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:555:4
            pushOntoCallStack("MaybeSequencePattern", "Python.javacc", 555, 4);
            try {
                MaybeStarPattern();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:555:21
            while (true) {
                if (!(scan$Python_javacc$555$22())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:555:22
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:555:32
                pushOntoCallStack("MaybeSequencePattern", "Python.javacc", 555, 32);
                try {
                    MaybeStarPattern();
                }
                finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at Python.javacc:555:51
            if (nextTokenType()== COMMA) {
                // Code for RegexpStringLiteral specified at Python.javacc:555:52
                consumeToken(COMMA);
            }
        }
        catch(ParseException e) {
            parseException3202= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3203);
            if (MaybeSequencePattern94!=null) {
                if (parseException3202== null) {
                    closeNodeScope(MaybeSequencePattern94, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:558:1
    final public void OpenSequencePattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "OpenSequencePattern";
        OpenSequencePattern OpenSequencePattern95= null;
        if (buildTree) {
            OpenSequencePattern95= new OpenSequencePattern();
            openNodeScope(OpenSequencePattern95);
        }
        ParseException parseException3229= null;
        int callStackSize3230= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:559:4
            pushOntoCallStack("OpenSequencePattern", "Python.javacc", 559, 4);
            try {
                MaybeStarPattern();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:559:21
            consumeToken(COMMA);
            // Code for ZeroOrOne specified at Python.javacc:559:30
            if (first_set$Python_javacc$559$31.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:559:31
                pushOntoCallStack("OpenSequencePattern", "Python.javacc", 559, 31);
                try {
                    MaybeSequencePattern();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException3229= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3230);
            if (OpenSequencePattern95!=null) {
                if (parseException3229== null) {
                    closeNodeScope(OpenSequencePattern95, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> SequencePattern_FIRST_SET= tokenTypeSet(LBRACKET, LPAREN);
    // Python.javacc:562:1
    final public void SequencePattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "SequencePattern";
        // Code for ExpansionChoice specified at Python.javacc:563:5
        SequencePattern SequencePattern96= null;
        if (buildTree) {
            SequencePattern96= new SequencePattern();
            openNodeScope(SequencePattern96);
        }
        ParseException parseException3247= null;
        int callStackSize3248= parsingStack.size();
        try {
            if (nextTokenType()== LBRACKET) {
                // Code for RegexpStringLiteral specified at Python.javacc:563:5
                consumeToken(LBRACKET);
                // Code for ZeroOrOne specified at Python.javacc:563:9
                if (first_set$Python_javacc$563$10.contains(nextTokenType())) {
                    // Code for NonTerminal specified at Python.javacc:563:10
                    pushOntoCallStack("SequencePattern", "Python.javacc", 563, 10);
                    try {
                        MaybeSequencePattern();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for RegexpStringLiteral specified at Python.javacc:563:32
                consumeToken(RBRACKET);
            }
            else if (nextTokenType()== LPAREN) {
                // Code for RegexpStringLiteral specified at Python.javacc:565:5
                consumeToken(LPAREN);
                // Code for ZeroOrOne specified at Python.javacc:565:9
                if (scan$Python_javacc$565$10()) {
                    // Code for NonTerminal specified at Python.javacc:565:10
                    pushOntoCallStack("SequencePattern", "Python.javacc", 565, 10);
                    try {
                        OpenSequencePattern();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for RegexpStringLiteral specified at Python.javacc:565:31
                consumeToken(RPAREN);
            }
            else  {
                pushOntoCallStack("SequencePattern", "Python.javacc", 563, 5);
                throw new ParseException(this, SequencePattern_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException3247= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3248);
            if (SequencePattern96!=null) {
                if (parseException3247== null) {
                    closeNodeScope(SequencePattern96, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:568:1
    final public void ClassPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "ClassPattern";
        ClassPattern ClassPattern97= null;
        if (buildTree) {
            ClassPattern97= new ClassPattern();
            openNodeScope(ClassPattern97);
        }
        ParseException parseException3286= null;
        int callStackSize3287= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:569:4
            pushOntoCallStack("ClassPattern", "Python.javacc", 569, 4);
            try {
                NameOrAttribute();
            }
            finally {
                popCallStack();
            }
            // Code for RegexpStringLiteral specified at Python.javacc:570:4
            consumeToken(LPAREN);
            // Code for ZeroOrOne specified at Python.javacc:572:7
            // Code for ExpansionChoice specified at Python.javacc:573:11
            if (scan$Python_javacc$573$11()) {
                // Code for NonTerminal specified at Python.javacc:574:11
                pushOntoCallStack("ClassPattern", "Python.javacc", 574, 11);
                try {
                    KeywordPatterns();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrOne specified at Python.javacc:574:27
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:574:28
                    consumeToken(COMMA);
                }
            }
            else if (first_set$Python_javacc$576$11.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:576:11
                pushOntoCallStack("ClassPattern", "Python.javacc", 576, 11);
                try {
                    PositionalPatterns();
                }
                finally {
                    popCallStack();
                }
                // Code for ZeroOrOne specified at Python.javacc:576:30
                if (scan$Python_javacc$576$31()) {
                    // Code for RegexpStringLiteral specified at Python.javacc:576:31
                    consumeToken(COMMA);
                    // Code for NonTerminal specified at Python.javacc:576:41
                    pushOntoCallStack("ClassPattern", "Python.javacc", 576, 41);
                    try {
                        KeywordPatterns();
                    }
                    finally {
                        popCallStack();
                    }
                }
                // Code for ZeroOrOne specified at Python.javacc:576:58
                if (nextTokenType()== COMMA) {
                    // Code for RegexpStringLiteral specified at Python.javacc:576:59
                    consumeToken(COMMA);
                }
            }
            // Code for RegexpStringLiteral specified at Python.javacc:578:4
            consumeToken(RPAREN);
        }
        catch(ParseException e) {
            parseException3286= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3287);
            if (ClassPattern97!=null) {
                if (parseException3286== null) {
                    closeNodeScope(ClassPattern97, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:581:1
    final public void PositionalPatterns() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "PositionalPatterns";
        PositionalPatterns PositionalPatterns98= null;
        if (buildTree) {
            PositionalPatterns98= new PositionalPatterns();
            openNodeScope(PositionalPatterns98);
        }
        ParseException parseException3346= null;
        int callStackSize3347= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:582:4
            pushOntoCallStack("PositionalPatterns", "Python.javacc", 582, 4);
            try {
                Pattern();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:583:4
            while (true) {
                if (!(scan$Python_javacc$586$8())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:587:11
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:587:15
                pushOntoCallStack("PositionalPatterns", "Python.javacc", 587, 15);
                try {
                    Pattern();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException3346= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3347);
            if (PositionalPatterns98!=null) {
                if (parseException3346== null) {
                    closeNodeScope(PositionalPatterns98, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:591:1
    final public void KeywordPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "KeywordPattern";
        KeywordPattern KeywordPattern99= null;
        if (buildTree) {
            KeywordPattern99= new KeywordPattern();
            openNodeScope(KeywordPattern99);
        }
        ParseException parseException3364= null;
        int callStackSize3365= parsingStack.size();
        try {
            // Code for RegexpRef specified at Python.javacc:591:18
            consumeToken(NAME);
            // Code for RegexpStringLiteral specified at Python.javacc:591:25
            consumeToken(ASSIGN);
            // Code for NonTerminal specified at Python.javacc:591:29
            pushOntoCallStack("KeywordPattern", "Python.javacc", 591, 29);
            try {
                Pattern();
            }
            finally {
                popCallStack();
            }
        }
        catch(ParseException e) {
            parseException3364= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3365);
            if (KeywordPattern99!=null) {
                if (parseException3364== null) {
                    closeNodeScope(KeywordPattern99, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:593:1
    final public void KeywordPatterns() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "KeywordPatterns";
        KeywordPatterns KeywordPatterns100= null;
        if (buildTree) {
            KeywordPatterns100= new KeywordPatterns();
            openNodeScope(KeywordPatterns100);
        }
        ParseException parseException3376= null;
        int callStackSize3377= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:593:19
            pushOntoCallStack("KeywordPatterns", "Python.javacc", 593, 19);
            try {
                KeywordPattern();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:593:34
            while (true) {
                if (!(scan$Python_javacc$593$35())) break;
                // Code for RegexpStringLiteral specified at Python.javacc:593:35
                consumeToken(COMMA);
                // Code for NonTerminal specified at Python.javacc:593:45
                pushOntoCallStack("KeywordPatterns", "Python.javacc", 593, 45);
                try {
                    KeywordPattern();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException3376= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3377);
            if (KeywordPatterns100!=null) {
                if (parseException3376== null) {
                    closeNodeScope(KeywordPatterns100, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:595:1
    final public void OrPattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "OrPattern";
        OrPattern OrPattern101= null;
        if (buildTree) {
            OrPattern101= new OrPattern();
            openNodeScope(OrPattern101);
        }
        ParseException parseException3394= null;
        int callStackSize3395= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:595:13
            pushOntoCallStack("OrPattern", "Python.javacc", 595, 13);
            try {
                ClosedPattern();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at Python.javacc:595:27
            while (true) {
                if (!(nextTokenType()== BIT_OR)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:595:28
                consumeToken(BIT_OR);
                // Code for NonTerminal specified at Python.javacc:595:32
                pushOntoCallStack("OrPattern", "Python.javacc", 595, 32);
                try {
                    ClosedPattern();
                }
                finally {
                    popCallStack();
                }
            }
        }
        catch(ParseException e) {
            parseException3394= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3395);
            if (OrPattern101!=null) {
                if (parseException3394== null) {
                    closeNodeScope(OrPattern101, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:597:1
    final public void Pattern() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Pattern";
        Pattern Pattern102= null;
        if (buildTree) {
            Pattern102= new Pattern();
            openNodeScope(Pattern102);
        }
        ParseException parseException3412= null;
        int callStackSize3413= parsingStack.size();
        try {
            // Code for NonTerminal specified at Python.javacc:597:11
            pushOntoCallStack("Pattern", "Python.javacc", 597, 11);
            try {
                OrPattern();
            }
            finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at Python.javacc:597:21
            if (nextTokenType()== AS) {
                // Code for RegexpStringLiteral specified at Python.javacc:597:22
                consumeToken(AS);
                // Code for RegexpRef specified at Python.javacc:597:27
                consumeToken(NAME);
            }
        }
        catch(ParseException e) {
            parseException3412= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3413);
            if (Pattern102!=null) {
                if (parseException3412== null) {
                    closeNodeScope(Pattern102, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> SubjectExpression_FIRST_SET= SubjectExpression_FIRST_SET_init();
    static private EnumSet<TokenType> SubjectExpression_FIRST_SET_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    // Python.javacc:599:1
    final public void SubjectExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "SubjectExpression";
        // Code for ExpansionChoice specified at Python.javacc:600:4
        SubjectExpression SubjectExpression103= null;
        if (buildTree) {
            SubjectExpression103= new SubjectExpression();
            openNodeScope(SubjectExpression103);
        }
        ParseException parseException3430= null;
        int callStackSize3431= parsingStack.size();
        try {
            if (scan$Python_javacc$600$4()) {
                // Code for NonTerminal specified at Python.javacc:600:4
                pushOntoCallStack("SubjectExpression", "Python.javacc", 600, 4);
                try {
                    StarNamedExpression();
                }
                finally {
                    popCallStack();
                }
                // Code for RegexpStringLiteral specified at Python.javacc:600:24
                consumeToken(COMMA);
                // Code for ZeroOrOne specified at Python.javacc:600:33
                if (first_set$Python_javacc$600$34.contains(nextTokenType())) {
                    // Code for NonTerminal specified at Python.javacc:600:34
                    pushOntoCallStack("SubjectExpression", "Python.javacc", 600, 34);
                    try {
                        StarNamedExpressions();
                    }
                    finally {
                        popCallStack();
                    }
                }
            }
            else if (first_set$Python_javacc$602$4.contains(nextTokenType())) {
                // Code for NonTerminal specified at Python.javacc:602:4
                pushOntoCallStack("SubjectExpression", "Python.javacc", 602, 4);
                try {
                    NamedExpression();
                }
                finally {
                    popCallStack();
                }
            }
            else  {
                pushOntoCallStack("SubjectExpression", "Python.javacc", 600, 4);
                throw new ParseException(this, SubjectExpression_FIRST_SET, parsingStack);
            }
        }
        catch(ParseException e) {
            parseException3430= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3431);
            if (SubjectExpression103!=null) {
                if (parseException3430== null) {
                    closeNodeScope(SubjectExpression103, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:605:1
    final public void Attribute() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "Attribute";
        Attribute Attribute104= null;
        if (buildTree) {
            Attribute104= new Attribute();
            openNodeScope(Attribute104);
        }
        ParseException parseException3457= null;
        int callStackSize3458= parsingStack.size();
        try {
            // Code for RegexpRef specified at Python.javacc:605:13
            consumeToken(NAME);
            // Code for OneOrMore specified at Python.javacc:605:20
            while (true) {
                // Code for RegexpStringLiteral specified at Python.javacc:605:21
                consumeToken(DOT);
                // Code for RegexpRef specified at Python.javacc:605:25
                consumeToken(NAME);
                if (!(nextTokenType()== DOT)) break;
            }
        }
        catch(ParseException e) {
            parseException3457= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3458);
            if (Attribute104!=null) {
                if (parseException3457== null) {
                    closeNodeScope(Attribute104, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    // Python.javacc:607:1
    final public void NameOrAttribute() {
        if (cancelled) throw new CancellationException();
        String prevProduction= currentlyParsedProduction;
        this.currentlyParsedProduction= "NameOrAttribute";
        Attribute NameOrAttribute105= null;
        if (buildTree) {
            NameOrAttribute105= new Attribute();
            openNodeScope(NameOrAttribute105);
        }
        ParseException parseException3475= null;
        int callStackSize3476= parsingStack.size();
        try {
            // Code for RegexpRef specified at Python.javacc:607:34
            consumeToken(NAME);
            // Code for ZeroOrMore specified at Python.javacc:607:41
            while (true) {
                if (!(nextTokenType()== DOT)) break;
                // Code for RegexpStringLiteral specified at Python.javacc:607:42
                consumeToken(DOT);
                // Code for RegexpRef specified at Python.javacc:607:46
                consumeToken(NAME);
            }
        }
        catch(ParseException e) {
            parseException3475= e;
            throw e;
        }
        finally {
            restoreCallStack(callStackSize3476);
            if (NameOrAttribute105!=null) {
                if (parseException3475== null) {
                    closeNodeScope(NameOrAttribute105, nodeArity()> 1);
                }
                else  {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction= prevProduction;
        }
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$23$5= first_set$Python_javacc$23$5_init();
    static private EnumSet<TokenType> first_set$Python_javacc$23$5_init() {
        return tokenTypeSet(AT, LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, _ASSERT, ASYNC, AWAIT, BREAK, CLASS, CONTINUE, DEF, DEL, FOR, FROM, GLOBAL, IF, FALSE, IMPORT, LAMBDA, MATCH, NONLOCAL, NONE, NOT, PASS, PEG_PARSER, RAISE, RETURN, TRUE, TRY, WHILE, WITH, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$34$3= tokenTypeSet(DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX);
    static private final EnumSet<TokenType> first_set$Python_javacc$35$5= tokenTypeSet(MINUS, PLUS);
    static private final EnumSet<TokenType> first_set$Python_javacc$43$5= tokenTypeSet(DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX);
    static private final EnumSet<TokenType> first_set$Python_javacc$55$6= tokenTypeSet(LPAREN);
    static private final EnumSet<TokenType> first_set$Python_javacc$57$6= tokenTypeSet(LBRACKET);
    static private final EnumSet<TokenType> first_set$Python_javacc$59$6= tokenTypeSet(LBRACE);
    static private final EnumSet<TokenType> first_set$Python_javacc$65$6= first_set$Python_javacc$65$6_init();
    static private EnumSet<TokenType> first_set$Python_javacc$65$6_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$65$28= first_set$Python_javacc$65$28_init();
    static private EnumSet<TokenType> first_set$Python_javacc$65$28_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$65$46= first_set$Python_javacc$65$46_init();
    static private EnumSet<TokenType> first_set$Python_javacc$65$46_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$67$5= first_set$Python_javacc$67$5_init();
    static private EnumSet<TokenType> first_set$Python_javacc$67$5_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$75$4= first_set$Python_javacc$75$4_init();
    static private EnumSet<TokenType> first_set$Python_javacc$75$4_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, _ASSERT, AWAIT, BREAK, CONTINUE, DEL, FROM, GLOBAL, FALSE, IMPORT, LAMBDA, NONLOCAL, NONE, NOT, PASS, PEG_PARSER, RAISE, RETURN, TRUE, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$77$4= first_set$Python_javacc$77$4_init();
    static private EnumSet<TokenType> first_set$Python_javacc$77$4_init() {
        return tokenTypeSet(AT, ASYNC, CLASS, DEF, FOR, IF, TRY, WHILE, WITH);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$85$4= first_set$Python_javacc$85$4_init();
    static private EnumSet<TokenType> first_set$Python_javacc$85$4_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$126$29= first_set$Python_javacc$126$29_init();
    static private EnumSet<TokenType> first_set$Python_javacc$126$29_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$134$28= first_set$Python_javacc$134$28_init();
    static private EnumSet<TokenType> first_set$Python_javacc$134$28_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$137$5= first_set$Python_javacc$137$5_init();
    static private EnumSet<TokenType> first_set$Python_javacc$137$5_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, _ASSERT, AWAIT, BREAK, CONTINUE, DEL, FROM, GLOBAL, FALSE, IMPORT, LAMBDA, NONLOCAL, NONE, NOT, PASS, PEG_PARSER, RAISE, RETURN, TRUE, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$139$23= first_set$Python_javacc$139$23_init();
    static private EnumSet<TokenType> first_set$Python_javacc$139$23_init() {
        return tokenTypeSet(AT, LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, _ASSERT, ASYNC, AWAIT, BREAK, CLASS, CONTINUE, DEF, DEL, FOR, FROM, GLOBAL, IF, FALSE, IMPORT, LAMBDA, MATCH, NONLOCAL, NONE, NOT, PASS, PEG_PARSER, RAISE, RETURN, TRUE, TRY, WHILE, WITH, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$144$26= first_set$Python_javacc$144$26_init();
    static private EnumSet<TokenType> first_set$Python_javacc$144$26_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$159$9= first_set$Python_javacc$159$9_init();
    static private EnumSet<TokenType> first_set$Python_javacc$159$9_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$161$9= first_set$Python_javacc$161$9_init();
    static private EnumSet<TokenType> first_set$Python_javacc$161$9_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$179$8= tokenTypeSet(EXCEPT, FINALLY);
    static private final EnumSet<TokenType> first_set$Python_javacc$195$28= tokenTypeSet(DOT, ELLIPSIS);
    static private final EnumSet<TokenType> first_set$Python_javacc$197$28= tokenTypeSet(DOT, ELLIPSIS);
    static private final EnumSet<TokenType> first_set$Python_javacc$210$6= first_set$Python_javacc$210$6_init();
    static private EnumSet<TokenType> first_set$Python_javacc$210$6_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$216$5= first_set$Python_javacc$216$5_init();
    static private EnumSet<TokenType> first_set$Python_javacc$216$5_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$229$40= tokenTypeSet(LSHIFT, RSHIFT);
    static private final EnumSet<TokenType> first_set$Python_javacc$231$49= tokenTypeSet(MINUS, PLUS);
    static private final EnumSet<TokenType> first_set$Python_javacc$233$45= tokenTypeSet(AT, STAR, SLASH, PERCENT, _TOKEN_100);
    static private final EnumSet<TokenType> first_set$Python_javacc$233$46= tokenTypeSet(AT, STAR, SLASH, PERCENT, _TOKEN_100);
    static private final EnumSet<TokenType> first_set$Python_javacc$235$19= first_set$Python_javacc$235$19_init();
    static private EnumSet<TokenType> first_set$Python_javacc$235$19_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, ELLIPSIS, AWAIT, FALSE, NONE, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$235$28= tokenTypeSet(TILDE, MINUS, PLUS);
    static private final EnumSet<TokenType> first_set$Python_javacc$241$10= first_set$Python_javacc$241$10_init();
    static private EnumSet<TokenType> first_set$Python_javacc$241$10_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$241$35= first_set$Python_javacc$241$35_init();
    static private EnumSet<TokenType> first_set$Python_javacc$241$35_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$244$14= first_set$Python_javacc$244$14_init();
    static private EnumSet<TokenType> first_set$Python_javacc$244$14_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$244$32= first_set$Python_javacc$244$32_init();
    static private EnumSet<TokenType> first_set$Python_javacc$244$32_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$264$14= first_set$Python_javacc$264$14_init();
    static private EnumSet<TokenType> first_set$Python_javacc$264$14_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$269$34= first_set$Python_javacc$269$34_init();
    static private EnumSet<TokenType> first_set$Python_javacc$269$34_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$278$7= first_set$Python_javacc$278$7_init();
    static private EnumSet<TokenType> first_set$Python_javacc$278$7_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, STAR_STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$305$7= tokenTypeSet(ASSIGN, COLONEQUALS);
    static private final EnumSet<TokenType> first_set$Python_javacc$313$4= first_set$Python_javacc$313$4_init();
    static private EnumSet<TokenType> first_set$Python_javacc$313$4_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, STAR_STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$326$5= first_set$Python_javacc$326$5_init();
    static private EnumSet<TokenType> first_set$Python_javacc$326$5_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$335$6= first_set$Python_javacc$335$6_init();
    static private EnumSet<TokenType> first_set$Python_javacc$335$6_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR_STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$371$14= first_set$Python_javacc$371$14_init();
    static private EnumSet<TokenType> first_set$Python_javacc$371$14_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$379$25= first_set$Python_javacc$379$25_init();
    static private EnumSet<TokenType> first_set$Python_javacc$379$25_init() {
        return tokenTypeSet(EQ, LE, GE, NE, GT, LT, IN, IS, NOT);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$397$13= first_set$Python_javacc$397$13_init();
    static private EnumSet<TokenType> first_set$Python_javacc$397$13_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$430$11= tokenTypeSet(SLASH, NAME);
    static private final EnumSet<TokenType> first_set$Python_javacc$445$13= tokenTypeSet(COLON, RPAREN);
    static private final EnumSet<TokenType> first_set$Python_javacc$456$4= first_set$Python_javacc$456$4_init();
    static private EnumSet<TokenType> first_set$Python_javacc$456$4_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, ELLIPSIS, FALSE, NONE, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$462$28= first_set$Python_javacc$462$28_init();
    static private EnumSet<TokenType> first_set$Python_javacc$462$28_init() {
        return tokenTypeSet(COLON, MINUSASSIGN, PLUSASSIGN, STARASSIGN, ATASSIGN, SLASHASSIGN, REMASSIGN, ANDASSIGN, ORASSIGN, XORASSIGN, LSHIFTASSIGN, RSHIFTASSIGN, STARSTARASSIGN, SLASHSLASHASSIGN);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$464$3= first_set$Python_javacc$464$3_init();
    static private EnumSet<TokenType> first_set$Python_javacc$464$3_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, ELLIPSIS, FALSE, NONE, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$466$22= first_set$Python_javacc$466$22_init();
    static private EnumSet<TokenType> first_set$Python_javacc$466$22_init() {
        return tokenTypeSet(MINUSASSIGN, PLUSASSIGN, STARASSIGN, ATASSIGN, SLASHASSIGN, REMASSIGN, ANDASSIGN, ORASSIGN, XORASSIGN, LSHIFTASSIGN, RSHIFTASSIGN, STARSTARASSIGN, SLASHSLASHASSIGN);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$466$38= first_set$Python_javacc$466$38_init();
    static private EnumSet<TokenType> first_set$Python_javacc$466$38_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$466$56= first_set$Python_javacc$466$56_init();
    static private EnumSet<TokenType> first_set$Python_javacc$466$56_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$468$30= first_set$Python_javacc$468$30_init();
    static private EnumSet<TokenType> first_set$Python_javacc$468$30_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, YIELD, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$468$48= first_set$Python_javacc$468$48_init();
    static private EnumSet<TokenType> first_set$Python_javacc$468$48_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$501$4= first_set$Python_javacc$501$4_init();
    static private EnumSet<TokenType> first_set$Python_javacc$501$4_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$508$39= first_set$Python_javacc$508$39_init();
    static private EnumSet<TokenType> first_set$Python_javacc$508$39_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$513$4= first_set$Python_javacc$513$4_init();
    static private EnumSet<TokenType> first_set$Python_javacc$513$4_init() {
        return tokenTypeSet(MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$526$19$= first_set$Python_javacc$526$19$_init();
    static private EnumSet<TokenType> first_set$Python_javacc$526$19$_init() {
        return tokenTypeSet(MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$526$19= first_set$Python_javacc$526$19_init();
    static private EnumSet<TokenType> first_set$Python_javacc$526$19_init() {
        return tokenTypeSet(MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$533$10= first_set$Python_javacc$533$10_init();
    static private EnumSet<TokenType> first_set$Python_javacc$533$10_init() {
        return tokenTypeSet(MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$549$4= tokenTypeSet(MINUS, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX);
    static private final EnumSet<TokenType> first_set$Python_javacc$559$31= first_set$Python_javacc$559$31_init();
    static private EnumSet<TokenType> first_set$Python_javacc$559$31_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$563$10= first_set$Python_javacc$563$10_init();
    static private EnumSet<TokenType> first_set$Python_javacc$563$10_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$576$11= first_set$Python_javacc$576$11_init();
    static private EnumSet<TokenType> first_set$Python_javacc$576$11_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, MINUS, FALSE, NONE, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$600$34= first_set$Python_javacc$600$34_init();
    static private EnumSet<TokenType> first_set$Python_javacc$600$34_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, STAR, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    static private final EnumSet<TokenType> first_set$Python_javacc$602$4= first_set$Python_javacc$602$4_init();
    static private EnumSet<TokenType> first_set$Python_javacc$602$4_init() {
        return tokenTypeSet(LBRACE, LBRACKET, LPAREN, TILDE, ELLIPSIS, MINUS, PLUS, AWAIT, FALSE, LAMBDA, NONE, NOT, PEG_PARSER, TRUE, DECNUMBER, HEXNUMBER, OCTNUMBER, BINNUMBER, FLOAT, COMPLEX, STRING_LITERAL, NAME);
    }

    private final boolean scanToken(TokenType expectedType) {
        Token peekedToken= nextToken(currentLookaheadToken);
        TokenType type= peekedToken.getType();
        if (type!=expectedType) return false;
        if (remainingLookahead!=UNLIMITED) remainingLookahead--;
        currentLookaheadToken= peekedToken;
        return true;
    }

    private final boolean scanToken(EnumSet<TokenType> types) {
        Token peekedToken= nextToken(currentLookaheadToken);
        TokenType type= peekedToken.getType();
        if (!types.contains(type)) return false;
        if (remainingLookahead!=UNLIMITED) remainingLookahead--;
        //     if (type == upToTokenType) remainingLookahead = 0;
        currentLookaheadToken= peekedToken;
        return true;
    }

    // scanahead routine for expansion at: 
    // Python.javacc:35:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$35$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:35:5
            // Applying single-token optimization for expansion of type ExpansionChoice
            // Python.javacc:35:5
            if (!scanToken(first_set$Python_javacc$35$5)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:35:14
            if (!scanToken(COMPLEX)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:45:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$45$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:45:5
            // NonTerminal Strings at Python.javacc:45:5
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 45, 5);
            boolean prevScanToEnd3494= scanToEnd;
            currentLookaheadProduction= "Strings";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Strings()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3494;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:55:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$55$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:55:6
            Token token3495= currentLookaheadToken;
            int remainingLookahead3495= remainingLookahead;
            boolean hitFailure3495= hitFailure;
            if (!check$Python_javacc$55$6()) {
                currentLookaheadToken= token3495;
                remainingLookahead= remainingLookahead3495;
                hitFailure= hitFailure3495;
                if (!check$Python_javacc$55$14()) {
                    currentLookaheadToken= token3495;
                    remainingLookahead= remainingLookahead3495;
                    hitFailure= hitFailure3495;
                    if (!check$Python_javacc$55$23()) {
                        currentLookaheadToken= token3495;
                        remainingLookahead= remainingLookahead3495;
                        hitFailure= hitFailure3495;
                        return false;
                    }
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:55:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$55$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (!check$Python_javacc$240$9()) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:55:6
            // NonTerminal Tuple at Python.javacc:55:6
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 55, 6);
            boolean prevScanToEnd3497= scanToEnd;
            currentLookaheadProduction= "Tuple";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Tuple()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3497;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:55:14
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$55$14() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:55:14
            // NonTerminal GenExp at Python.javacc:55:14
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 55, 14);
            boolean prevScanToEnd3498= scanToEnd;
            currentLookaheadProduction= "GenExp";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$GenExp()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3498;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:55:23
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$55$23() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:55:23
            // NonTerminal Group at Python.javacc:55:23
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 55, 23);
            boolean prevScanToEnd3499= scanToEnd;
            currentLookaheadProduction= "Group";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Group()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3499;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:57:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$57$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:57:6
            Token token3500= currentLookaheadToken;
            int remainingLookahead3500= remainingLookahead;
            boolean hitFailure3500= hitFailure;
            if (!check$Python_javacc$57$6()) {
                currentLookaheadToken= token3500;
                remainingLookahead= remainingLookahead3500;
                hitFailure= hitFailure3500;
                if (!check$Python_javacc$57$17()) {
                    currentLookaheadToken= token3500;
                    remainingLookahead= remainingLookahead3500;
                    hitFailure= hitFailure3500;
                    return false;
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:57:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$57$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:57:6
            // NonTerminal ListComp at Python.javacc:57:6
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 57, 6);
            boolean prevScanToEnd3502= scanToEnd;
            currentLookaheadProduction= "ListComp";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ListComp()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3502;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:57:17
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$57$17() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:57:17
            // NonTerminal List at Python.javacc:57:17
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 57, 17);
            boolean prevScanToEnd3503= scanToEnd;
            currentLookaheadProduction= "List";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$List()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3503;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:59:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$59$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:59:6
            Token token3504= currentLookaheadToken;
            int remainingLookahead3504= remainingLookahead;
            boolean hitFailure3504= hitFailure;
            if (!check$Python_javacc$59$6()) {
                currentLookaheadToken= token3504;
                remainingLookahead= remainingLookahead3504;
                hitFailure= hitFailure3504;
                if (!check$Python_javacc$59$16()) {
                    currentLookaheadToken= token3504;
                    remainingLookahead= remainingLookahead3504;
                    hitFailure= hitFailure3504;
                    if (!check$Python_javacc$59$27()) {
                        currentLookaheadToken= token3504;
                        remainingLookahead= remainingLookahead3504;
                        hitFailure= hitFailure3504;
                        if (!check$Python_javacc$59$34()) {
                            currentLookaheadToken= token3504;
                            remainingLookahead= remainingLookahead3504;
                            hitFailure= hitFailure3504;
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:59:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$59$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:59:6
            // NonTerminal SetComp at Python.javacc:59:6
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 59, 6);
            boolean prevScanToEnd3506= scanToEnd;
            currentLookaheadProduction= "SetComp";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$SetComp()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3506;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:59:16
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$59$16() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:59:16
            // NonTerminal DictComp at Python.javacc:59:16
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 59, 16);
            boolean prevScanToEnd3507= scanToEnd;
            currentLookaheadProduction= "DictComp";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$DictComp()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3507;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:59:27
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$59$27() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (!check$Python_javacc$332$8()) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:59:27
            // NonTerminal Dict at Python.javacc:59:27
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 59, 27);
            boolean prevScanToEnd3508= scanToEnd;
            currentLookaheadProduction= "Dict";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Dict()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3508;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:59:34
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$59$34() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:59:34
            // NonTerminal Set at Python.javacc:59:34
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 59, 34);
            boolean prevScanToEnd3509= scanToEnd;
            currentLookaheadProduction= "Set";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Set()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3509;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:65:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$65$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:65:5
            Token token3510= currentLookaheadToken;
            if (!check$Python_javacc$65$6()) {
                currentLookaheadToken= token3510;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:65:18
            if (!scanToken(COLON)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:65:27
            Token token3511= currentLookaheadToken;
            if (!check$Python_javacc$65$28()) {
                currentLookaheadToken= token3511;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:65:40
            Token token3512= currentLookaheadToken;
            if (!check$Python_javacc$65$41()) {
                currentLookaheadToken= token3512;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:65:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$65$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:65:6
            // NonTerminal Expression at Python.javacc:65:6
            pushOntoLookaheadStack("Slice", "Python.javacc", 65, 6);
            boolean prevScanToEnd3513= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3513;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:65:28
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$65$28() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:65:28
            // NonTerminal Expression at Python.javacc:65:28
            pushOntoLookaheadStack("Slice", "Python.javacc", 65, 28);
            boolean prevScanToEnd3514= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3514;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:65:41
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$65$41() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:65:41
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:65:45
            Token token3515= currentLookaheadToken;
            if (!check$Python_javacc$65$46()) {
                currentLookaheadToken= token3515;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:65:46
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$65$46() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:65:46
            // NonTerminal Expression at Python.javacc:65:46
            pushOntoLookaheadStack("Slice", "Python.javacc", 65, 46);
            boolean prevScanToEnd3516= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3516;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:67:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$67$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:67:5
            Token token3517= currentLookaheadToken;
            if (!check$Python_javacc$67$6()) {
                currentLookaheadToken= token3517;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:67:22
            // NonTerminal Expression at Python.javacc:67:22
            pushOntoLookaheadStack("Slice", "Python.javacc", 67, 22);
            boolean prevScanToEnd3518= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3518;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:67:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$67$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:67:9
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:67:16
            if (!scanToken(COLONEQUALS)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:70:21
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$70$21() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:70:21
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:70:31
            // NonTerminal Slice at Python.javacc:70:31
            pushOntoLookaheadStack("Slices", "Python.javacc", 70, 31);
            boolean prevScanToEnd3519= scanToEnd;
            currentLookaheadProduction= "Slice";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Slice()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3519;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:73:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$73$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:73:4
            // NonTerminal MatchStatement at Python.javacc:73:4
            pushOntoLookaheadStack("Statement", "Python.javacc", 73, 4);
            boolean prevScanToEnd3520= scanToEnd;
            currentLookaheadProduction= "MatchStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$MatchStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3520;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:75:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$75$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:75:4
            // NonTerminal SimpleStatement at Python.javacc:75:4
            pushOntoLookaheadStack("Statement", "Python.javacc", 75, 4);
            boolean prevScanToEnd3521= scanToEnd;
            currentLookaheadProduction= "SimpleStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$SimpleStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3521;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:77:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$77$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:77:4
            // NonTerminal CompoundStatement at Python.javacc:77:4
            pushOntoLookaheadStack("Statement", "Python.javacc", 77, 4);
            boolean prevScanToEnd3522= scanToEnd;
            currentLookaheadProduction= "CompoundStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$CompoundStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3522;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:80:40
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$80$40() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:80:40
            if (!scanToken(SEMICOLON)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:80:50
            // NonTerminal SmallStatement at Python.javacc:80:50
            pushOntoLookaheadStack("SimpleStatement", "Python.javacc", 80, 50);
            boolean prevScanToEnd3523= scanToEnd;
            currentLookaheadProduction= "SmallStatement";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$SmallStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3523;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:83:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$83$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (!check$Python_javacc$462$7()) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:83:4
            // NonTerminal Assignment at Python.javacc:83:4
            pushOntoLookaheadStack("SmallStatement", "Python.javacc", 83, 4);
            boolean prevScanToEnd3524= scanToEnd;
            currentLookaheadProduction= "Assignment";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Assignment()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3524;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:85:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$85$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:85:4
            // NonTerminal StarExpressions at Python.javacc:85:4
            pushOntoLookaheadStack("SmallStatement", "Python.javacc", 85, 4);
            boolean prevScanToEnd3525= scanToEnd;
            currentLookaheadProduction= "StarExpressions";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarExpressions()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3525;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:87:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$87$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:87:4
            // NonTerminal ReturnStatement at Python.javacc:87:4
            pushOntoLookaheadStack("SmallStatement", "Python.javacc", 87, 4);
            boolean prevScanToEnd3526= scanToEnd;
            currentLookaheadProduction= "ReturnStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ReturnStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3526;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:89:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$89$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:89:4
            // NonTerminal ImportStatement at Python.javacc:89:4
            pushOntoLookaheadStack("SmallStatement", "Python.javacc", 89, 4);
            boolean prevScanToEnd3527= scanToEnd;
            currentLookaheadProduction= "ImportStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ImportStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3527;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:91:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$91$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:91:4
            // NonTerminal GlobalStatement at Python.javacc:91:4
            pushOntoLookaheadStack("SmallStatement", "Python.javacc", 91, 4);
            boolean prevScanToEnd3528= scanToEnd;
            currentLookaheadProduction= "GlobalStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$GlobalStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3528;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:93:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$93$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:93:4
            // NonTerminal NonlocalStatement at Python.javacc:93:4
            pushOntoLookaheadStack("SmallStatement", "Python.javacc", 93, 4);
            boolean prevScanToEnd3529= scanToEnd;
            currentLookaheadProduction= "NonlocalStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$NonlocalStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3529;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:101:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$101$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:101:4
            // NonTerminal DelStatement at Python.javacc:101:4
            pushOntoLookaheadStack("SmallStatement", "Python.javacc", 101, 4);
            boolean prevScanToEnd3530= scanToEnd;
            currentLookaheadProduction= "DelStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$DelStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3530;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:103:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$103$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:103:4
            // NonTerminal AssertStatement at Python.javacc:103:4
            pushOntoLookaheadStack("SmallStatement", "Python.javacc", 103, 4);
            boolean prevScanToEnd3531= scanToEnd;
            currentLookaheadProduction= "AssertStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$AssertStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3531;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:105:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$105$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:105:4
            // NonTerminal RaiseStatement at Python.javacc:105:4
            pushOntoLookaheadStack("SmallStatement", "Python.javacc", 105, 4);
            boolean prevScanToEnd3532= scanToEnd;
            currentLookaheadProduction= "RaiseStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$RaiseStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3532;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:107:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$107$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:107:4
            // NonTerminal YieldStatement at Python.javacc:107:4
            pushOntoLookaheadStack("SmallStatement", "Python.javacc", 107, 4);
            boolean prevScanToEnd3533= scanToEnd;
            currentLookaheadProduction= "YieldStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$YieldStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3533;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:111:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$111$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:111:5
            // NonTerminal FunctionDefinition at Python.javacc:111:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 111, 5);
            boolean prevScanToEnd3534= scanToEnd;
            currentLookaheadProduction= "FunctionDefinition";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$FunctionDefinition()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3534;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:113:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$113$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:113:5
            // NonTerminal IfStatement at Python.javacc:113:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 113, 5);
            boolean prevScanToEnd3535= scanToEnd;
            currentLookaheadProduction= "IfStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$IfStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3535;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:115:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$115$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:115:5
            // NonTerminal ClassDefinition at Python.javacc:115:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 115, 5);
            boolean prevScanToEnd3536= scanToEnd;
            currentLookaheadProduction= "ClassDefinition";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ClassDefinition()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3536;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:117:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$117$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:117:5
            // NonTerminal WithStatement at Python.javacc:117:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 117, 5);
            boolean prevScanToEnd3537= scanToEnd;
            currentLookaheadProduction= "WithStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$WithStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3537;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:119:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$119$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:119:5
            // NonTerminal WhileStatement at Python.javacc:119:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 119, 5);
            boolean prevScanToEnd3538= scanToEnd;
            currentLookaheadProduction= "WhileStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$WhileStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3538;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:121:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$121$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:121:5
            // NonTerminal ForStatement at Python.javacc:121:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 121, 5);
            boolean prevScanToEnd3539= scanToEnd;
            currentLookaheadProduction= "ForStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ForStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3539;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:123:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$123$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:123:5
            // NonTerminal TryStatement at Python.javacc:123:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 123, 5);
            boolean prevScanToEnd3540= scanToEnd;
            currentLookaheadProduction= "TryStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$TryStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3540;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:126:29
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$126$29() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:126:29
            // NonTerminal StarExpressions at Python.javacc:126:29
            pushOntoLookaheadStack("ReturnStatement", "Python.javacc", 126, 29);
            boolean prevScanToEnd3541= scanToEnd;
            currentLookaheadProduction= "StarExpressions";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarExpressions()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3541;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:128:36
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$128$36() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:128:36
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:128:40
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:130:40
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$130$40() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:130:40
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:130:44
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:132:40
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$132$40() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:132:40
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:132:44
            // NonTerminal Expression at Python.javacc:132:44
            pushOntoLookaheadStack("AssertStatement", "Python.javacc", 132, 44);
            boolean prevScanToEnd3542= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3542;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:134:28
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$134$28() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:134:28
            // NonTerminal Expression at Python.javacc:134:28
            pushOntoLookaheadStack("RaiseStatement", "Python.javacc", 134, 28);
            boolean prevScanToEnd3543= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3543;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:134:39
            Token token3544= currentLookaheadToken;
            if (!check$Python_javacc$134$40()) {
                currentLookaheadToken= token3544;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:134:40
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$134$40() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:134:40
            if (!scanToken(FROM)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:134:47
            // NonTerminal Expression at Python.javacc:134:47
            pushOntoLookaheadStack("RaiseStatement", "Python.javacc", 134, 47);
            boolean prevScanToEnd3545= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3545;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:137:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$137$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:137:5
            // NonTerminal SimpleStatement at Python.javacc:137:5
            pushOntoLookaheadStack("Block", "Python.javacc", 137, 5);
            boolean prevScanToEnd3546= scanToEnd;
            currentLookaheadProduction= "SimpleStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$SimpleStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3546;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:139:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$139$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:139:5
            if (!scanToken(NEWLINE)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:139:14
            if (!scanToken(INDENT)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for OneOrMore specified at Python.javacc:139:22
            if (!check$Python_javacc$139$23()) {
                return false;
            }
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3547= currentLookaheadToken;
                if (!check$Python_javacc$139$23()) {
                    currentLookaheadToken= token3547;
                    break;
                }
            }
            hitFailure= false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:139:34
            if (!scanToken(DEDENT)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:139:23
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$139$23() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:139:23
            // NonTerminal Statement at Python.javacc:139:23
            pushOntoLookaheadStack("Block", "Python.javacc", 139, 23);
            boolean prevScanToEnd3548= scanToEnd;
            currentLookaheadProduction= "Statement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Statement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3548;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:144:26
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$144$26() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:144:26
            Token token3549= currentLookaheadToken;
            if (!scanToken(STAR)) {
                currentLookaheadToken= token3549;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:144:32
            // NonTerminal Expression at Python.javacc:144:32
            pushOntoLookaheadStack("ExceptBlock", "Python.javacc", 144, 32);
            boolean prevScanToEnd3550= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3550;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:144:43
            Token token3551= currentLookaheadToken;
            if (!check$Python_javacc$144$44()) {
                currentLookaheadToken= token3551;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:144:44
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$144$44() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:144:44
            if (!scanToken(AS)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:144:49
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:148:7
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$148$7() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:148:7
            if (!scanToken(ELIF)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:148:14
            // NonTerminal NamedExpression at Python.javacc:148:14
            pushOntoLookaheadStack("IfStatement", "Python.javacc", 148, 14);
            boolean prevScanToEnd3552= scanToEnd;
            currentLookaheadProduction= "NamedExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$NamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3552;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:148:30
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:148:34
            // NonTerminal Block at Python.javacc:148:34
            pushOntoLookaheadStack("IfStatement", "Python.javacc", 148, 34);
            boolean prevScanToEnd3553= scanToEnd;
            currentLookaheadProduction= "Block";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Block()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3553;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:149:7
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$149$7() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:149:7
            if (!scanToken(ELSE)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:149:14
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:149:18
            // NonTerminal Block at Python.javacc:149:18
            pushOntoLookaheadStack("IfStatement", "Python.javacc", 149, 18);
            boolean prevScanToEnd3554= scanToEnd;
            currentLookaheadProduction= "Block";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Block()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3554;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:154:53
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$154$53() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:154:53
            // NonTerminal ElseBlock at Python.javacc:154:53
            pushOntoLookaheadStack("WhileStatement", "Python.javacc", 154, 53);
            boolean prevScanToEnd3555= scanToEnd;
            currentLookaheadProduction= "ElseBlock";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ElseBlock()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3555;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:159:9
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$159$9() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (!check$Python_javacc$159$14()) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:159:44
            // NonTerminal WithItemsInParentheses at Python.javacc:159:44
            pushOntoLookaheadStack("WithStatement", "Python.javacc", 159, 44);
            boolean prevScanToEnd3556= scanToEnd;
            currentLookaheadProduction= "WithItemsInParentheses";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$WithItemsInParentheses()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3556;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:161:9
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$161$9() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:161:9
            // NonTerminal WithItem at Python.javacc:161:9
            pushOntoLookaheadStack("WithStatement", "Python.javacc", 161, 9);
            boolean prevScanToEnd3557= scanToEnd;
            currentLookaheadProduction= "WithItem";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$WithItem()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3557;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrMore specified at Python.javacc:161:18
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3558= currentLookaheadToken;
                if (!check$Python_javacc$161$19()) {
                    currentLookaheadToken= token3558;
                    break;
                }
            }
            hitFailure= false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:161:19
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$161$19() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:161:19
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:161:23
            // NonTerminal WithItem at Python.javacc:161:23
            pushOntoLookaheadStack("WithStatement", "Python.javacc", 161, 23);
            boolean prevScanToEnd3559= scanToEnd;
            currentLookaheadProduction= "WithItem";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$WithItem()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3559;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:166:45
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$166$45() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:166:52
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:166:56
            // NonTerminal WithItem at Python.javacc:166:56
            pushOntoLookaheadStack("WithItemsInParentheses", "Python.javacc", 166, 56);
            boolean prevScanToEnd3560= scanToEnd;
            currentLookaheadProduction= "WithItem";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$WithItem()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3560;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:168:24
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$168$24() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:168:24
            if (!scanToken(AS)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:168:29
            // NonTerminal StarTarget at Python.javacc:168:29
            pushOntoLookaheadStack("WithItem", "Python.javacc", 168, 29);
            boolean prevScanToEnd3561= scanToEnd;
            currentLookaheadProduction= "StarTarget";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarTarget()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3561;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:173:11
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$173$11() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:173:11
            // NonTerminal ElseBlock at Python.javacc:173:11
            pushOntoLookaheadStack("ForStatement", "Python.javacc", 173, 11);
            boolean prevScanToEnd3562= scanToEnd;
            currentLookaheadProduction= "ElseBlock";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ElseBlock()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3562;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:179:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$179$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:179:8
            // NonTerminal FinallyBlock at Python.javacc:179:8
            pushOntoLookaheadStack("TryStatement", "Python.javacc", 179, 8);
            boolean prevScanToEnd3563= scanToEnd;
            currentLookaheadProduction= "FinallyBlock";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$FinallyBlock()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3563;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:181:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$181$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for OneOrMore specified at Python.javacc:181:9
            if (!check$Python_javacc$181$10()) {
                return false;
            }
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3564= currentLookaheadToken;
                if (!check$Python_javacc$181$10()) {
                    currentLookaheadToken= token3564;
                    break;
                }
            }
            hitFailure= false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:181:24
            Token token3565= currentLookaheadToken;
            if (!check$Python_javacc$181$25()) {
                currentLookaheadToken= token3565;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:181:36
            Token token3566= currentLookaheadToken;
            if (!check$Python_javacc$181$37()) {
                currentLookaheadToken= token3566;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:181:10
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$181$10() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:181:10
            // NonTerminal ExceptBlock at Python.javacc:181:10
            pushOntoLookaheadStack("TryStatement", "Python.javacc", 181, 10);
            boolean prevScanToEnd3570= scanToEnd;
            currentLookaheadProduction= "ExceptBlock";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ExceptBlock()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3570;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:181:25
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$181$25() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:181:25
            // NonTerminal ElseBlock at Python.javacc:181:25
            pushOntoLookaheadStack("TryStatement", "Python.javacc", 181, 25);
            boolean prevScanToEnd3571= scanToEnd;
            currentLookaheadProduction= "ElseBlock";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ElseBlock()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3571;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:181:37
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$181$37() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:181:37
            // NonTerminal FinallyBlock at Python.javacc:181:37
            pushOntoLookaheadStack("TryStatement", "Python.javacc", 181, 37);
            boolean prevScanToEnd3572= scanToEnd;
            currentLookaheadProduction= "FinallyBlock";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$FinallyBlock()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3572;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:185:41
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$185$41() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:185:48
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:185:52
            // NonTerminal PrimaryExpression at Python.javacc:185:52
            pushOntoLookaheadStack("DelStatement", "Python.javacc", 185, 52);
            boolean prevScanToEnd3573= scanToEnd;
            currentLookaheadProduction= "PrimaryExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$PrimaryExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3573;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:187:21
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$187$21() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:187:24
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:187:31
            if (!scanToken(COLONEQUALS)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:189:22
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$189$22() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:189:25
            if (!scanToken(DOT)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:189:29
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:191:19
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$191$19() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:191:19
            // NonTerminal ImportName at Python.javacc:191:19
            pushOntoLookaheadStack("ImportStatement", "Python.javacc", 191, 19);
            boolean prevScanToEnd3574= scanToEnd;
            currentLookaheadProduction= "ImportName";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ImportName()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3574;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:191:32
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$191$32() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:191:32
            // NonTerminal ImportFrom1 at Python.javacc:191:32
            pushOntoLookaheadStack("ImportStatement", "Python.javacc", 191, 32);
            boolean prevScanToEnd3575= scanToEnd;
            currentLookaheadProduction= "ImportFrom1";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ImportFrom1()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3575;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:191:46
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$191$46() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:191:46
            // NonTerminal ImportFrom2 at Python.javacc:191:46
            pushOntoLookaheadStack("ImportStatement", "Python.javacc", 191, 46);
            boolean prevScanToEnd3576= scanToEnd;
            currentLookaheadProduction= "ImportFrom2";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ImportFrom2()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3576;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:193:40
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$193$40() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:193:40
            if (!scanToken(AS)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:193:45
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:193:54
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$193$54() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:193:54
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:193:58
            // NonTerminal DottedName at Python.javacc:193:58
            pushOntoLookaheadStack("ImportName", "Python.javacc", 193, 58);
            boolean prevScanToEnd3577= scanToEnd;
            currentLookaheadProduction= "DottedName";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$DottedName()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3577;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:193:69
            Token token3578= currentLookaheadToken;
            if (!check$Python_javacc$193$70()) {
                currentLookaheadToken= token3578;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:193:70
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$193$70() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:193:70
            if (!scanToken(AS)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:193:75
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:202:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$202$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:202:4
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:202:11
            Token token3579= currentLookaheadToken;
            if (!check$Python_javacc$202$12()) {
                currentLookaheadToken= token3579;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrMore specified at Python.javacc:202:25
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3580= currentLookaheadToken;
                if (!check$Python_javacc$202$26()) {
                    currentLookaheadToken= token3580;
                    break;
                }
            }
            hitFailure= false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:202:58
            Token token3581= currentLookaheadToken;
            if (!scanToken(COMMA)) {
                currentLookaheadToken= token3581;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:202:12
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$202$12() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:202:12
            if (!scanToken(AS)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:202:17
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:202:26
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$202$26() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:202:26
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:202:30
            if (!scanToken(NAME)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:202:42
            Token token3582= currentLookaheadToken;
            if (!check$Python_javacc$202$43()) {
                currentLookaheadToken= token3582;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:202:43
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$202$43() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:202:43
            if (!scanToken(AS)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:202:48
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:204:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$204$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:204:4
            if (!scanToken(LPAREN)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:204:8
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:204:15
            Token token3583= currentLookaheadToken;
            if (!check$Python_javacc$204$16()) {
                currentLookaheadToken= token3583;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrMore specified at Python.javacc:204:29
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3584= currentLookaheadToken;
                if (!check$Python_javacc$204$30()) {
                    currentLookaheadToken= token3584;
                    break;
                }
            }
            hitFailure= false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:204:62
            Token token3585= currentLookaheadToken;
            if (!scanToken(COMMA)) {
                currentLookaheadToken= token3585;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:204:68
            if (!scanToken(RPAREN)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:204:72
            Token token3586= currentLookaheadToken;
            if (!scanToken(COMMA)) {
                currentLookaheadToken= token3586;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:204:16
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$204$16() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:204:16
            if (!scanToken(AS)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:204:21
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:204:30
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$204$30() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:204:30
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:204:34
            if (!scanToken(NAME)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:204:46
            Token token3587= currentLookaheadToken;
            if (!check$Python_javacc$204$47()) {
                currentLookaheadToken= token3587;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:204:47
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$204$47() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:204:47
            if (!scanToken(AS)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:204:52
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:208:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$208$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:208:6
            if (!scanToken(STAR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:208:10
            // NonTerminal BitwiseOr at Python.javacc:208:10
            pushOntoLookaheadStack("StarNamedExpression", "Python.javacc", 208, 10);
            boolean prevScanToEnd3588= scanToEnd;
            currentLookaheadProduction= "BitwiseOr";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$BitwiseOr()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3588;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:210:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$210$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:210:6
            // NonTerminal NamedExpression at Python.javacc:210:6
            pushOntoLookaheadStack("StarNamedExpression", "Python.javacc", 210, 6);
            boolean prevScanToEnd3589= scanToEnd;
            currentLookaheadProduction= "NamedExpression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$NamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3589;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:214:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$214$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:214:5
            if (!scanToken(STAR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:214:9
            // NonTerminal BitwiseOr at Python.javacc:214:9
            pushOntoLookaheadStack("StarExpression", "Python.javacc", 214, 9);
            boolean prevScanToEnd3590= scanToEnd;
            currentLookaheadProduction= "BitwiseOr";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$BitwiseOr()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3590;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:216:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$216$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:216:5
            // NonTerminal Expression at Python.javacc:216:5
            pushOntoLookaheadStack("StarExpression", "Python.javacc", 216, 5);
            boolean prevScanToEnd3591= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3591;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:219:35
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$219$35() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:219:35
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:219:45
            // NonTerminal StarExpression at Python.javacc:219:45
            pushOntoLookaheadStack("StarExpressions", "Python.javacc", 219, 45);
            boolean prevScanToEnd3592= scanToEnd;
            currentLookaheadProduction= "StarExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3592;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:221:45
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$221$45() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:221:45
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:221:55
            // NonTerminal StarNamedExpression at Python.javacc:221:55
            pushOntoLookaheadStack("StarNamedExpressions", "Python.javacc", 221, 55);
            boolean prevScanToEnd3593= scanToEnd;
            currentLookaheadProduction= "StarNamedExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarNamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3593;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:223:25
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$223$25() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:223:25
            if (!scanToken(BIT_OR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:223:29
            // NonTerminal BitwiseXor at Python.javacc:223:29
            pushOntoLookaheadStack("BitwiseOr", "Python.javacc", 223, 29);
            boolean prevScanToEnd3594= scanToEnd;
            currentLookaheadProduction= "BitwiseXor";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$BitwiseXor()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3594;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:225:26
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$225$26() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:225:26
            if (!scanToken(XOR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:225:30
            // NonTerminal BitwiseAnd at Python.javacc:225:30
            pushOntoLookaheadStack("BitwiseXor", "Python.javacc", 225, 30);
            boolean prevScanToEnd3595= scanToEnd;
            currentLookaheadProduction= "BitwiseAnd";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$BitwiseAnd()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3595;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:227:31
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$227$31() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:227:31
            if (!scanToken(BIT_AND)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:227:35
            // NonTerminal ShiftExpression at Python.javacc:227:35
            pushOntoLookaheadStack("BitwiseAnd", "Python.javacc", 227, 35);
            boolean prevScanToEnd3596= scanToEnd;
            currentLookaheadProduction= "ShiftExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$ShiftExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3596;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:229:39
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$229$39() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:229:40
            // Applying single-token optimization for expansion of type ExpansionChoice
            // Python.javacc:229:40
            if (!scanToken(first_set$Python_javacc$229$40)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:229:53
            // NonTerminal AdditiveExpression at Python.javacc:229:53
            pushOntoLookaheadStack("ShiftExpression", "Python.javacc", 229, 53);
            boolean prevScanToEnd3597= scanToEnd;
            currentLookaheadProduction= "AdditiveExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$AdditiveExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3597;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:231:48
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$231$48() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:231:49
            // Applying single-token optimization for expansion of type ExpansionChoice
            // Python.javacc:231:49
            if (!scanToken(first_set$Python_javacc$231$49)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:231:58
            // NonTerminal MultiplicativeExpression at Python.javacc:231:58
            pushOntoLookaheadStack("AdditiveExpression", "Python.javacc", 231, 58);
            boolean prevScanToEnd3598= scanToEnd;
            currentLookaheadProduction= "MultiplicativeExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$MultiplicativeExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3598;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:233:45
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$233$45() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:233:46
            // Applying single-token optimization for expansion of type ExpansionChoice
            // Python.javacc:233:46
            if (!scanToken(first_set$Python_javacc$233$46)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:233:68
            // NonTerminal UnaryExpression at Python.javacc:233:68
            pushOntoLookaheadStack("MultiplicativeExpression", "Python.javacc", 233, 68);
            boolean prevScanToEnd3599= scanToEnd;
            currentLookaheadProduction= "UnaryExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$UnaryExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3599;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:235:19
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$235$19() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:235:19
            // NonTerminal Power at Python.javacc:235:19
            pushOntoLookaheadStack("UnaryExpression", "Python.javacc", 235, 19);
            boolean prevScanToEnd3600= scanToEnd;
            currentLookaheadProduction= "Power";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Power()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3600;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:235:27
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$235$27() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:235:28
            // Applying single-token optimization for expansion of type ExpansionChoice
            // Python.javacc:235:28
            if (!scanToken(first_set$Python_javacc$235$28)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:235:45
            // NonTerminal UnaryExpression at Python.javacc:235:45
            pushOntoLookaheadStack("UnaryExpression", "Python.javacc", 235, 45);
            boolean prevScanToEnd3601= scanToEnd;
            currentLookaheadProduction= "UnaryExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$UnaryExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3601;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:237:23
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$237$23() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:237:23
            if (!scanToken(STAR_STAR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:237:28
            // NonTerminal UnaryExpression at Python.javacc:237:28
            pushOntoLookaheadStack("Power", "Python.javacc", 237, 28);
            boolean prevScanToEnd3602= scanToEnd;
            currentLookaheadProduction= "UnaryExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$UnaryExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3602;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:240:20
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$240$20() {
        try {
            lookaheadRoutineNesting++;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:240:20
            // NonTerminal StarNamedExpression at Python.javacc:240:20
            pushOntoLookaheadStack("Tuple", "Python.javacc", 240, 20);
            boolean prevScanToEnd3603= scanToEnd;
            currentLookaheadProduction= "StarNamedExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarNamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3603;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:240:40
            if (!scanToken(COMMA)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:241:10
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$241$10() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:241:10
            // NonTerminal StarNamedExpression at Python.javacc:241:10
            pushOntoLookaheadStack("Tuple", "Python.javacc", 241, 10);
            boolean prevScanToEnd3604= scanToEnd;
            currentLookaheadProduction= "StarNamedExpression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarNamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3604;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:241:30
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:241:34
            Token token3605= currentLookaheadToken;
            if (!check$Python_javacc$241$35()) {
                currentLookaheadToken= token3605;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:241:35
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$241$35() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:241:35
            // NonTerminal StarNamedExpressions at Python.javacc:241:35
            pushOntoLookaheadStack("Tuple", "Python.javacc", 241, 35);
            boolean prevScanToEnd3606= scanToEnd;
            currentLookaheadProduction= "StarNamedExpressions";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarNamedExpressions()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3606;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:244:14
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$244$14() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:244:14
            // NonTerminal YieldExpression at Python.javacc:244:14
            pushOntoLookaheadStack("Group", "Python.javacc", 244, 14);
            boolean prevScanToEnd3607= scanToEnd;
            currentLookaheadProduction= "YieldExpression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$YieldExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3607;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:244:32
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$244$32() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:244:32
            // NonTerminal NamedExpression at Python.javacc:244:32
            pushOntoLookaheadStack("Group", "Python.javacc", 244, 32);
            boolean prevScanToEnd3608= scanToEnd;
            currentLookaheadProduction= "NamedExpression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$NamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3608;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:251:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$251$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:251:8
            Token token3609= currentLookaheadToken;
            int remainingLookahead3609= remainingLookahead;
            boolean hitFailure3609= hitFailure;
            if (!check$Python_javacc$251$8$()) {
                currentLookaheadToken= token3609;
                remainingLookahead= remainingLookahead3609;
                hitFailure= hitFailure3609;
                if (!check$Python_javacc$253$8()) {
                    currentLookaheadToken= token3609;
                    remainingLookahead= remainingLookahead3609;
                    hitFailure= hitFailure3609;
                    if (!check$Python_javacc$255$8()) {
                        currentLookaheadToken= token3609;
                        remainingLookahead= remainingLookahead3609;
                        hitFailure= hitFailure3609;
                        if (!check$Python_javacc$257$8()) {
                            currentLookaheadToken= token3609;
                            remainingLookahead= remainingLookahead3609;
                            hitFailure= hitFailure3609;
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:251:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$251$8$() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:251:8
            if (!scanToken(DOT)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:251:12
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:253:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$253$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:253:8
            // NonTerminal Slices at Python.javacc:253:8
            pushOntoLookaheadStack("PrimaryExpression", "Python.javacc", 253, 8);
            boolean prevScanToEnd3610= scanToEnd;
            currentLookaheadProduction= "Slices";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Slices()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3610;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:255:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$255$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:255:8
            // NonTerminal GenExp at Python.javacc:255:8
            pushOntoLookaheadStack("PrimaryExpression", "Python.javacc", 255, 8);
            boolean prevScanToEnd3611= scanToEnd;
            currentLookaheadProduction= "GenExp";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$GenExp()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3611;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:257:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$257$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:257:8
            // NonTerminal InvocationArguments at Python.javacc:257:8
            pushOntoLookaheadStack("PrimaryExpression", "Python.javacc", 257, 8);
            boolean prevScanToEnd3612= scanToEnd;
            currentLookaheadProduction= "InvocationArguments";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$InvocationArguments()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3612;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:262:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$262$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:262:5
            if (!scanToken(YIELD)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:262:13
            if (!scanToken(FROM)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:262:25
            // NonTerminal Expression at Python.javacc:262:25
            pushOntoLookaheadStack("YieldExpression", "Python.javacc", 262, 25);
            boolean prevScanToEnd3613= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3613;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:264:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$264$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:264:5
            if (!scanToken(YIELD)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:264:13
            Token token3614= currentLookaheadToken;
            if (!check$Python_javacc$264$14()) {
                currentLookaheadToken= token3614;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:264:14
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$264$14() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:264:14
            // NonTerminal StarExpressions at Python.javacc:264:14
            pushOntoLookaheadStack("YieldExpression", "Python.javacc", 264, 14);
            boolean prevScanToEnd3615= scanToEnd;
            currentLookaheadProduction= "StarExpressions";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarExpressions()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3615;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:269:16
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$269$16() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:269:16
            // NonTerminal YieldExpression at Python.javacc:269:16
            pushOntoLookaheadStack("AnnotatedRhs", "Python.javacc", 269, 16);
            boolean prevScanToEnd3616= scanToEnd;
            currentLookaheadProduction= "YieldExpression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$YieldExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3616;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:269:34
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$269$34() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:269:34
            // NonTerminal StarExpressions at Python.javacc:269:34
            pushOntoLookaheadStack("AnnotatedRhs", "Python.javacc", 269, 34);
            boolean prevScanToEnd3617= scanToEnd;
            currentLookaheadProduction= "StarExpressions";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarExpressions()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3617;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:271:15
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$271$15() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:271:15
            if (!scanToken(AT)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:271:19
            // NonTerminal NamedExpression at Python.javacc:271:19
            pushOntoLookaheadStack("Decorators", "Python.javacc", 271, 19);
            boolean prevScanToEnd3618= scanToEnd;
            currentLookaheadProduction= "NamedExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$NamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3618;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:271:35
            if (!scanToken(NEWLINE)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:278:7
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$278$7() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:278:7
            // NonTerminal Argument at Python.javacc:278:7
            pushOntoLookaheadStack("InvocationArguments", "Python.javacc", 278, 7);
            boolean prevScanToEnd3619= scanToEnd;
            currentLookaheadProduction= "Argument";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Argument()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3619;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for CodeBlock specified at Python.javacc:279:7
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrMore specified at Python.javacc:288:7
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3620= currentLookaheadToken;
                if (!check$Python_javacc$289$10()) {
                    currentLookaheadToken= token3620;
                    break;
                }
            }
            hitFailure= false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:297:7
            Token token3621= currentLookaheadToken;
            if (!scanToken(COMMA)) {
                currentLookaheadToken= token3621;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:289:10
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$289$10() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:290:10
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:291:10
            // NonTerminal Argument at Python.javacc:291:10
            pushOntoLookaheadStack("InvocationArguments", "Python.javacc", 291, 10);
            boolean prevScanToEnd3622= scanToEnd;
            currentLookaheadProduction= "Argument";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Argument()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3622;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for CodeBlock specified at Python.javacc:292:10
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:303:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$303$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:303:4
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:305:7
            Token token3623= currentLookaheadToken;
            int remainingLookahead3623= remainingLookahead;
            boolean hitFailure3623= hitFailure;
            if (!check$Python_javacc$305$7()) {
                currentLookaheadToken= token3623;
                remainingLookahead= remainingLookahead3623;
                hitFailure= hitFailure3623;
                if (!scanToken(ASSIGN)) {
                    currentLookaheadToken= token3623;
                    remainingLookahead= remainingLookahead3623;
                    hitFailure= hitFailure3623;
                    return false;
                }
            }
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:311:4
            // NonTerminal Expression at Python.javacc:311:4
            pushOntoLookaheadStack("Argument", "Python.javacc", 311, 4);
            boolean prevScanToEnd3624= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3624;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:305:7
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$305$7() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:306:7
            if (!scanToken(COLONEQUALS)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:313:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$313$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:313:4
            Token token3625= currentLookaheadToken;
            if (!check$Python_javacc$314$7$()) {
                currentLookaheadToken= token3625;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:318:4
            // NonTerminal Expression at Python.javacc:318:4
            pushOntoLookaheadStack("Argument", "Python.javacc", 318, 4);
            boolean prevScanToEnd3626= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3626;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:314:7
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$314$7$() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:314:7
            Token token3627= currentLookaheadToken;
            int remainingLookahead3627= remainingLookahead;
            boolean hitFailure3627= hitFailure;
            if (!check$Python_javacc$314$7()) {
                currentLookaheadToken= token3627;
                remainingLookahead= remainingLookahead3627;
                hitFailure= hitFailure3627;
                if (!scanToken(STAR_STAR)) {
                    currentLookaheadToken= token3627;
                    remainingLookahead= remainingLookahead3627;
                    hitFailure= hitFailure3627;
                    return false;
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:314:7
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$314$7() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:314:35
            if (!scanToken(STAR)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:324:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$324$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:324:5
            if (!scanToken(STAR_STAR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:324:10
            // NonTerminal BitwiseOr at Python.javacc:324:10
            pushOntoLookaheadStack("DoubleStarredKeyValuePair", "Python.javacc", 324, 10);
            boolean prevScanToEnd3628= scanToEnd;
            currentLookaheadProduction= "BitwiseOr";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$BitwiseOr()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3628;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:326:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$326$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:326:5
            // NonTerminal KeyValuePair at Python.javacc:326:5
            pushOntoLookaheadStack("DoubleStarredKeyValuePair", "Python.javacc", 326, 5);
            boolean prevScanToEnd3629= scanToEnd;
            currentLookaheadProduction= "KeyValuePair";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$KeyValuePair()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3629;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:329:57
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$329$57() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:329:57
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:329:67
            // NonTerminal DoubleStarredKeyValuePair at Python.javacc:329:67
            pushOntoLookaheadStack("DoubleStarredKeyValuePairs", "Python.javacc", 329, 67);
            boolean prevScanToEnd3630= scanToEnd;
            currentLookaheadProduction= "DoubleStarredKeyValuePair";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$DoubleStarredKeyValuePair()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3630;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:332:19
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$332$19() {
        try {
            lookaheadRoutineNesting++;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:332:19
            // NonTerminal DoubleStarredKeyValuePair at Python.javacc:332:19
            pushOntoLookaheadStack("Dict", "Python.javacc", 332, 19);
            boolean prevScanToEnd3631= scanToEnd;
            currentLookaheadProduction= "DoubleStarredKeyValuePair";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$DoubleStarredKeyValuePair()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3631;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:335:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$335$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:335:6
            // NonTerminal DoubleStarredKeyValuePairs at Python.javacc:335:6
            pushOntoLookaheadStack("Dict", "Python.javacc", 335, 6);
            boolean prevScanToEnd3633= scanToEnd;
            currentLookaheadProduction= "DoubleStarredKeyValuePairs";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$DoubleStarredKeyValuePairs()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3633;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:340:36
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$340$36() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:340:36
            // NonTerminal ForIfClause at Python.javacc:340:36
            pushOntoLookaheadStack("DictComp", "Python.javacc", 340, 36);
            boolean prevScanToEnd3634= scanToEnd;
            currentLookaheadProduction= "ForIfClause";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ForIfClause()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3634;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:344:38
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$344$38() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:344:38
            // NonTerminal ForIfClause at Python.javacc:344:38
            pushOntoLookaheadStack("SetComp", "Python.javacc", 344, 38);
            boolean prevScanToEnd3635= scanToEnd;
            currentLookaheadProduction= "ForIfClause";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ForIfClause()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3635;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:347:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$347$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:347:6
            // NonTerminal Decorators at Python.javacc:347:6
            pushOntoLookaheadStack("ClassDefinition", "Python.javacc", 347, 6);
            boolean prevScanToEnd3636= scanToEnd;
            currentLookaheadProduction= "Decorators";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Decorators()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3636;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:348:13
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$348$13() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:348:13
            // NonTerminal InvocationArguments at Python.javacc:348:13
            pushOntoLookaheadStack("ClassDefinition", "Python.javacc", 348, 13);
            boolean prevScanToEnd3637= scanToEnd;
            currentLookaheadProduction= "InvocationArguments";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$InvocationArguments()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3637;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:354:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$354$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:354:6
            // NonTerminal Decorators at Python.javacc:354:6
            pushOntoLookaheadStack("FunctionDefinition", "Python.javacc", 354, 6);
            boolean prevScanToEnd3638= scanToEnd;
            currentLookaheadProduction= "Decorators";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Decorators()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3638;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:361:6
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$361$6() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:361:6
            if (!scanToken(RARROW)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:361:11
            // NonTerminal Expression at Python.javacc:361:11
            pushOntoLookaheadStack("FunctionDefinition", "Python.javacc", 361, 11);
            boolean prevScanToEnd3639= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3639;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:371:14
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$371$14() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:371:14
            // NonTerminal Disjunction at Python.javacc:371:14
            pushOntoLookaheadStack("Expression", "Python.javacc", 371, 14);
            boolean prevScanToEnd3640= scanToEnd;
            currentLookaheadProduction= "Disjunction";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Disjunction()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3640;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:371:26
            Token token3641= currentLookaheadToken;
            if (!check$Python_javacc$371$27()) {
                currentLookaheadToken= token3641;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:371:27
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$371$27() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:371:27
            if (!scanToken(IF)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:371:32
            // NonTerminal Disjunction at Python.javacc:371:32
            pushOntoLookaheadStack("Expression", "Python.javacc", 371, 32);
            boolean prevScanToEnd3642= scanToEnd;
            currentLookaheadProduction= "Disjunction";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Disjunction()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3642;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:371:44
            if (!scanToken(ELSE)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:371:51
            // NonTerminal Expression at Python.javacc:371:51
            pushOntoLookaheadStack("Expression", "Python.javacc", 371, 51);
            boolean prevScanToEnd3643= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3643;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:371:65
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$371$65() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:371:65
            // NonTerminal LambdaDefinition at Python.javacc:371:65
            pushOntoLookaheadStack("Expression", "Python.javacc", 371, 65);
            boolean prevScanToEnd3644= scanToEnd;
            currentLookaheadProduction= "LambdaDefinition";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$LambdaDefinition()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3644;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:373:28
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$373$28() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:373:28
            if (!scanToken(OR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:373:33
            // NonTerminal Conjunction at Python.javacc:373:33
            pushOntoLookaheadStack("Disjunction", "Python.javacc", 373, 33);
            boolean prevScanToEnd3645= scanToEnd;
            currentLookaheadProduction= "Conjunction";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Conjunction()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3645;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:375:26
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$375$26() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:375:26
            if (!scanToken(AND)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:375:32
            // NonTerminal Inversion at Python.javacc:375:32
            pushOntoLookaheadStack("Conjunction", "Python.javacc", 375, 32);
            boolean prevScanToEnd3646= scanToEnd;
            currentLookaheadProduction= "Inversion";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Inversion()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3646;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:379:25
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$379$25() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:379:25
            // NonTerminal ComparisonOperator at Python.javacc:379:25
            pushOntoLookaheadStack("Comparison", "Python.javacc", 379, 25);
            boolean prevScanToEnd3647= scanToEnd;
            currentLookaheadProduction= "ComparisonOperator";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ComparisonOperator()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3647;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:379:44
            // NonTerminal BitwiseOr at Python.javacc:379:44
            pushOntoLookaheadStack("Comparison", "Python.javacc", 379, 44);
            boolean prevScanToEnd3648= scanToEnd;
            currentLookaheadProduction= "BitwiseOr";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$BitwiseOr()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3648;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:384:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$384$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:384:4
            Token token3649= currentLookaheadToken;
            if (!scanToken(NOT)) {
                currentLookaheadToken= token3649;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:384:12
            if (!scanToken(IN)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:386:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$386$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:386:4
            if (!scanToken(IS)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:386:9
            Token token3650= currentLookaheadToken;
            if (!scanToken(NOT)) {
                currentLookaheadToken= token3650;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:391:27
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$391$27() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:391:27
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:391:37
            // NonTerminal StarTarget at Python.javacc:391:37
            pushOntoLookaheadStack("StarTargets", "Python.javacc", 391, 37);
            boolean prevScanToEnd3651= scanToEnd;
            currentLookaheadProduction= "StarTarget";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarTarget()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3651;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:393:61
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$393$61() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:393:61
            if (!scanToken(IF)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:393:66
            // NonTerminal Disjunction at Python.javacc:393:66
            pushOntoLookaheadStack("ForIfClause", "Python.javacc", 393, 66);
            boolean prevScanToEnd3652= scanToEnd;
            currentLookaheadProduction= "Disjunction";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Disjunction()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3652;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:395:37
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$395$37() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:395:37
            // NonTerminal ForIfClause at Python.javacc:395:37
            pushOntoLookaheadStack("GenExp", "Python.javacc", 395, 37);
            boolean prevScanToEnd3653= scanToEnd;
            currentLookaheadProduction= "ForIfClause";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ForIfClause()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3653;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:397:13
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$397$13() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:397:13
            // NonTerminal StarNamedExpressions at Python.javacc:397:13
            pushOntoLookaheadStack("List", "Python.javacc", 397, 13);
            boolean prevScanToEnd3654= scanToEnd;
            currentLookaheadProduction= "StarNamedExpressions";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarNamedExpressions()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3654;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:399:39
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$399$39() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:399:39
            // NonTerminal ForIfClause at Python.javacc:399:39
            pushOntoLookaheadStack("ListComp", "Python.javacc", 399, 39);
            boolean prevScanToEnd3655= scanToEnd;
            currentLookaheadProduction= "ForIfClause";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ForIfClause()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3655;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:402:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$402$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:402:4
            // NonTerminal KeyWords at Python.javacc:402:4
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 402, 4);
            boolean prevScanToEnd3656= scanToEnd;
            currentLookaheadProduction= "KeyWords";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$KeyWords()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3656;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:404:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$404$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:404:4
            if (!scanToken(STAR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:404:8
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:404:17
            // NonTerminal ParamMaybeDefault at Python.javacc:404:17
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 404, 17);
            boolean prevScanToEnd3657= scanToEnd;
            currentLookaheadProduction= "ParamMaybeDefault";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$ParamMaybeDefault()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3657;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrMore specified at Python.javacc:404:35
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3658= currentLookaheadToken;
                if (!check$Python_javacc$404$36()) {
                    currentLookaheadToken= token3658;
                    break;
                }
            }
            hitFailure= false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:404:66
            Token token3659= currentLookaheadToken;
            if (!check$Python_javacc$404$67()) {
                currentLookaheadToken= token3659;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:404:36
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$404$36() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:404:36
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:404:46
            // NonTerminal ParamMaybeDefault at Python.javacc:404:46
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 404, 46);
            boolean prevScanToEnd3660= scanToEnd;
            currentLookaheadProduction= "ParamMaybeDefault";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$ParamMaybeDefault()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3660;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:404:67
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$404$67() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:404:67
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:404:71
            Token token3661= currentLookaheadToken;
            if (!check$Python_javacc$404$72()) {
                currentLookaheadToken= token3661;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:404:72
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$404$72() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:404:72
            // NonTerminal KeyWords at Python.javacc:404:72
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 404, 72);
            boolean prevScanToEnd3662= scanToEnd;
            currentLookaheadProduction= "KeyWords";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$KeyWords()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3662;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:406:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$406$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:406:4
            if (!scanToken(STAR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:406:8
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:406:15
            Token token3663= currentLookaheadToken;
            if (!check$Python_javacc$406$16()) {
                currentLookaheadToken= token3663;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrMore specified at Python.javacc:406:64
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3664= currentLookaheadToken;
                if (!check$Python_javacc$406$65()) {
                    currentLookaheadToken= token3664;
                    break;
                }
            }
            hitFailure= false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:406:95
            Token token3665= currentLookaheadToken;
            if (!check$Python_javacc$406$96()) {
                currentLookaheadToken= token3665;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:406:16
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$406$16() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (!backscan$Python_javacc$406$23()) return false;
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:406:48
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:406:52
            // NonTerminal Expression at Python.javacc:406:52
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 406, 52);
            boolean prevScanToEnd3666= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3666;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:406:65
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$406$65() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:406:65
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:406:75
            // NonTerminal ParamMaybeDefault at Python.javacc:406:75
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 406, 75);
            boolean prevScanToEnd3667= scanToEnd;
            currentLookaheadProduction= "ParamMaybeDefault";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$ParamMaybeDefault()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3667;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:406:96
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$406$96() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:406:96
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:406:100
            Token token3668= currentLookaheadToken;
            if (!check$Python_javacc$406$101()) {
                currentLookaheadToken= token3668;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:406:101
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$406$101() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:406:101
            // NonTerminal KeyWords at Python.javacc:406:101
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 406, 101);
            boolean prevScanToEnd3669= scanToEnd;
            currentLookaheadProduction= "KeyWords";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$KeyWords()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3669;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:409:29
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$409$29() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:409:29
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:409:33
            // NonTerminal Expression at Python.javacc:409:33
            pushOntoLookaheadStack("ParamMaybeDefault", "Python.javacc", 409, 33);
            boolean prevScanToEnd3670= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3670;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:409:46
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$409$46() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:409:46
            if (!scanToken(ASSIGN)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:409:50
            // NonTerminal Expression at Python.javacc:409:50
            pushOntoLookaheadStack("ParamMaybeDefault", "Python.javacc", 409, 50);
            boolean prevScanToEnd3671= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3671;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:414:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$414$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (backscan$Python_javacc$414$15()) return false;
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:415:8
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:415:12
            // NonTerminal Expression at Python.javacc:415:12
            pushOntoLookaheadStack("KeyWords", "Python.javacc", 415, 12);
            boolean prevScanToEnd3672= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3672;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:422:7
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$422$7() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:422:7
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:425:7
            Token token3673= currentLookaheadToken;
            if (!check$Python_javacc$425$8()) {
                currentLookaheadToken= token3673;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:426:7
            Token token3674= currentLookaheadToken;
            if (!check$Python_javacc$426$8()) {
                currentLookaheadToken= token3674;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrMore specified at Python.javacc:427:7
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3675= currentLookaheadToken;
                if (!check$Python_javacc$427$8()) {
                    currentLookaheadToken= token3675;
                    break;
                }
            }
            hitFailure= false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:442:7
            Token token3676= currentLookaheadToken;
            if (!scanToken(COMMA)) {
                currentLookaheadToken= token3676;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:425:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$425$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (!backscan$Python_javacc$425$15()) return false;
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:425:38
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:425:42
            // NonTerminal Expression at Python.javacc:425:42
            pushOntoLookaheadStack("Parameters", "Python.javacc", 425, 42);
            boolean prevScanToEnd3677= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3677;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:426:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$426$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:426:8
            if (!scanToken(ASSIGN)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:426:12
            // NonTerminal Expression at Python.javacc:426:12
            pushOntoLookaheadStack("Parameters", "Python.javacc", 426, 12);
            boolean prevScanToEnd3678= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3678;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for CodeBlock specified at Python.javacc:426:23
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:427:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$427$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:427:8
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:430:11
            Token token3679= currentLookaheadToken;
            int remainingLookahead3679= remainingLookahead;
            boolean hitFailure3679= hitFailure;
            if (!check$Python_javacc$430$11()) {
                currentLookaheadToken= token3679;
                remainingLookahead= remainingLookahead3679;
                hitFailure= hitFailure3679;
                if (!check$Python_javacc$433$11()) {
                    currentLookaheadToken= token3679;
                    remainingLookahead= remainingLookahead3679;
                    hitFailure= hitFailure3679;
                    return false;
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:430:11
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$430$11() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:431:11
            if (!scanToken(SLASH)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for CodeBlock specified at Python.javacc:431:15
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:433:11
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$433$11() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:433:11
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:433:18
            Token token3680= currentLookaheadToken;
            if (!check$Python_javacc$433$19()) {
                currentLookaheadToken= token3680;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:434:11
            Token token3681= currentLookaheadToken;
            if (!check$Python_javacc$437$14()) {
                currentLookaheadToken= token3681;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:433:19
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$433$19() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (!backscan$Python_javacc$433$26()) return false;
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:433:49
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:433:53
            // NonTerminal Expression at Python.javacc:433:53
            pushOntoLookaheadStack("Parameters", "Python.javacc", 433, 53);
            boolean prevScanToEnd3682= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3682;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:437:14
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$437$14() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:438:17
            if (!scanToken(ASSIGN)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:438:21
            // NonTerminal Expression at Python.javacc:438:21
            pushOntoLookaheadStack("Parameters", "Python.javacc", 438, 21);
            boolean prevScanToEnd3683= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3683;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for CodeBlock specified at Python.javacc:438:32
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:445:7
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$445$7() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (check$Python_javacc$445$13()) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:445:26
            // NonTerminal StarEtc at Python.javacc:445:26
            pushOntoLookaheadStack("Parameters", "Python.javacc", 445, 26);
            boolean prevScanToEnd3684= scanToEnd;
            currentLookaheadProduction= "StarEtc";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarEtc()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3684;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:456:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$456$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:456:4
            // NonTerminal PrimaryExpression at Python.javacc:456:4
            pushOntoLookaheadStack("SimpleAssignTarget", "Python.javacc", 456, 4);
            boolean prevScanToEnd3685= scanToEnd;
            currentLookaheadProduction= "PrimaryExpression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$PrimaryExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3685;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:458:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$458$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:458:4
            if (!scanToken(LPAREN)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:458:8
            // NonTerminal SimpleAssignTarget at Python.javacc:458:8
            pushOntoLookaheadStack("SimpleAssignTarget", "Python.javacc", 458, 8);
            boolean prevScanToEnd3686= scanToEnd;
            currentLookaheadProduction= "SimpleAssignTarget";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$SimpleAssignTarget()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3686;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:458:27
            if (!scanToken(RPAREN)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:462:7
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$462$7$() {
        try {
            lookaheadRoutineNesting++;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:462:8
            // NonTerminal SimpleAssignTarget at Python.javacc:462:8
            pushOntoLookaheadStack("Assignment", "Python.javacc", 462, 8);
            boolean prevScanToEnd3687= scanToEnd;
            currentLookaheadProduction= "SimpleAssignTarget";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$SimpleAssignTarget()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3687;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:462:28
            // Applying single-token optimization for expansion of type ExpansionChoice
            // Python.javacc:462:28
            if (!scanToken(first_set$Python_javacc$462$28)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:462:48
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$462$48() {
        try {
            lookaheadRoutineNesting++;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:462:49
            // NonTerminal StarTargets at Python.javacc:462:49
            pushOntoLookaheadStack("Assignment", "Python.javacc", 462, 49);
            boolean prevScanToEnd3689= scanToEnd;
            currentLookaheadProduction= "StarTargets";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarTargets()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3689;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:462:61
            if (!scanToken(ASSIGN)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:464:3
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$464$3() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:464:3
            // NonTerminal SimpleAssignTarget at Python.javacc:464:3
            pushOntoLookaheadStack("Assignment", "Python.javacc", 464, 3);
            boolean prevScanToEnd3692= scanToEnd;
            currentLookaheadProduction= "SimpleAssignTarget";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$SimpleAssignTarget()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3692;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:464:22
            if (!scanToken(COLON)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:464:31
            // NonTerminal Expression at Python.javacc:464:31
            pushOntoLookaheadStack("Assignment", "Python.javacc", 464, 31);
            boolean prevScanToEnd3693= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3693;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:464:42
            Token token3694= currentLookaheadToken;
            if (!check$Python_javacc$464$43()) {
                currentLookaheadToken= token3694;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:464:43
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$464$43() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:464:43
            if (!scanToken(ASSIGN)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:464:47
            // NonTerminal AnnotatedRhs at Python.javacc:464:47
            pushOntoLookaheadStack("Assignment", "Python.javacc", 464, 47);
            boolean prevScanToEnd3695= scanToEnd;
            currentLookaheadProduction= "AnnotatedRhs";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$AnnotatedRhs()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3695;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:466:3
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$466$3() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:466:3
            // NonTerminal SimpleAssignTarget at Python.javacc:466:3
            pushOntoLookaheadStack("Assignment", "Python.javacc", 466, 3);
            boolean prevScanToEnd3696= scanToEnd;
            currentLookaheadProduction= "SimpleAssignTarget";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$SimpleAssignTarget()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3696;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:466:22
            // Applying single-token optimization for expansion of type NonTerminal
            // Python.javacc:466:22
            if (!scanToken(first_set$Python_javacc$466$22)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:466:38
            Token token3697= currentLookaheadToken;
            int remainingLookahead3697= remainingLookahead;
            boolean hitFailure3697= hitFailure;
            if (!check$Python_javacc$466$38()) {
                currentLookaheadToken= token3697;
                remainingLookahead= remainingLookahead3697;
                hitFailure= hitFailure3697;
                if (!check$Python_javacc$466$56()) {
                    currentLookaheadToken= token3697;
                    remainingLookahead= remainingLookahead3697;
                    hitFailure= hitFailure3697;
                    return false;
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:466:38
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$466$38() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:466:38
            // NonTerminal YieldExpression at Python.javacc:466:38
            pushOntoLookaheadStack("Assignment", "Python.javacc", 466, 38);
            boolean prevScanToEnd3698= scanToEnd;
            currentLookaheadProduction= "YieldExpression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$YieldExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3698;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:466:56
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$466$56() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:466:56
            // NonTerminal StarExpressions at Python.javacc:466:56
            pushOntoLookaheadStack("Assignment", "Python.javacc", 466, 56);
            boolean prevScanToEnd3699= scanToEnd;
            currentLookaheadProduction= "StarExpressions";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarExpressions()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3699;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:468:3
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$468$3() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for OneOrMore specified at Python.javacc:468:3
            if (!check$Python_javacc$468$4()) {
                return false;
            }
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3700= currentLookaheadToken;
                if (!check$Python_javacc$468$4()) {
                    currentLookaheadToken= token3700;
                    break;
                }
            }
            hitFailure= false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:468:30
            Token token3701= currentLookaheadToken;
            int remainingLookahead3701= remainingLookahead;
            boolean hitFailure3701= hitFailure;
            if (!check$Python_javacc$468$30()) {
                currentLookaheadToken= token3701;
                remainingLookahead= remainingLookahead3701;
                hitFailure= hitFailure3701;
                if (!check$Python_javacc$468$48()) {
                    currentLookaheadToken= token3701;
                    remainingLookahead= remainingLookahead3701;
                    hitFailure= hitFailure3701;
                    return false;
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:468:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$468$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:468:6
            // NonTerminal StarTargets at Python.javacc:468:6
            pushOntoLookaheadStack("Assignment", "Python.javacc", 468, 6);
            boolean prevScanToEnd3702= scanToEnd;
            currentLookaheadProduction= "StarTargets";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarTargets()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3702;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:468:18
            if (!scanToken(ASSIGN)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:468:30
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$468$30() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:468:30
            // NonTerminal YieldExpression at Python.javacc:468:30
            pushOntoLookaheadStack("Assignment", "Python.javacc", 468, 30);
            boolean prevScanToEnd3703= scanToEnd;
            currentLookaheadProduction= "YieldExpression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$YieldExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3703;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:468:48
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$468$48() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:468:48
            // NonTerminal StarExpressions at Python.javacc:468:48
            pushOntoLookaheadStack("Assignment", "Python.javacc", 468, 48);
            boolean prevScanToEnd3704= scanToEnd;
            currentLookaheadProduction= "StarExpressions";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarExpressions()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3704;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:482:26
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$482$26() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:482:26
            // NonTerminal CaseBlock at Python.javacc:482:26
            pushOntoLookaheadStack("MatchStatement", "Python.javacc", 482, 26);
            boolean prevScanToEnd3705= scanToEnd;
            currentLookaheadProduction= "CaseBlock";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$CaseBlock()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3705;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:491:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$491$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:491:8
            if (!scanToken(IF)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:491:13
            // NonTerminal NamedExpression at Python.javacc:491:13
            pushOntoLookaheadStack("CaseBlock", "Python.javacc", 491, 13);
            boolean prevScanToEnd3706= scanToEnd;
            currentLookaheadProduction= "NamedExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$NamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3706;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:499:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$499$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:499:4
            // NonTerminal OpenSequencePattern at Python.javacc:499:4
            pushOntoLookaheadStack("Patterns", "Python.javacc", 499, 4);
            boolean prevScanToEnd3707= scanToEnd;
            currentLookaheadProduction= "OpenSequencePattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$OpenSequencePattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3707;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:501:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$501$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:501:4
            // NonTerminal Pattern at Python.javacc:501:4
            pushOntoLookaheadStack("Patterns", "Python.javacc", 501, 4);
            boolean prevScanToEnd3708= scanToEnd;
            currentLookaheadProduction= "Pattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Pattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3708;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:508:25
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$508$25() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:508:25
            // NonTerminal StarPattern at Python.javacc:508:25
            pushOntoLookaheadStack("MaybeStarPattern", "Python.javacc", 508, 25);
            boolean prevScanToEnd3709= scanToEnd;
            currentLookaheadProduction= "StarPattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3709;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:508:39
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$508$39() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:508:39
            // NonTerminal Pattern at Python.javacc:508:39
            pushOntoLookaheadStack("MaybeStarPattern", "Python.javacc", 508, 39);
            boolean prevScanToEnd3710= scanToEnd;
            currentLookaheadProduction= "Pattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Pattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3710;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:511:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$511$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:511:4
            // NonTerminal ClassPattern at Python.javacc:511:4
            pushOntoLookaheadStack("ClosedPattern", "Python.javacc", 511, 4);
            boolean prevScanToEnd3711= scanToEnd;
            currentLookaheadProduction= "ClassPattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ClassPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3711;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:513:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$513$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:513:4
            // NonTerminal LiteralPattern at Python.javacc:513:4
            pushOntoLookaheadStack("ClosedPattern", "Python.javacc", 513, 4);
            boolean prevScanToEnd3712= scanToEnd;
            currentLookaheadProduction= "LiteralPattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$LiteralPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3712;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:515:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$515$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:515:4
            // NonTerminal NameOrAttribute at Python.javacc:515:4
            pushOntoLookaheadStack("ClosedPattern", "Python.javacc", 515, 4);
            boolean prevScanToEnd3713= scanToEnd;
            currentLookaheadProduction= "NameOrAttribute";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$NameOrAttribute()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3713;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:517:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$517$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:517:6
            // NonTerminal GroupPattern at Python.javacc:517:6
            pushOntoLookaheadStack("ClosedPattern", "Python.javacc", 517, 6);
            boolean prevScanToEnd3714= scanToEnd;
            currentLookaheadProduction= "GroupPattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$GroupPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3714;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:519:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$519$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:519:4
            // NonTerminal SequencePattern at Python.javacc:519:4
            pushOntoLookaheadStack("ClosedPattern", "Python.javacc", 519, 4);
            boolean prevScanToEnd3715= scanToEnd;
            currentLookaheadProduction= "SequencePattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$SequencePattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3715;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:521:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$521$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:521:4
            // NonTerminal MappingPattern at Python.javacc:521:4
            pushOntoLookaheadStack("ClosedPattern", "Python.javacc", 521, 4);
            boolean prevScanToEnd3716= scanToEnd;
            currentLookaheadProduction= "MappingPattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$MappingPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3716;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:526:19
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$526$19$() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:526:19
            // NonTerminal LiteralPattern at Python.javacc:526:19
            pushOntoLookaheadStack("KeyValuePattern", "Python.javacc", 526, 19);
            boolean prevScanToEnd3718= scanToEnd;
            currentLookaheadProduction= "LiteralPattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$LiteralPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3718;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:526:36
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$526$36() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:526:36
            // NonTerminal Attribute at Python.javacc:526:36
            pushOntoLookaheadStack("KeyValuePattern", "Python.javacc", 526, 36);
            boolean prevScanToEnd3719= scanToEnd;
            currentLookaheadProduction= "Attribute";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Attribute()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3719;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:528:33
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$528$33() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:528:33
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:528:43
            // NonTerminal KeyValuePattern at Python.javacc:528:43
            pushOntoLookaheadStack("ItemsPattern", "Python.javacc", 528, 43);
            boolean prevScanToEnd3720= scanToEnd;
            currentLookaheadProduction= "KeyValuePattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$KeyValuePattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3720;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:533:10
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$533$10() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:533:10
            Token token3721= currentLookaheadToken;
            int remainingLookahead3721= remainingLookahead;
            boolean hitFailure3721= hitFailure;
            if (!check$Python_javacc$533$10$()) {
                currentLookaheadToken= token3721;
                remainingLookahead= remainingLookahead3721;
                hitFailure= hitFailure3721;
                if (!check$Python_javacc$535$10()) {
                    currentLookaheadToken= token3721;
                    remainingLookahead= remainingLookahead3721;
                    hitFailure= hitFailure3721;
                    return false;
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:533:10
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$533$10$() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:533:10
            // NonTerminal ItemsPattern at Python.javacc:533:10
            pushOntoLookaheadStack("MappingPattern", "Python.javacc", 533, 10);
            boolean prevScanToEnd3722= scanToEnd;
            currentLookaheadProduction= "ItemsPattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ItemsPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3722;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:533:23
            Token token3723= currentLookaheadToken;
            if (!check$Python_javacc$533$24()) {
                currentLookaheadToken= token3723;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:533:53
            Token token3724= currentLookaheadToken;
            if (!scanToken(COMMA)) {
                currentLookaheadToken= token3724;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:533:24
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$533$24() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:533:24
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:533:34
            // NonTerminal DoubleStarPattern at Python.javacc:533:34
            pushOntoLookaheadStack("MappingPattern", "Python.javacc", 533, 34);
            boolean prevScanToEnd3725= scanToEnd;
            currentLookaheadProduction= "DoubleStarPattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$DoubleStarPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3725;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:535:10
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$535$10() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:535:10
            // NonTerminal DoubleStarPattern at Python.javacc:535:10
            pushOntoLookaheadStack("MappingPattern", "Python.javacc", 535, 10);
            boolean prevScanToEnd3726= scanToEnd;
            currentLookaheadProduction= "DoubleStarPattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$DoubleStarPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3726;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:535:28
            Token token3727= currentLookaheadToken;
            if (!scanToken(COMMA)) {
                currentLookaheadToken= token3727;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:549:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$549$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:549:4
            // NonTerminal SignedNumber at Python.javacc:549:4
            pushOntoLookaheadStack("LiteralPattern", "Python.javacc", 549, 4);
            boolean prevScanToEnd3728= scanToEnd;
            currentLookaheadProduction= "SignedNumber";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$SignedNumber()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3728;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:551:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$551$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:551:4
            // NonTerminal Strings at Python.javacc:551:4
            pushOntoLookaheadStack("LiteralPattern", "Python.javacc", 551, 4);
            boolean prevScanToEnd3729= scanToEnd;
            currentLookaheadProduction= "Strings";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$Strings()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3729;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:555:22
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$555$22() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:555:22
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:555:32
            // NonTerminal MaybeStarPattern at Python.javacc:555:32
            pushOntoLookaheadStack("MaybeSequencePattern", "Python.javacc", 555, 32);
            boolean prevScanToEnd3730= scanToEnd;
            currentLookaheadProduction= "MaybeStarPattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$MaybeStarPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3730;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:559:31
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$559$31() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:559:31
            // NonTerminal MaybeSequencePattern at Python.javacc:559:31
            pushOntoLookaheadStack("OpenSequencePattern", "Python.javacc", 559, 31);
            boolean prevScanToEnd3731= scanToEnd;
            currentLookaheadProduction= "MaybeSequencePattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$MaybeSequencePattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3731;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:563:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$563$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:563:5
            if (!scanToken(LBRACKET)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:563:9
            Token token3732= currentLookaheadToken;
            if (!check$Python_javacc$563$10()) {
                currentLookaheadToken= token3732;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:563:32
            if (!scanToken(RBRACKET)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:563:10
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$563$10() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:563:10
            // NonTerminal MaybeSequencePattern at Python.javacc:563:10
            pushOntoLookaheadStack("SequencePattern", "Python.javacc", 563, 10);
            boolean prevScanToEnd3733= scanToEnd;
            currentLookaheadProduction= "MaybeSequencePattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$MaybeSequencePattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3733;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:565:5
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$565$5() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:565:5
            if (!scanToken(LPAREN)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:565:9
            Token token3734= currentLookaheadToken;
            if (!check$Python_javacc$565$10()) {
                currentLookaheadToken= token3734;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:565:31
            if (!scanToken(RPAREN)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:565:10
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$565$10() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:565:10
            // NonTerminal OpenSequencePattern at Python.javacc:565:10
            pushOntoLookaheadStack("SequencePattern", "Python.javacc", 565, 10);
            boolean prevScanToEnd3735= scanToEnd;
            currentLookaheadProduction= "OpenSequencePattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$OpenSequencePattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3735;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:573:11
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$573$11$() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:573:11
            Token token3736= currentLookaheadToken;
            int remainingLookahead3736= remainingLookahead;
            boolean hitFailure3736= hitFailure;
            if (!check$Python_javacc$573$11()) {
                currentLookaheadToken= token3736;
                remainingLookahead= remainingLookahead3736;
                hitFailure= hitFailure3736;
                if (!check$Python_javacc$576$11()) {
                    currentLookaheadToken= token3736;
                    remainingLookahead= remainingLookahead3736;
                    hitFailure= hitFailure3736;
                    return false;
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:573:11
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$573$11() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (!check$Python_javacc$573$16()) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:574:11
            // NonTerminal KeywordPatterns at Python.javacc:574:11
            pushOntoLookaheadStack("ClassPattern", "Python.javacc", 574, 11);
            boolean prevScanToEnd3737= scanToEnd;
            currentLookaheadProduction= "KeywordPatterns";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$KeywordPatterns()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3737;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:574:27
            Token token3738= currentLookaheadToken;
            if (!scanToken(COMMA)) {
                currentLookaheadToken= token3738;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:576:11
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$576$11() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:576:11
            // NonTerminal PositionalPatterns at Python.javacc:576:11
            pushOntoLookaheadStack("ClassPattern", "Python.javacc", 576, 11);
            boolean prevScanToEnd3739= scanToEnd;
            currentLookaheadProduction= "PositionalPatterns";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$PositionalPatterns()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3739;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:576:30
            Token token3740= currentLookaheadToken;
            if (!check$Python_javacc$576$31()) {
                currentLookaheadToken= token3740;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:576:58
            Token token3741= currentLookaheadToken;
            if (!scanToken(COMMA)) {
                currentLookaheadToken= token3741;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:576:31
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$576$31() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:576:31
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:576:41
            // NonTerminal KeywordPatterns at Python.javacc:576:41
            pushOntoLookaheadStack("ClassPattern", "Python.javacc", 576, 41);
            boolean prevScanToEnd3742= scanToEnd;
            currentLookaheadProduction= "KeywordPatterns";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$KeywordPatterns()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3742;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:586:8
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$586$8() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (!(getToken(1).getType()== TokenType.COMMA&&!(getToken(2).getType()== TokenType.NAME&&getToken(3).getType()== TokenType.ASSIGN))) return false;
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:587:11
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:587:15
            // NonTerminal Pattern at Python.javacc:587:15
            pushOntoLookaheadStack("PositionalPatterns", "Python.javacc", 587, 15);
            boolean prevScanToEnd3743= scanToEnd;
            currentLookaheadProduction= "Pattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Pattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3743;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:593:35
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$593$35() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:593:35
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 2;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:593:45
            // NonTerminal KeywordPattern at Python.javacc:593:45
            pushOntoLookaheadStack("KeywordPatterns", "Python.javacc", 593, 45);
            boolean prevScanToEnd3744= scanToEnd;
            currentLookaheadProduction= "KeywordPattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$KeywordPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3744;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:595:28
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$595$28() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:595:28
            if (!scanToken(BIT_OR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:595:32
            // NonTerminal ClosedPattern at Python.javacc:595:32
            pushOntoLookaheadStack("OrPattern", "Python.javacc", 595, 32);
            boolean prevScanToEnd3745= scanToEnd;
            currentLookaheadProduction= "ClosedPattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$ClosedPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3745;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:597:22
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$597$22() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:597:22
            if (!scanToken(AS)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:597:27
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:600:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$600$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:600:4
            // NonTerminal StarNamedExpression at Python.javacc:600:4
            pushOntoLookaheadStack("SubjectExpression", "Python.javacc", 600, 4);
            boolean prevScanToEnd3746= scanToEnd;
            currentLookaheadProduction= "StarNamedExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarNamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3746;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:600:24
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:600:33
            Token token3747= currentLookaheadToken;
            if (!check$Python_javacc$600$34()) {
                currentLookaheadToken= token3747;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:600:34
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$600$34() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:600:34
            // NonTerminal StarNamedExpressions at Python.javacc:600:34
            pushOntoLookaheadStack("SubjectExpression", "Python.javacc", 600, 34);
            boolean prevScanToEnd3748= scanToEnd;
            currentLookaheadProduction= "StarNamedExpressions";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarNamedExpressions()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3748;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:602:4
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$602$4() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:602:4
            // NonTerminal NamedExpression at Python.javacc:602:4
            pushOntoLookaheadStack("SubjectExpression", "Python.javacc", 602, 4);
            boolean prevScanToEnd3749= scanToEnd;
            currentLookaheadProduction= "NamedExpression";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$NamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3749;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:605:21
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$605$21() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:605:21
            if (!scanToken(DOT)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:605:25
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // scanahead routine for expansion at: 
    // Python.javacc:607:42
    // BuildScanRoutine macro
    private final boolean check$Python_javacc$607$42() {
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:607:42
            if (!scanToken(DOT)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:607:46
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting--;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:55:6
    private final boolean scan$Python_javacc$55$6() {
        int nonTerminalNesting3750= nonTerminalNesting;
        int lookaheadRoutineNesting3752= lookaheadRoutineNesting;
        Token currentLookaheadToken3751= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (!check$Python_javacc$240$9()) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3752;
            currentLookaheadToken= currentLookaheadToken3751;
            nonTerminalNesting= nonTerminalNesting3750;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:55:14
    private final boolean scan$Python_javacc$55$14() {
        int nonTerminalNesting3753= nonTerminalNesting;
        int lookaheadRoutineNesting3755= lookaheadRoutineNesting;
        Token currentLookaheadToken3754= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:55:14
            // NonTerminal GenExp at Python.javacc:55:14
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 55, 14);
            boolean prevScanToEnd3756= scanToEnd;
            currentLookaheadProduction= "GenExp";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$GenExp()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3756;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3755;
            currentLookaheadToken= currentLookaheadToken3754;
            nonTerminalNesting= nonTerminalNesting3753;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:57:6
    private final boolean scan$Python_javacc$57$6() {
        int nonTerminalNesting3757= nonTerminalNesting;
        int lookaheadRoutineNesting3759= lookaheadRoutineNesting;
        Token currentLookaheadToken3758= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:57:6
            // NonTerminal ListComp at Python.javacc:57:6
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 57, 6);
            boolean prevScanToEnd3760= scanToEnd;
            currentLookaheadProduction= "ListComp";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ListComp()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3760;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3759;
            currentLookaheadToken= currentLookaheadToken3758;
            nonTerminalNesting= nonTerminalNesting3757;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:59:6
    private final boolean scan$Python_javacc$59$6() {
        int nonTerminalNesting3761= nonTerminalNesting;
        int lookaheadRoutineNesting3763= lookaheadRoutineNesting;
        Token currentLookaheadToken3762= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:59:6
            // NonTerminal SetComp at Python.javacc:59:6
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 59, 6);
            boolean prevScanToEnd3764= scanToEnd;
            currentLookaheadProduction= "SetComp";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$SetComp()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3764;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3763;
            currentLookaheadToken= currentLookaheadToken3762;
            nonTerminalNesting= nonTerminalNesting3761;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:59:16
    private final boolean scan$Python_javacc$59$16() {
        int nonTerminalNesting3765= nonTerminalNesting;
        int lookaheadRoutineNesting3767= lookaheadRoutineNesting;
        Token currentLookaheadToken3766= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:59:16
            // NonTerminal DictComp at Python.javacc:59:16
            pushOntoLookaheadStack("AtomicExpression", "Python.javacc", 59, 16);
            boolean prevScanToEnd3768= scanToEnd;
            currentLookaheadProduction= "DictComp";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$DictComp()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3768;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3767;
            currentLookaheadToken= currentLookaheadToken3766;
            nonTerminalNesting= nonTerminalNesting3765;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:59:27
    private final boolean scan$Python_javacc$59$27() {
        int nonTerminalNesting3769= nonTerminalNesting;
        int lookaheadRoutineNesting3771= lookaheadRoutineNesting;
        Token currentLookaheadToken3770= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (!check$Python_javacc$332$8()) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3771;
            currentLookaheadToken= currentLookaheadToken3770;
            nonTerminalNesting= nonTerminalNesting3769;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:65:5
    private final boolean scan$Python_javacc$65$5() {
        int nonTerminalNesting3772= nonTerminalNesting;
        int lookaheadRoutineNesting3774= lookaheadRoutineNesting;
        Token currentLookaheadToken3773= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:65:5
            Token token3775= currentLookaheadToken;
            if (!check$Python_javacc$65$6()) {
                currentLookaheadToken= token3775;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:65:18
            if (!scanToken(COLON)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:65:27
            Token token3776= currentLookaheadToken;
            if (!check$Python_javacc$65$28()) {
                currentLookaheadToken= token3776;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:65:40
            Token token3777= currentLookaheadToken;
            if (!check$Python_javacc$65$41()) {
                currentLookaheadToken= token3777;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3774;
            currentLookaheadToken= currentLookaheadToken3773;
            nonTerminalNesting= nonTerminalNesting3772;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:67:6
    private final boolean scan$Python_javacc$67$6() {
        int nonTerminalNesting3778= nonTerminalNesting;
        int lookaheadRoutineNesting3780= lookaheadRoutineNesting;
        Token currentLookaheadToken3779= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:67:9
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:67:16
            if (!scanToken(COLONEQUALS)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3780;
            currentLookaheadToken= currentLookaheadToken3779;
            nonTerminalNesting= nonTerminalNesting3778;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:70:21
    private final boolean scan$Python_javacc$70$21() {
        int nonTerminalNesting3781= nonTerminalNesting;
        int lookaheadRoutineNesting3783= lookaheadRoutineNesting;
        Token currentLookaheadToken3782= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:70:21
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:70:31
            // NonTerminal Slice at Python.javacc:70:31
            pushOntoLookaheadStack("Slices", "Python.javacc", 70, 31);
            boolean prevScanToEnd3784= scanToEnd;
            currentLookaheadProduction= "Slice";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Slice()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3784;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3783;
            currentLookaheadToken= currentLookaheadToken3782;
            nonTerminalNesting= nonTerminalNesting3781;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:73:4
    private final boolean scan$Python_javacc$73$4() {
        int nonTerminalNesting3785= nonTerminalNesting;
        int lookaheadRoutineNesting3787= lookaheadRoutineNesting;
        Token currentLookaheadToken3786= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:73:4
            // NonTerminal MatchStatement at Python.javacc:73:4
            pushOntoLookaheadStack("Statement", "Python.javacc", 73, 4);
            boolean prevScanToEnd3788= scanToEnd;
            currentLookaheadProduction= "MatchStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$MatchStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3788;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3787;
            currentLookaheadToken= currentLookaheadToken3786;
            nonTerminalNesting= nonTerminalNesting3785;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:80:40
    private final boolean scan$Python_javacc$80$40() {
        int nonTerminalNesting3789= nonTerminalNesting;
        int lookaheadRoutineNesting3791= lookaheadRoutineNesting;
        Token currentLookaheadToken3790= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:80:40
            if (!scanToken(SEMICOLON)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:80:50
            // NonTerminal SmallStatement at Python.javacc:80:50
            pushOntoLookaheadStack("SimpleStatement", "Python.javacc", 80, 50);
            boolean prevScanToEnd3792= scanToEnd;
            currentLookaheadProduction= "SmallStatement";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$SmallStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3792;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3791;
            currentLookaheadToken= currentLookaheadToken3790;
            nonTerminalNesting= nonTerminalNesting3789;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:83:4
    private final boolean scan$Python_javacc$83$4() {
        int nonTerminalNesting3793= nonTerminalNesting;
        int lookaheadRoutineNesting3795= lookaheadRoutineNesting;
        Token currentLookaheadToken3794= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (!check$Python_javacc$462$7()) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3795;
            currentLookaheadToken= currentLookaheadToken3794;
            nonTerminalNesting= nonTerminalNesting3793;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:111:5
    private final boolean scan$Python_javacc$111$5() {
        int nonTerminalNesting3796= nonTerminalNesting;
        int lookaheadRoutineNesting3798= lookaheadRoutineNesting;
        Token currentLookaheadToken3797= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:111:5
            // NonTerminal FunctionDefinition at Python.javacc:111:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 111, 5);
            boolean prevScanToEnd3799= scanToEnd;
            currentLookaheadProduction= "FunctionDefinition";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$FunctionDefinition()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3799;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3798;
            currentLookaheadToken= currentLookaheadToken3797;
            nonTerminalNesting= nonTerminalNesting3796;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:115:5
    private final boolean scan$Python_javacc$115$5() {
        int nonTerminalNesting3800= nonTerminalNesting;
        int lookaheadRoutineNesting3802= lookaheadRoutineNesting;
        Token currentLookaheadToken3801= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:115:5
            // NonTerminal ClassDefinition at Python.javacc:115:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 115, 5);
            boolean prevScanToEnd3803= scanToEnd;
            currentLookaheadProduction= "ClassDefinition";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ClassDefinition()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3803;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3802;
            currentLookaheadToken= currentLookaheadToken3801;
            nonTerminalNesting= nonTerminalNesting3800;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:117:5
    private final boolean scan$Python_javacc$117$5() {
        int nonTerminalNesting3804= nonTerminalNesting;
        int lookaheadRoutineNesting3806= lookaheadRoutineNesting;
        Token currentLookaheadToken3805= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:117:5
            // NonTerminal WithStatement at Python.javacc:117:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 117, 5);
            boolean prevScanToEnd3807= scanToEnd;
            currentLookaheadProduction= "WithStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$WithStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3807;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3806;
            currentLookaheadToken= currentLookaheadToken3805;
            nonTerminalNesting= nonTerminalNesting3804;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:121:5
    private final boolean scan$Python_javacc$121$5() {
        int nonTerminalNesting3808= nonTerminalNesting;
        int lookaheadRoutineNesting3810= lookaheadRoutineNesting;
        Token currentLookaheadToken3809= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:121:5
            // NonTerminal ForStatement at Python.javacc:121:5
            pushOntoLookaheadStack("CompoundStatement", "Python.javacc", 121, 5);
            boolean prevScanToEnd3811= scanToEnd;
            currentLookaheadProduction= "ForStatement";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ForStatement()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3811;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3810;
            currentLookaheadToken= currentLookaheadToken3809;
            nonTerminalNesting= nonTerminalNesting3808;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:159:9
    private final boolean scan$Python_javacc$159$9() {
        int nonTerminalNesting3818= nonTerminalNesting;
        int lookaheadRoutineNesting3820= lookaheadRoutineNesting;
        Token currentLookaheadToken3819= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (!check$Python_javacc$159$14()) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3820;
            currentLookaheadToken= currentLookaheadToken3819;
            nonTerminalNesting= nonTerminalNesting3818;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:166:45
    private final boolean scan$Python_javacc$166$45() {
        int nonTerminalNesting3821= nonTerminalNesting;
        int lookaheadRoutineNesting3823= lookaheadRoutineNesting;
        Token currentLookaheadToken3822= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 2;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:166:52
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:166:56
            // NonTerminal WithItem at Python.javacc:166:56
            pushOntoLookaheadStack("WithItemsInParentheses", "Python.javacc", 166, 56);
            boolean prevScanToEnd3824= scanToEnd;
            currentLookaheadProduction= "WithItem";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$WithItem()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3824;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3823;
            currentLookaheadToken= currentLookaheadToken3822;
            nonTerminalNesting= nonTerminalNesting3821;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:185:41
    private final boolean scan$Python_javacc$185$41() {
        int nonTerminalNesting3833= nonTerminalNesting;
        int lookaheadRoutineNesting3835= lookaheadRoutineNesting;
        Token currentLookaheadToken3834= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 2;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:185:48
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:185:52
            // NonTerminal PrimaryExpression at Python.javacc:185:52
            pushOntoLookaheadStack("DelStatement", "Python.javacc", 185, 52);
            boolean prevScanToEnd3836= scanToEnd;
            currentLookaheadProduction= "PrimaryExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$PrimaryExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3836;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3835;
            currentLookaheadToken= currentLookaheadToken3834;
            nonTerminalNesting= nonTerminalNesting3833;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:187:21
    private final boolean scan$Python_javacc$187$21() {
        int nonTerminalNesting3837= nonTerminalNesting;
        int lookaheadRoutineNesting3839= lookaheadRoutineNesting;
        Token currentLookaheadToken3838= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:187:24
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:187:31
            if (!scanToken(COLONEQUALS)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3839;
            currentLookaheadToken= currentLookaheadToken3838;
            nonTerminalNesting= nonTerminalNesting3837;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:189:22
    private final boolean scan$Python_javacc$189$22() {
        int nonTerminalNesting3840= nonTerminalNesting;
        int lookaheadRoutineNesting3842= lookaheadRoutineNesting;
        Token currentLookaheadToken3841= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:189:25
            if (!scanToken(DOT)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:189:29
            if (!scanToken(NAME)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3842;
            currentLookaheadToken= currentLookaheadToken3841;
            nonTerminalNesting= nonTerminalNesting3840;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:191:32
    private final boolean scan$Python_javacc$191$32() {
        int nonTerminalNesting3843= nonTerminalNesting;
        int lookaheadRoutineNesting3845= lookaheadRoutineNesting;
        Token currentLookaheadToken3844= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:191:32
            // NonTerminal ImportFrom1 at Python.javacc:191:32
            pushOntoLookaheadStack("ImportStatement", "Python.javacc", 191, 32);
            boolean prevScanToEnd3846= scanToEnd;
            currentLookaheadProduction= "ImportFrom1";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ImportFrom1()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3846;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3845;
            currentLookaheadToken= currentLookaheadToken3844;
            nonTerminalNesting= nonTerminalNesting3843;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:191:46
    private final boolean scan$Python_javacc$191$46() {
        int nonTerminalNesting3847= nonTerminalNesting;
        int lookaheadRoutineNesting3849= lookaheadRoutineNesting;
        Token currentLookaheadToken3848= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:191:46
            // NonTerminal ImportFrom2 at Python.javacc:191:46
            pushOntoLookaheadStack("ImportStatement", "Python.javacc", 191, 46);
            boolean prevScanToEnd3850= scanToEnd;
            currentLookaheadProduction= "ImportFrom2";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ImportFrom2()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3850;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3849;
            currentLookaheadToken= currentLookaheadToken3848;
            nonTerminalNesting= nonTerminalNesting3847;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:202:26
    private final boolean scan$Python_javacc$202$26() {
        int nonTerminalNesting3862= nonTerminalNesting;
        int lookaheadRoutineNesting3864= lookaheadRoutineNesting;
        Token currentLookaheadToken3863= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:202:26
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:202:30
            if (!scanToken(NAME)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:202:42
            Token token3865= currentLookaheadToken;
            if (!check$Python_javacc$202$43()) {
                currentLookaheadToken= token3865;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3864;
            currentLookaheadToken= currentLookaheadToken3863;
            nonTerminalNesting= nonTerminalNesting3862;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:204:30
    private final boolean scan$Python_javacc$204$30() {
        int nonTerminalNesting3866= nonTerminalNesting;
        int lookaheadRoutineNesting3868= lookaheadRoutineNesting;
        Token currentLookaheadToken3867= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:204:30
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:204:34
            if (!scanToken(NAME)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:204:46
            Token token3869= currentLookaheadToken;
            if (!check$Python_javacc$204$47()) {
                currentLookaheadToken= token3869;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3868;
            currentLookaheadToken= currentLookaheadToken3867;
            nonTerminalNesting= nonTerminalNesting3866;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:219:35
    private final boolean scan$Python_javacc$219$35() {
        int nonTerminalNesting3870= nonTerminalNesting;
        int lookaheadRoutineNesting3872= lookaheadRoutineNesting;
        Token currentLookaheadToken3871= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:219:35
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:219:45
            // NonTerminal StarExpression at Python.javacc:219:45
            pushOntoLookaheadStack("StarExpressions", "Python.javacc", 219, 45);
            boolean prevScanToEnd3873= scanToEnd;
            currentLookaheadProduction= "StarExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3873;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3872;
            currentLookaheadToken= currentLookaheadToken3871;
            nonTerminalNesting= nonTerminalNesting3870;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:221:45
    private final boolean scan$Python_javacc$221$45() {
        int nonTerminalNesting3874= nonTerminalNesting;
        int lookaheadRoutineNesting3876= lookaheadRoutineNesting;
        Token currentLookaheadToken3875= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:221:45
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:221:55
            // NonTerminal StarNamedExpression at Python.javacc:221:55
            pushOntoLookaheadStack("StarNamedExpressions", "Python.javacc", 221, 55);
            boolean prevScanToEnd3877= scanToEnd;
            currentLookaheadProduction= "StarNamedExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarNamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3877;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3876;
            currentLookaheadToken= currentLookaheadToken3875;
            nonTerminalNesting= nonTerminalNesting3874;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:255:8
    private final boolean scan$Python_javacc$255$8() {
        int nonTerminalNesting3881= nonTerminalNesting;
        int lookaheadRoutineNesting3883= lookaheadRoutineNesting;
        Token currentLookaheadToken3882= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:255:8
            // NonTerminal GenExp at Python.javacc:255:8
            pushOntoLookaheadStack("PrimaryExpression", "Python.javacc", 255, 8);
            boolean prevScanToEnd3884= scanToEnd;
            currentLookaheadProduction= "GenExp";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$GenExp()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3884;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3883;
            currentLookaheadToken= currentLookaheadToken3882;
            nonTerminalNesting= nonTerminalNesting3881;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:262:5
    private final boolean scan$Python_javacc$262$5() {
        int nonTerminalNesting3885= nonTerminalNesting;
        int lookaheadRoutineNesting3887= lookaheadRoutineNesting;
        Token currentLookaheadToken3886= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:262:5
            if (!scanToken(YIELD)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:262:13
            if (!scanToken(FROM)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:262:25
            // NonTerminal Expression at Python.javacc:262:25
            pushOntoLookaheadStack("YieldExpression", "Python.javacc", 262, 25);
            boolean prevScanToEnd3888= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3888;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3887;
            currentLookaheadToken= currentLookaheadToken3886;
            nonTerminalNesting= nonTerminalNesting3885;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:289:10
    private final boolean scan$Python_javacc$289$10() {
        int nonTerminalNesting3889= nonTerminalNesting;
        int lookaheadRoutineNesting3891= lookaheadRoutineNesting;
        Token currentLookaheadToken3890= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 3;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:290:10
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:291:10
            // NonTerminal Argument at Python.javacc:291:10
            pushOntoLookaheadStack("InvocationArguments", "Python.javacc", 291, 10);
            boolean prevScanToEnd3892= scanToEnd;
            currentLookaheadProduction= "Argument";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Argument()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3892;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for CodeBlock specified at Python.javacc:292:10
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3891;
            currentLookaheadToken= currentLookaheadToken3890;
            nonTerminalNesting= nonTerminalNesting3889;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:303:4
    private final boolean scan$Python_javacc$303$4() {
        int nonTerminalNesting3893= nonTerminalNesting;
        int lookaheadRoutineNesting3895= lookaheadRoutineNesting;
        Token currentLookaheadToken3894= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:303:4
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:305:7
            Token token3896= currentLookaheadToken;
            int remainingLookahead3896= remainingLookahead;
            boolean hitFailure3896= hitFailure;
            if (!check$Python_javacc$305$7()) {
                currentLookaheadToken= token3896;
                remainingLookahead= remainingLookahead3896;
                hitFailure= hitFailure3896;
                if (!scanToken(ASSIGN)) {
                    currentLookaheadToken= token3896;
                    remainingLookahead= remainingLookahead3896;
                    hitFailure= hitFailure3896;
                    return false;
                }
            }
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:311:4
            // NonTerminal Expression at Python.javacc:311:4
            pushOntoLookaheadStack("Argument", "Python.javacc", 311, 4);
            boolean prevScanToEnd3897= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3897;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3895;
            currentLookaheadToken= currentLookaheadToken3894;
            nonTerminalNesting= nonTerminalNesting3893;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:305:7
    private final boolean scan$Python_javacc$305$7() {
        int nonTerminalNesting3898= nonTerminalNesting;
        int lookaheadRoutineNesting3900= lookaheadRoutineNesting;
        Token currentLookaheadToken3899= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 1;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:306:7
            if (!scanToken(COLONEQUALS)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3900;
            currentLookaheadToken= currentLookaheadToken3899;
            nonTerminalNesting= nonTerminalNesting3898;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:314:7
    private final boolean scan$Python_javacc$314$7() {
        int nonTerminalNesting3901= nonTerminalNesting;
        int lookaheadRoutineNesting3903= lookaheadRoutineNesting;
        Token currentLookaheadToken3902= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 1;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:314:35
            if (!scanToken(STAR)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3903;
            currentLookaheadToken= currentLookaheadToken3902;
            nonTerminalNesting= nonTerminalNesting3901;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:329:57
    private final boolean scan$Python_javacc$329$57() {
        int nonTerminalNesting3904= nonTerminalNesting;
        int lookaheadRoutineNesting3906= lookaheadRoutineNesting;
        Token currentLookaheadToken3905= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:329:57
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:329:67
            // NonTerminal DoubleStarredKeyValuePair at Python.javacc:329:67
            pushOntoLookaheadStack("DoubleStarredKeyValuePairs", "Python.javacc", 329, 67);
            boolean prevScanToEnd3907= scanToEnd;
            currentLookaheadProduction= "DoubleStarredKeyValuePair";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$DoubleStarredKeyValuePair()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3907;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3906;
            currentLookaheadToken= currentLookaheadToken3905;
            nonTerminalNesting= nonTerminalNesting3904;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:391:27
    private final boolean scan$Python_javacc$391$27() {
        int nonTerminalNesting3935= nonTerminalNesting;
        int lookaheadRoutineNesting3937= lookaheadRoutineNesting;
        Token currentLookaheadToken3936= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:391:27
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:391:37
            // NonTerminal StarTarget at Python.javacc:391:37
            pushOntoLookaheadStack("StarTargets", "Python.javacc", 391, 37);
            boolean prevScanToEnd3938= scanToEnd;
            currentLookaheadProduction= "StarTarget";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarTarget()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3938;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3937;
            currentLookaheadToken= currentLookaheadToken3936;
            nonTerminalNesting= nonTerminalNesting3935;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:404:4
    private final boolean scan$Python_javacc$404$4() {
        int nonTerminalNesting3949= nonTerminalNesting;
        int lookaheadRoutineNesting3951= lookaheadRoutineNesting;
        Token currentLookaheadToken3950= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:404:4
            if (!scanToken(STAR)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:404:8
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:404:17
            // NonTerminal ParamMaybeDefault at Python.javacc:404:17
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 404, 17);
            boolean prevScanToEnd3952= scanToEnd;
            currentLookaheadProduction= "ParamMaybeDefault";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$ParamMaybeDefault()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3952;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrMore specified at Python.javacc:404:35
            while (remainingLookahead> 0&&!hitFailure) {
                Token token3953= currentLookaheadToken;
                if (!check$Python_javacc$404$36()) {
                    currentLookaheadToken= token3953;
                    break;
                }
            }
            hitFailure= false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:404:66
            Token token3954= currentLookaheadToken;
            if (!check$Python_javacc$404$67()) {
                currentLookaheadToken= token3954;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3951;
            currentLookaheadToken= currentLookaheadToken3950;
            nonTerminalNesting= nonTerminalNesting3949;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:404:36
    private final boolean scan$Python_javacc$404$36() {
        int nonTerminalNesting3955= nonTerminalNesting;
        int lookaheadRoutineNesting3957= lookaheadRoutineNesting;
        Token currentLookaheadToken3956= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:404:36
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:404:46
            // NonTerminal ParamMaybeDefault at Python.javacc:404:46
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 404, 46);
            boolean prevScanToEnd3958= scanToEnd;
            currentLookaheadProduction= "ParamMaybeDefault";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$ParamMaybeDefault()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3958;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3957;
            currentLookaheadToken= currentLookaheadToken3956;
            nonTerminalNesting= nonTerminalNesting3955;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:406:16
    private final boolean scan$Python_javacc$406$16() {
        int nonTerminalNesting3959= nonTerminalNesting;
        int lookaheadRoutineNesting3961= lookaheadRoutineNesting;
        Token currentLookaheadToken3960= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 1;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (!backscan$Python_javacc$406$23()) return false;
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:406:48
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:406:52
            // NonTerminal Expression at Python.javacc:406:52
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 406, 52);
            boolean prevScanToEnd3962= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3962;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3961;
            currentLookaheadToken= currentLookaheadToken3960;
            nonTerminalNesting= nonTerminalNesting3959;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:406:65
    private final boolean scan$Python_javacc$406$65() {
        int nonTerminalNesting3963= nonTerminalNesting;
        int lookaheadRoutineNesting3965= lookaheadRoutineNesting;
        Token currentLookaheadToken3964= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:406:65
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:406:75
            // NonTerminal ParamMaybeDefault at Python.javacc:406:75
            pushOntoLookaheadStack("StarEtc", "Python.javacc", 406, 75);
            boolean prevScanToEnd3966= scanToEnd;
            currentLookaheadProduction= "ParamMaybeDefault";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$ParamMaybeDefault()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3966;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3965;
            currentLookaheadToken= currentLookaheadToken3964;
            nonTerminalNesting= nonTerminalNesting3963;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:414:8
    private final boolean scan$Python_javacc$414$8() {
        int nonTerminalNesting3967= nonTerminalNesting;
        int lookaheadRoutineNesting3969= lookaheadRoutineNesting;
        Token currentLookaheadToken3968= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 1;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (backscan$Python_javacc$414$15()) return false;
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:415:8
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:415:12
            // NonTerminal Expression at Python.javacc:415:12
            pushOntoLookaheadStack("KeyWords", "Python.javacc", 415, 12);
            boolean prevScanToEnd3970= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3970;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3969;
            currentLookaheadToken= currentLookaheadToken3968;
            nonTerminalNesting= nonTerminalNesting3967;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:425:8
    private final boolean scan$Python_javacc$425$8() {
        int nonTerminalNesting3971= nonTerminalNesting;
        int lookaheadRoutineNesting3973= lookaheadRoutineNesting;
        Token currentLookaheadToken3972= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 1;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (!backscan$Python_javacc$425$15()) return false;
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:425:38
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:425:42
            // NonTerminal Expression at Python.javacc:425:42
            pushOntoLookaheadStack("Parameters", "Python.javacc", 425, 42);
            boolean prevScanToEnd3974= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3974;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3973;
            currentLookaheadToken= currentLookaheadToken3972;
            nonTerminalNesting= nonTerminalNesting3971;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:427:8
    private final boolean scan$Python_javacc$427$8() {
        int nonTerminalNesting3975= nonTerminalNesting;
        int lookaheadRoutineNesting3977= lookaheadRoutineNesting;
        Token currentLookaheadToken3976= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:427:8
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:430:11
            Token token3978= currentLookaheadToken;
            int remainingLookahead3978= remainingLookahead;
            boolean hitFailure3978= hitFailure;
            if (!check$Python_javacc$430$11()) {
                currentLookaheadToken= token3978;
                remainingLookahead= remainingLookahead3978;
                hitFailure= hitFailure3978;
                if (!check$Python_javacc$433$11()) {
                    currentLookaheadToken= token3978;
                    remainingLookahead= remainingLookahead3978;
                    hitFailure= hitFailure3978;
                    return false;
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3977;
            currentLookaheadToken= currentLookaheadToken3976;
            nonTerminalNesting= nonTerminalNesting3975;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:430:11
    private final boolean scan$Python_javacc$430$11() {
        int nonTerminalNesting3979= nonTerminalNesting;
        int lookaheadRoutineNesting3981= lookaheadRoutineNesting;
        Token currentLookaheadToken3980= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 1;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:431:11
            if (!scanToken(SLASH)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for CodeBlock specified at Python.javacc:431:15
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3981;
            currentLookaheadToken= currentLookaheadToken3980;
            nonTerminalNesting= nonTerminalNesting3979;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:433:19
    private final boolean scan$Python_javacc$433$19() {
        int nonTerminalNesting3982= nonTerminalNesting;
        int lookaheadRoutineNesting3984= lookaheadRoutineNesting;
        Token currentLookaheadToken3983= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 1;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (!backscan$Python_javacc$433$26()) return false;
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:433:49
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:433:53
            // NonTerminal Expression at Python.javacc:433:53
            pushOntoLookaheadStack("Parameters", "Python.javacc", 433, 53);
            boolean prevScanToEnd3985= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3985;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3984;
            currentLookaheadToken= currentLookaheadToken3983;
            nonTerminalNesting= nonTerminalNesting3982;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:437:14
    private final boolean scan$Python_javacc$437$14() {
        int nonTerminalNesting3986= nonTerminalNesting;
        int lookaheadRoutineNesting3988= lookaheadRoutineNesting;
        Token currentLookaheadToken3987= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 0;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:438:17
            if (!scanToken(ASSIGN)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:438:21
            // NonTerminal Expression at Python.javacc:438:21
            pushOntoLookaheadStack("Parameters", "Python.javacc", 438, 21);
            boolean prevScanToEnd3989= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3989;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for CodeBlock specified at Python.javacc:438:32
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3988;
            currentLookaheadToken= currentLookaheadToken3987;
            nonTerminalNesting= nonTerminalNesting3986;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:445:7
    private final boolean scan$Python_javacc$445$7() {
        int nonTerminalNesting3990= nonTerminalNesting;
        int lookaheadRoutineNesting3992= lookaheadRoutineNesting;
        Token currentLookaheadToken3991= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (check$Python_javacc$445$13()) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3992;
            currentLookaheadToken= currentLookaheadToken3991;
            nonTerminalNesting= nonTerminalNesting3990;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:464:3
    private final boolean scan$Python_javacc$464$3() {
        int nonTerminalNesting3996= nonTerminalNesting;
        int lookaheadRoutineNesting3998= lookaheadRoutineNesting;
        Token currentLookaheadToken3997= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:464:3
            // NonTerminal SimpleAssignTarget at Python.javacc:464:3
            pushOntoLookaheadStack("Assignment", "Python.javacc", 464, 3);
            boolean prevScanToEnd3999= scanToEnd;
            currentLookaheadProduction= "SimpleAssignTarget";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$SimpleAssignTarget()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd3999;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:464:22
            if (!scanToken(COLON)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:464:31
            // NonTerminal Expression at Python.javacc:464:31
            pushOntoLookaheadStack("Assignment", "Python.javacc", 464, 31);
            boolean prevScanToEnd4000= scanToEnd;
            currentLookaheadProduction= "Expression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Expression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4000;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:464:42
            Token token4001= currentLookaheadToken;
            if (!check$Python_javacc$464$43()) {
                currentLookaheadToken= token4001;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting3998;
            currentLookaheadToken= currentLookaheadToken3997;
            nonTerminalNesting= nonTerminalNesting3996;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:466:3
    private final boolean scan$Python_javacc$466$3() {
        int nonTerminalNesting4002= nonTerminalNesting;
        int lookaheadRoutineNesting4004= lookaheadRoutineNesting;
        Token currentLookaheadToken4003= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:466:3
            // NonTerminal SimpleAssignTarget at Python.javacc:466:3
            pushOntoLookaheadStack("Assignment", "Python.javacc", 466, 3);
            boolean prevScanToEnd4005= scanToEnd;
            currentLookaheadProduction= "SimpleAssignTarget";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$SimpleAssignTarget()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4005;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:466:22
            // Applying single-token optimization for expansion of type NonTerminal
            // Python.javacc:466:22
            if (!scanToken(first_set$Python_javacc$466$22)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:466:38
            Token token4006= currentLookaheadToken;
            int remainingLookahead4006= remainingLookahead;
            boolean hitFailure4006= hitFailure;
            if (!check$Python_javacc$466$38()) {
                currentLookaheadToken= token4006;
                remainingLookahead= remainingLookahead4006;
                hitFailure= hitFailure4006;
                if (!check$Python_javacc$466$56()) {
                    currentLookaheadToken= token4006;
                    remainingLookahead= remainingLookahead4006;
                    hitFailure= hitFailure4006;
                    return false;
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4004;
            currentLookaheadToken= currentLookaheadToken4003;
            nonTerminalNesting= nonTerminalNesting4002;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:468:3
    private final boolean scan$Python_javacc$468$3() {
        int nonTerminalNesting4007= nonTerminalNesting;
        int lookaheadRoutineNesting4009= lookaheadRoutineNesting;
        Token currentLookaheadToken4008= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for OneOrMore specified at Python.javacc:468:3
            if (!check$Python_javacc$468$4()) {
                return false;
            }
            while (remainingLookahead> 0&&!hitFailure) {
                Token token4010= currentLookaheadToken;
                if (!check$Python_javacc$468$4()) {
                    currentLookaheadToken= token4010;
                    break;
                }
            }
            hitFailure= false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:468:30
            Token token4011= currentLookaheadToken;
            int remainingLookahead4011= remainingLookahead;
            boolean hitFailure4011= hitFailure;
            if (!check$Python_javacc$468$30()) {
                currentLookaheadToken= token4011;
                remainingLookahead= remainingLookahead4011;
                hitFailure= hitFailure4011;
                if (!check$Python_javacc$468$48()) {
                    currentLookaheadToken= token4011;
                    remainingLookahead= remainingLookahead4011;
                    hitFailure= hitFailure4011;
                    return false;
                }
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4009;
            currentLookaheadToken= currentLookaheadToken4008;
            nonTerminalNesting= nonTerminalNesting4007;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:468:4
    private final boolean scan$Python_javacc$468$4() {
        int nonTerminalNesting4012= nonTerminalNesting;
        int lookaheadRoutineNesting4014= lookaheadRoutineNesting;
        Token currentLookaheadToken4013= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:468:6
            // NonTerminal StarTargets at Python.javacc:468:6
            pushOntoLookaheadStack("Assignment", "Python.javacc", 468, 6);
            boolean prevScanToEnd4015= scanToEnd;
            currentLookaheadProduction= "StarTargets";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$StarTargets()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4015;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:468:18
            if (!scanToken(ASSIGN)) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4014;
            currentLookaheadToken= currentLookaheadToken4013;
            nonTerminalNesting= nonTerminalNesting4012;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:499:4
    private final boolean scan$Python_javacc$499$4() {
        int nonTerminalNesting4025= nonTerminalNesting;
        int lookaheadRoutineNesting4027= lookaheadRoutineNesting;
        Token currentLookaheadToken4026= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:499:4
            // NonTerminal OpenSequencePattern at Python.javacc:499:4
            pushOntoLookaheadStack("Patterns", "Python.javacc", 499, 4);
            boolean prevScanToEnd4028= scanToEnd;
            currentLookaheadProduction= "OpenSequencePattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$OpenSequencePattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4028;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4027;
            currentLookaheadToken= currentLookaheadToken4026;
            nonTerminalNesting= nonTerminalNesting4025;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:511:4
    private final boolean scan$Python_javacc$511$4() {
        int nonTerminalNesting4029= nonTerminalNesting;
        int lookaheadRoutineNesting4031= lookaheadRoutineNesting;
        Token currentLookaheadToken4030= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:511:4
            // NonTerminal ClassPattern at Python.javacc:511:4
            pushOntoLookaheadStack("ClosedPattern", "Python.javacc", 511, 4);
            boolean prevScanToEnd4032= scanToEnd;
            currentLookaheadProduction= "ClassPattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$ClassPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4032;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4031;
            currentLookaheadToken= currentLookaheadToken4030;
            nonTerminalNesting= nonTerminalNesting4029;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:517:4
    private final boolean scan$Python_javacc$517$4() {
        int nonTerminalNesting4033= nonTerminalNesting;
        int lookaheadRoutineNesting4035= lookaheadRoutineNesting;
        Token currentLookaheadToken4034= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:517:6
            // NonTerminal GroupPattern at Python.javacc:517:6
            pushOntoLookaheadStack("ClosedPattern", "Python.javacc", 517, 6);
            boolean prevScanToEnd4036= scanToEnd;
            currentLookaheadProduction= "GroupPattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$GroupPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4036;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4035;
            currentLookaheadToken= currentLookaheadToken4034;
            nonTerminalNesting= nonTerminalNesting4033;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:528:33
    private final boolean scan$Python_javacc$528$33() {
        int nonTerminalNesting4037= nonTerminalNesting;
        int lookaheadRoutineNesting4039= lookaheadRoutineNesting;
        Token currentLookaheadToken4038= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:528:33
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:528:43
            // NonTerminal KeyValuePattern at Python.javacc:528:43
            pushOntoLookaheadStack("ItemsPattern", "Python.javacc", 528, 43);
            boolean prevScanToEnd4040= scanToEnd;
            currentLookaheadProduction= "KeyValuePattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$KeyValuePattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4040;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4039;
            currentLookaheadToken= currentLookaheadToken4038;
            nonTerminalNesting= nonTerminalNesting4037;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:533:24
    private final boolean scan$Python_javacc$533$24() {
        int nonTerminalNesting4041= nonTerminalNesting;
        int lookaheadRoutineNesting4043= lookaheadRoutineNesting;
        Token currentLookaheadToken4042= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:533:24
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:533:34
            // NonTerminal DoubleStarPattern at Python.javacc:533:34
            pushOntoLookaheadStack("MappingPattern", "Python.javacc", 533, 34);
            boolean prevScanToEnd4044= scanToEnd;
            currentLookaheadProduction= "DoubleStarPattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$DoubleStarPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4044;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4043;
            currentLookaheadToken= currentLookaheadToken4042;
            nonTerminalNesting= nonTerminalNesting4041;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:555:22
    private final boolean scan$Python_javacc$555$22() {
        int nonTerminalNesting4045= nonTerminalNesting;
        int lookaheadRoutineNesting4047= lookaheadRoutineNesting;
        Token currentLookaheadToken4046= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:555:22
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:555:32
            // NonTerminal MaybeStarPattern at Python.javacc:555:32
            pushOntoLookaheadStack("MaybeSequencePattern", "Python.javacc", 555, 32);
            boolean prevScanToEnd4048= scanToEnd;
            currentLookaheadProduction= "MaybeStarPattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$MaybeStarPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4048;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4047;
            currentLookaheadToken= currentLookaheadToken4046;
            nonTerminalNesting= nonTerminalNesting4045;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:565:10
    private final boolean scan$Python_javacc$565$10() {
        int nonTerminalNesting4054= nonTerminalNesting;
        int lookaheadRoutineNesting4056= lookaheadRoutineNesting;
        Token currentLookaheadToken4055= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:565:10
            // NonTerminal OpenSequencePattern at Python.javacc:565:10
            pushOntoLookaheadStack("SequencePattern", "Python.javacc", 565, 10);
            boolean prevScanToEnd4057= scanToEnd;
            currentLookaheadProduction= "OpenSequencePattern";
            scanToEnd= false;
            ++nonTerminalNesting;
            try {
                if (!check$OpenSequencePattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4057;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4056;
            currentLookaheadToken= currentLookaheadToken4055;
            nonTerminalNesting= nonTerminalNesting4054;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:573:11
    private final boolean scan$Python_javacc$573$11() {
        int nonTerminalNesting4063= nonTerminalNesting;
        int lookaheadRoutineNesting4065= lookaheadRoutineNesting;
        Token currentLookaheadToken4064= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (!check$Python_javacc$573$16()) return false;
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4065;
            currentLookaheadToken= currentLookaheadToken4064;
            nonTerminalNesting= nonTerminalNesting4063;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:576:31
    private final boolean scan$Python_javacc$576$31() {
        int nonTerminalNesting4066= nonTerminalNesting;
        int lookaheadRoutineNesting4068= lookaheadRoutineNesting;
        Token currentLookaheadToken4067= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:576:31
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 1;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:576:41
            // NonTerminal KeywordPatterns at Python.javacc:576:41
            pushOntoLookaheadStack("ClassPattern", "Python.javacc", 576, 41);
            boolean prevScanToEnd4069= scanToEnd;
            currentLookaheadProduction= "KeywordPatterns";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$KeywordPatterns()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4069;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4068;
            currentLookaheadToken= currentLookaheadToken4067;
            nonTerminalNesting= nonTerminalNesting4066;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:586:8
    private final boolean scan$Python_javacc$586$8() {
        int nonTerminalNesting4070= nonTerminalNesting;
        int lookaheadRoutineNesting4072= lookaheadRoutineNesting;
        Token currentLookaheadToken4071= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= 0;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (!(getToken(1).getType()== TokenType.COMMA&&!(getToken(2).getType()== TokenType.NAME&&getToken(3).getType()== TokenType.ASSIGN))) return false;
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:587:11
            if (!scanToken(COMMA)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:587:15
            // NonTerminal Pattern at Python.javacc:587:15
            pushOntoLookaheadStack("PositionalPatterns", "Python.javacc", 587, 15);
            boolean prevScanToEnd4073= scanToEnd;
            currentLookaheadProduction= "Pattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Pattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4073;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4072;
            currentLookaheadToken= currentLookaheadToken4071;
            nonTerminalNesting= nonTerminalNesting4070;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:593:35
    private final boolean scan$Python_javacc$593$35() {
        int nonTerminalNesting4074= nonTerminalNesting;
        int lookaheadRoutineNesting4076= lookaheadRoutineNesting;
        Token currentLookaheadToken4075= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:593:35
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 2;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:593:45
            // NonTerminal KeywordPattern at Python.javacc:593:45
            pushOntoLookaheadStack("KeywordPatterns", "Python.javacc", 593, 45);
            boolean prevScanToEnd4077= scanToEnd;
            currentLookaheadProduction= "KeywordPattern";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$KeywordPattern()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4077;
                --nonTerminalNesting;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4076;
            currentLookaheadToken= currentLookaheadToken4075;
            nonTerminalNesting= nonTerminalNesting4074;
        }
    }

    // BuildPredicateRoutine: expansion at Python.javacc:600:4
    private final boolean scan$Python_javacc$600$4() {
        int nonTerminalNesting4078= nonTerminalNesting;
        int lookaheadRoutineNesting4080= lookaheadRoutineNesting;
        Token currentLookaheadToken4079= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            remainingLookahead= UNLIMITED;
            if (currentLookaheadToken== null) currentLookaheadToken= lastConsumedToken;
            hitFailure= false;
            scanToEnd= false;
            // BuildPredicateCode macro
            if (remainingLookahead<=0) return true;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:600:4
            // NonTerminal StarNamedExpression at Python.javacc:600:4
            pushOntoLookaheadStack("SubjectExpression", "Python.javacc", 600, 4);
            boolean prevScanToEnd4081= scanToEnd;
            currentLookaheadProduction= "StarNamedExpression";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$StarNamedExpression()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4081;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:600:24
            if (!scanToken(COMMA)) return false;
            if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
                remainingLookahead= 0;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:600:33
            Token token4082= currentLookaheadToken;
            if (!check$Python_javacc$600$34()) {
                currentLookaheadToken= token4082;
                hitFailure= false;
            }
            return true;
        }
        finally {
            lookaheadRoutineNesting= lookaheadRoutineNesting4080;
            currentLookaheadToken= currentLookaheadToken4079;
            nonTerminalNesting= nonTerminalNesting4078;
        }
    }

    // lookahead routine for lookahead at: 
    // Python.javacc:159:9
    private final boolean check$Python_javacc$159$14() {
        int prevRemainingLookahead= remainingLookahead;
        boolean prevHitFailure= hitFailure;
        Token prevScanAheadToken= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:159:14
            // NonTerminal WithItemsInParentheses at Python.javacc:159:14
            pushOntoLookaheadStack("WithStatement", "Python.javacc", 159, 14);
            boolean prevScanToEnd4083= scanToEnd;
            currentLookaheadProduction= "WithItemsInParentheses";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$WithItemsInParentheses()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4083;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:159:37
            if (!scanToken(COLON)) return false;
            return!hitFailure;
        }
        finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken= prevScanAheadToken;
            remainingLookahead= prevRemainingLookahead;
            hitFailure= prevHitFailure;
        }
    }

    // lookahead routine for lookahead at: 
    // Python.javacc:240:4
    private final boolean check$Python_javacc$240$9() {
        int prevRemainingLookahead= remainingLookahead;
        boolean prevHitFailure= hitFailure;
        Token prevScanAheadToken= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:240:9
            if (!scanToken(LPAREN)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:240:14
            Token token4084= currentLookaheadToken;
            int remainingLookahead4084= remainingLookahead;
            boolean hitFailure4084= hitFailure;
            if (!scanToken(RPAREN)) {
                currentLookaheadToken= token4084;
                remainingLookahead= remainingLookahead4084;
                hitFailure= hitFailure4084;
                if (!check$Python_javacc$240$20()) {
                    currentLookaheadToken= token4084;
                    remainingLookahead= remainingLookahead4084;
                    hitFailure= hitFailure4084;
                    return false;
                }
            }
            return!hitFailure;
        }
        finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken= prevScanAheadToken;
            remainingLookahead= prevRemainingLookahead;
            hitFailure= prevHitFailure;
        }
    }

    // lookahead routine for lookahead at: 
    // Python.javacc:332:3
    private final boolean check$Python_javacc$332$8() {
        int prevRemainingLookahead= remainingLookahead;
        boolean prevHitFailure= hitFailure;
        Token prevScanAheadToken= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:332:8
            if (!scanToken(LBRACE)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:332:13
            Token token4085= currentLookaheadToken;
            int remainingLookahead4085= remainingLookahead;
            boolean hitFailure4085= hitFailure;
            if (!scanToken(RBRACE)) {
                currentLookaheadToken= token4085;
                remainingLookahead= remainingLookahead4085;
                hitFailure= hitFailure4085;
                if (!check$Python_javacc$332$19()) {
                    currentLookaheadToken= token4085;
                    remainingLookahead= remainingLookahead4085;
                    hitFailure= hitFailure4085;
                    return false;
                }
            }
            return!hitFailure;
        }
        finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken= prevScanAheadToken;
            remainingLookahead= prevRemainingLookahead;
            hitFailure= prevHitFailure;
        }
    }

    // lookahead routine for lookahead at: 
    // Python.javacc:445:7
    private final boolean check$Python_javacc$445$13() {
        int prevRemainingLookahead= remainingLookahead;
        boolean prevHitFailure= hitFailure;
        Token prevScanAheadToken= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            // Applying single-token optimization for expansion of type ExpansionSequence
            // Python.javacc:445:13
            if (!scanToken(first_set$Python_javacc$445$13)) return false;
            return!hitFailure;
        }
        finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken= prevScanAheadToken;
            remainingLookahead= prevRemainingLookahead;
            hitFailure= prevHitFailure;
        }
    }

    // lookahead routine for lookahead at: 
    // Python.javacc:462:2
    private final boolean check$Python_javacc$462$7() {
        int prevRemainingLookahead= remainingLookahead;
        boolean prevHitFailure= hitFailure;
        Token prevScanAheadToken= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ExpansionChoice specified at Python.javacc:462:7
            Token token4086= currentLookaheadToken;
            int remainingLookahead4086= remainingLookahead;
            boolean hitFailure4086= hitFailure;
            if (!check$Python_javacc$462$7$()) {
                currentLookaheadToken= token4086;
                remainingLookahead= remainingLookahead4086;
                hitFailure= hitFailure4086;
                if (!check$Python_javacc$462$48()) {
                    currentLookaheadToken= token4086;
                    remainingLookahead= remainingLookahead4086;
                    hitFailure= hitFailure4086;
                    return false;
                }
            }
            return!hitFailure;
        }
        finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken= prevScanAheadToken;
            remainingLookahead= prevRemainingLookahead;
            hitFailure= prevHitFailure;
        }
    }

    // lookahead routine for lookahead at: 
    // Python.javacc:573:11
    private final boolean check$Python_javacc$573$16() {
        int prevRemainingLookahead= remainingLookahead;
        boolean prevHitFailure= hitFailure;
        Token prevScanAheadToken= currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpRef specified at Python.javacc:573:16
            if (!scanToken(NAME)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:573:23
            if (!scanToken(ASSIGN)) return false;
            return!hitFailure;
        }
        finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken= prevScanAheadToken;
            remainingLookahead= prevRemainingLookahead;
            hitFailure= prevHitFailure;
        }
    }

    private final boolean backscan$Python_javacc$406$23() {
        ListIterator<NonTerminalCall> stackIterator= stackIteratorBackward();
        NonTerminalCall ntc= null;
        if (!stackIterator.hasNext()) {
            return false;
        }
        stackIterator.next();
        if (!stackIterator.hasNext()) return false;
        ntc= stackIterator.next();
        if (ntc.productionName!="FunctionDefinition") return false;
        return true;
    }

    private final boolean backscan$Python_javacc$414$15() {
        ListIterator<NonTerminalCall> stackIterator= stackIteratorBackward();
        NonTerminalCall ntc= null;
        while (stackIterator.hasNext()) {
            ntc= stackIterator.next();
            if (ntc.productionName== "LambdaDefinition") {
                stackIterator.previous();
                break;
            }
            if (!stackIterator.hasNext()) return false;
        }
        if (!stackIterator.hasNext()) return false;
        ntc= stackIterator.next();
        if (ntc.productionName!="LambdaDefinition") return false;
        return true;
    }

    private final boolean backscan$Python_javacc$425$15() {
        ListIterator<NonTerminalCall> stackIterator= stackIteratorBackward();
        NonTerminalCall ntc= null;
        if (!stackIterator.hasNext()) return false;
        ntc= stackIterator.next();
        if (ntc.productionName!="FunctionDefinition") return false;
        return true;
    }

    private final boolean backscan$Python_javacc$433$26() {
        ListIterator<NonTerminalCall> stackIterator= stackIteratorBackward();
        NonTerminalCall ntc= null;
        if (!stackIterator.hasNext()) return false;
        ntc= stackIterator.next();
        if (ntc.productionName!="FunctionDefinition") return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$SignedNumber() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:33:3
        Token token4088= currentLookaheadToken;
        if (!scanToken(MINUS)) {
            currentLookaheadToken= token4088;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:34:3
        // Applying single-token optimization for expansion of type NonTerminal
        // Python.javacc:34:3
        if (!scanToken(first_set$Python_javacc$34$3)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:35:3
        Token token4089= currentLookaheadToken;
        if (!check$Python_javacc$35$4()) {
            currentLookaheadToken= token4089;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Strings() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for OneOrMore specified at Python.javacc:38:11
        if (!scanToken(STRING_LITERAL)) {
            return false;
        }
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4090= currentLookaheadToken;
            if (!scanToken(STRING_LITERAL)) {
                currentLookaheadToken= token4090;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$AtomicExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:41:5
        Token token4091= currentLookaheadToken;
        int remainingLookahead4091= remainingLookahead;
        boolean hitFailure4091= hitFailure;
        if (!scanToken(NAME)) {
            currentLookaheadToken= token4091;
            remainingLookahead= remainingLookahead4091;
            hitFailure= hitFailure4091;
            if (!scanToken(first_set$Python_javacc$43$5)) {
                currentLookaheadToken= token4091;
                remainingLookahead= remainingLookahead4091;
                hitFailure= hitFailure4091;
                if (!check$Python_javacc$45$5()) {
                    currentLookaheadToken= token4091;
                    remainingLookahead= remainingLookahead4091;
                    hitFailure= hitFailure4091;
                    if (!scanToken(TRUE)) {
                        currentLookaheadToken= token4091;
                        remainingLookahead= remainingLookahead4091;
                        hitFailure= hitFailure4091;
                        if (!scanToken(FALSE)) {
                            currentLookaheadToken= token4091;
                            remainingLookahead= remainingLookahead4091;
                            hitFailure= hitFailure4091;
                            if (!scanToken(NONE)) {
                                currentLookaheadToken= token4091;
                                remainingLookahead= remainingLookahead4091;
                                hitFailure= hitFailure4091;
                                if (!scanToken(PEG_PARSER)) {
                                    currentLookaheadToken= token4091;
                                    remainingLookahead= remainingLookahead4091;
                                    hitFailure= hitFailure4091;
                                    if (!check$Python_javacc$55$5()) {
                                        currentLookaheadToken= token4091;
                                        remainingLookahead= remainingLookahead4091;
                                        hitFailure= hitFailure4091;
                                        if (!check$Python_javacc$57$5()) {
                                            currentLookaheadToken= token4091;
                                            remainingLookahead= remainingLookahead4091;
                                            hitFailure= hitFailure4091;
                                            if (!check$Python_javacc$59$5()) {
                                                currentLookaheadToken= token4091;
                                                remainingLookahead= remainingLookahead4091;
                                                hitFailure= hitFailure4091;
                                                if (!scanToken(ELLIPSIS)) {
                                                    currentLookaheadToken= token4091;
                                                    remainingLookahead= remainingLookahead4091;
                                                    hitFailure= hitFailure4091;
                                                    return false;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Slice() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:65:5
        Token token4092= currentLookaheadToken;
        int remainingLookahead4092= remainingLookahead;
        boolean hitFailure4092= hitFailure;
        if (!check$Python_javacc$65$5()) {
            currentLookaheadToken= token4092;
            remainingLookahead= remainingLookahead4092;
            hitFailure= hitFailure4092;
            if (!check$Python_javacc$67$5()) {
                currentLookaheadToken= token4092;
                remainingLookahead= remainingLookahead4092;
                hitFailure= hitFailure4092;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Slices() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:70:10
        if (!scanToken(LBRACKET)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:70:14
        // NonTerminal Slice at Python.javacc:70:14
        pushOntoLookaheadStack("Slices", "Python.javacc", 70, 14);
        boolean prevScanToEnd4093= scanToEnd;
        currentLookaheadProduction= "Slice";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Slice()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4093;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:70:20
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4094= currentLookaheadToken;
            if (!check$Python_javacc$70$21()) {
                currentLookaheadToken= token4094;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:70:39
        Token token4095= currentLookaheadToken;
        if (!scanToken(COMMA)) {
            currentLookaheadToken= token4095;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:70:45
        if (!scanToken(RBRACKET)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Statement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:73:4
        Token token4096= currentLookaheadToken;
        int remainingLookahead4096= remainingLookahead;
        boolean hitFailure4096= hitFailure;
        if (!check$Python_javacc$73$4()) {
            currentLookaheadToken= token4096;
            remainingLookahead= remainingLookahead4096;
            hitFailure= hitFailure4096;
            if (!check$Python_javacc$75$4()) {
                currentLookaheadToken= token4096;
                remainingLookahead= remainingLookahead4096;
                hitFailure= hitFailure4096;
                if (!check$Python_javacc$77$4()) {
                    currentLookaheadToken= token4096;
                    remainingLookahead= remainingLookahead4096;
                    hitFailure= hitFailure4096;
                    return false;
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$SimpleStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:80:24
        // NonTerminal SmallStatement at Python.javacc:80:24
        pushOntoLookaheadStack("SimpleStatement", "Python.javacc", 80, 24);
        boolean prevScanToEnd4097= scanToEnd;
        currentLookaheadProduction= "SmallStatement";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$SmallStatement()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4097;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:80:39
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4098= currentLookaheadToken;
            if (!check$Python_javacc$80$40()) {
                currentLookaheadToken= token4098;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:80:67
        Token token4099= currentLookaheadToken;
        if (!scanToken(SEMICOLON)) {
            currentLookaheadToken= token4099;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:80:73
        if (!scanToken(NEWLINE)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$SmallStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:83:4
        Token token4100= currentLookaheadToken;
        int remainingLookahead4100= remainingLookahead;
        boolean hitFailure4100= hitFailure;
        if (!check$Python_javacc$83$4()) {
            currentLookaheadToken= token4100;
            remainingLookahead= remainingLookahead4100;
            hitFailure= hitFailure4100;
            if (!check$Python_javacc$85$4()) {
                currentLookaheadToken= token4100;
                remainingLookahead= remainingLookahead4100;
                hitFailure= hitFailure4100;
                if (!check$Python_javacc$87$4()) {
                    currentLookaheadToken= token4100;
                    remainingLookahead= remainingLookahead4100;
                    hitFailure= hitFailure4100;
                    if (!check$Python_javacc$89$4()) {
                        currentLookaheadToken= token4100;
                        remainingLookahead= remainingLookahead4100;
                        hitFailure= hitFailure4100;
                        if (!check$Python_javacc$91$4()) {
                            currentLookaheadToken= token4100;
                            remainingLookahead= remainingLookahead4100;
                            hitFailure= hitFailure4100;
                            if (!check$Python_javacc$93$4()) {
                                currentLookaheadToken= token4100;
                                remainingLookahead= remainingLookahead4100;
                                hitFailure= hitFailure4100;
                                if (!scanToken(BREAK)) {
                                    currentLookaheadToken= token4100;
                                    remainingLookahead= remainingLookahead4100;
                                    hitFailure= hitFailure4100;
                                    if (!scanToken(CONTINUE)) {
                                        currentLookaheadToken= token4100;
                                        remainingLookahead= remainingLookahead4100;
                                        hitFailure= hitFailure4100;
                                        if (!scanToken(PASS)) {
                                            currentLookaheadToken= token4100;
                                            remainingLookahead= remainingLookahead4100;
                                            hitFailure= hitFailure4100;
                                            if (!check$Python_javacc$101$4()) {
                                                currentLookaheadToken= token4100;
                                                remainingLookahead= remainingLookahead4100;
                                                hitFailure= hitFailure4100;
                                                if (!check$Python_javacc$103$4()) {
                                                    currentLookaheadToken= token4100;
                                                    remainingLookahead= remainingLookahead4100;
                                                    hitFailure= hitFailure4100;
                                                    if (!check$Python_javacc$105$4()) {
                                                        currentLookaheadToken= token4100;
                                                        remainingLookahead= remainingLookahead4100;
                                                        hitFailure= hitFailure4100;
                                                        if (!check$Python_javacc$107$4()) {
                                                            currentLookaheadToken= token4100;
                                                            remainingLookahead= remainingLookahead4100;
                                                            hitFailure= hitFailure4100;
                                                            return false;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$CompoundStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:111:5
        Token token4101= currentLookaheadToken;
        int remainingLookahead4101= remainingLookahead;
        boolean hitFailure4101= hitFailure;
        if (!check$Python_javacc$111$5()) {
            currentLookaheadToken= token4101;
            remainingLookahead= remainingLookahead4101;
            hitFailure= hitFailure4101;
            if (!check$Python_javacc$113$5()) {
                currentLookaheadToken= token4101;
                remainingLookahead= remainingLookahead4101;
                hitFailure= hitFailure4101;
                if (!check$Python_javacc$115$5()) {
                    currentLookaheadToken= token4101;
                    remainingLookahead= remainingLookahead4101;
                    hitFailure= hitFailure4101;
                    if (!check$Python_javacc$117$5()) {
                        currentLookaheadToken= token4101;
                        remainingLookahead= remainingLookahead4101;
                        hitFailure= hitFailure4101;
                        if (!check$Python_javacc$119$5()) {
                            currentLookaheadToken= token4101;
                            remainingLookahead= remainingLookahead4101;
                            hitFailure= hitFailure4101;
                            if (!check$Python_javacc$121$5()) {
                                currentLookaheadToken= token4101;
                                remainingLookahead= remainingLookahead4101;
                                hitFailure= hitFailure4101;
                                if (!check$Python_javacc$123$5()) {
                                    currentLookaheadToken= token4101;
                                    remainingLookahead= remainingLookahead4101;
                                    hitFailure= hitFailure4101;
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ReturnStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:126:19
        if (!scanToken(RETURN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:126:28
        Token token4102= currentLookaheadToken;
        if (!check$Python_javacc$126$29()) {
            currentLookaheadToken= token4102;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$GlobalStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:128:19
        if (!scanToken(GLOBAL)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:128:28
        if (!scanToken(NAME)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:128:35
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4103= currentLookaheadToken;
            if (!check$Python_javacc$128$36()) {
                currentLookaheadToken= token4103;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$NonlocalStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:130:21
        if (!scanToken(NONLOCAL)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:130:32
        if (!scanToken(NAME)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:130:39
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4104= currentLookaheadToken;
            if (!check$Python_javacc$130$40()) {
                currentLookaheadToken= token4104;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$AssertStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:132:19
        if (!scanToken(_ASSERT)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:132:28
        // NonTerminal Expression at Python.javacc:132:28
        pushOntoLookaheadStack("AssertStatement", "Python.javacc", 132, 28);
        boolean prevScanToEnd4105= scanToEnd;
        currentLookaheadProduction= "Expression";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Expression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4105;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:132:39
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4106= currentLookaheadToken;
            if (!check$Python_javacc$132$40()) {
                currentLookaheadToken= token4106;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$RaiseStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:134:18
        if (!scanToken(RAISE)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:134:26
        Token token4107= currentLookaheadToken;
        if (!check$Python_javacc$134$28()) {
            currentLookaheadToken= token4107;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Block() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:137:5
        Token token4108= currentLookaheadToken;
        int remainingLookahead4108= remainingLookahead;
        boolean hitFailure4108= hitFailure;
        if (!check$Python_javacc$137$5()) {
            currentLookaheadToken= token4108;
            remainingLookahead= remainingLookahead4108;
            hitFailure= hitFailure4108;
            if (!check$Python_javacc$139$5()) {
                currentLookaheadToken= token4108;
                remainingLookahead= remainingLookahead4108;
                hitFailure= hitFailure4108;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ElseBlock() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:142:13
        if (!scanToken(ELSE)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:142:20
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:142:24
        // NonTerminal Block at Python.javacc:142:24
        pushOntoLookaheadStack("ElseBlock", "Python.javacc", 142, 24);
        boolean prevScanToEnd4109= scanToEnd;
        currentLookaheadProduction= "Block";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Block()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4109;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ExceptBlock() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:144:15
        if (!scanToken(EXCEPT)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:144:24
        Token token4110= currentLookaheadToken;
        if (!check$Python_javacc$144$26()) {
            currentLookaheadToken= token4110;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:144:59
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:144:63
        // NonTerminal Block at Python.javacc:144:63
        pushOntoLookaheadStack("ExceptBlock", "Python.javacc", 144, 63);
        boolean prevScanToEnd4111= scanToEnd;
        currentLookaheadProduction= "Block";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Block()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4111;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$IfStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:147:5
        if (!scanToken(IF)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:147:10
        // NonTerminal NamedExpression at Python.javacc:147:10
        pushOntoLookaheadStack("IfStatement", "Python.javacc", 147, 10);
        boolean prevScanToEnd4112= scanToEnd;
        currentLookaheadProduction= "NamedExpression";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$NamedExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4112;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:147:26
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:147:30
        // NonTerminal Block at Python.javacc:147:30
        pushOntoLookaheadStack("IfStatement", "Python.javacc", 147, 30);
        boolean prevScanToEnd4113= scanToEnd;
        currentLookaheadProduction= "Block";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Block()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4113;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:148:6
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4114= currentLookaheadToken;
            if (!check$Python_javacc$148$7()) {
                currentLookaheadToken= token4114;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:149:6
        Token token4115= currentLookaheadToken;
        if (!check$Python_javacc$149$7()) {
            currentLookaheadToken= token4115;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$FinallyBlock() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:152:16
        if (!scanToken(FINALLY)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:152:26
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:152:30
        // NonTerminal Block at Python.javacc:152:30
        pushOntoLookaheadStack("FinallyBlock", "Python.javacc", 152, 30);
        boolean prevScanToEnd4116= scanToEnd;
        currentLookaheadProduction= "Block";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Block()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4116;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$WhileStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:154:18
        if (!scanToken(WHILE)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:154:26
        // NonTerminal NamedExpression at Python.javacc:154:26
        pushOntoLookaheadStack("WhileStatement", "Python.javacc", 154, 26);
        boolean prevScanToEnd4117= scanToEnd;
        currentLookaheadProduction= "NamedExpression";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$NamedExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4117;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:154:42
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:154:46
        // NonTerminal Block at Python.javacc:154:46
        pushOntoLookaheadStack("WhileStatement", "Python.javacc", 154, 46);
        boolean prevScanToEnd4118= scanToEnd;
        currentLookaheadProduction= "Block";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Block()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4118;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:154:52
        Token token4119= currentLookaheadToken;
        if (!check$Python_javacc$154$53()) {
            currentLookaheadToken= token4119;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$WithStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:157:5
        Token token4120= currentLookaheadToken;
        if (!scanToken(ASYNC)) {
            currentLookaheadToken= token4120;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:157:15
        if (!scanToken(WITH)) return false;
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 0;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:159:9
        Token token4121= currentLookaheadToken;
        int remainingLookahead4121= remainingLookahead;
        boolean hitFailure4121= hitFailure;
        if (!check$Python_javacc$159$9()) {
            currentLookaheadToken= token4121;
            remainingLookahead= remainingLookahead4121;
            hitFailure= hitFailure4121;
            if (!check$Python_javacc$161$9()) {
                currentLookaheadToken= token4121;
                remainingLookahead= remainingLookahead4121;
                hitFailure= hitFailure4121;
                return false;
            }
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:163:5
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:163:9
        // NonTerminal Block at Python.javacc:163:9
        pushOntoLookaheadStack("WithStatement", "Python.javacc", 163, 9);
        boolean prevScanToEnd4122= scanToEnd;
        currentLookaheadProduction= "Block";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Block()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4122;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$WithItemsInParentheses() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:166:31
        if (!scanToken(LPAREN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:166:35
        // NonTerminal WithItem at Python.javacc:166:35
        pushOntoLookaheadStack("WithItemsInParentheses", "Python.javacc", 166, 35);
        boolean prevScanToEnd4123= scanToEnd;
        currentLookaheadProduction= "WithItem";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$WithItem()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4123;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:166:44
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4124= currentLookaheadToken;
            if (!check$Python_javacc$166$45()) {
                currentLookaheadToken= token4124;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:166:67
        Token token4125= currentLookaheadToken;
        if (!scanToken(COMMA)) {
            currentLookaheadToken= token4125;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:166:73
        if (!scanToken(RPAREN)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$WithItem() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:168:12
        // NonTerminal Expression at Python.javacc:168:12
        pushOntoLookaheadStack("WithItem", "Python.javacc", 168, 12);
        boolean prevScanToEnd4126= scanToEnd;
        currentLookaheadProduction= "Expression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$Expression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4126;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:168:23
        Token token4127= currentLookaheadToken;
        if (!check$Python_javacc$168$24()) {
            currentLookaheadToken= token4127;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ForStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:171:4
        Token token4128= currentLookaheadToken;
        if (!scanToken(ASYNC)) {
            currentLookaheadToken= token4128;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:171:14
        if (!scanToken(FOR)) return false;
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 0;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:172:4
        // NonTerminal StarTargets at Python.javacc:172:4
        pushOntoLookaheadStack("ForStatement", "Python.javacc", 172, 4);
        boolean prevScanToEnd4129= scanToEnd;
        currentLookaheadProduction= "StarTargets";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$StarTargets()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4129;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:172:16
        if (!scanToken(IN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:172:21
        // NonTerminal StarExpressions at Python.javacc:172:21
        pushOntoLookaheadStack("ForStatement", "Python.javacc", 172, 21);
        boolean prevScanToEnd4130= scanToEnd;
        currentLookaheadProduction= "StarExpressions";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$StarExpressions()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4130;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:172:37
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:173:4
        // NonTerminal Block at Python.javacc:173:4
        pushOntoLookaheadStack("ForStatement", "Python.javacc", 173, 4);
        boolean prevScanToEnd4131= scanToEnd;
        currentLookaheadProduction= "Block";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Block()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4131;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:173:10
        Token token4132= currentLookaheadToken;
        if (!check$Python_javacc$173$11()) {
            currentLookaheadToken= token4132;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$TryStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:177:4
        if (!scanToken(TRY)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:177:10
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:177:14
        // NonTerminal Block at Python.javacc:177:14
        pushOntoLookaheadStack("TryStatement", "Python.javacc", 177, 14);
        boolean prevScanToEnd4133= scanToEnd;
        currentLookaheadProduction= "Block";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Block()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4133;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:179:8
        Token token4134= currentLookaheadToken;
        int remainingLookahead4134= remainingLookahead;
        boolean hitFailure4134= hitFailure;
        if (!check$Python_javacc$179$8()) {
            currentLookaheadToken= token4134;
            remainingLookahead= remainingLookahead4134;
            hitFailure= hitFailure4134;
            if (!check$Python_javacc$181$8()) {
                currentLookaheadToken= token4134;
                remainingLookahead= remainingLookahead4134;
                hitFailure= hitFailure4134;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$DelStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:185:16
        if (!scanToken(DEL)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:185:22
        // NonTerminal PrimaryExpression at Python.javacc:185:22
        pushOntoLookaheadStack("DelStatement", "Python.javacc", 185, 22);
        boolean prevScanToEnd4135= scanToEnd;
        currentLookaheadProduction= "PrimaryExpression";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$PrimaryExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4135;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:185:40
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4136= currentLookaheadToken;
            if (!check$Python_javacc$185$41()) {
                currentLookaheadToken= token4136;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:185:72
        Token token4137= currentLookaheadToken;
        if (!scanToken(COMMA)) {
            currentLookaheadToken= token4137;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$NamedExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:187:19
        Token token4138= currentLookaheadToken;
        if (!check$Python_javacc$187$21()) {
            currentLookaheadToken= token4138;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:187:38
        // NonTerminal Expression at Python.javacc:187:38
        pushOntoLookaheadStack("NamedExpression", "Python.javacc", 187, 38);
        boolean prevScanToEnd4139= scanToEnd;
        currentLookaheadProduction= "Expression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$Expression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4139;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$DottedName() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:189:14
        if (!scanToken(NAME)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:189:21
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4140= currentLookaheadToken;
            if (!check$Python_javacc$189$22()) {
                currentLookaheadToken= token4140;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ImportStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:191:19
        Token token4141= currentLookaheadToken;
        int remainingLookahead4141= remainingLookahead;
        boolean hitFailure4141= hitFailure;
        if (!check$Python_javacc$191$19()) {
            currentLookaheadToken= token4141;
            remainingLookahead= remainingLookahead4141;
            hitFailure= hitFailure4141;
            if (!check$Python_javacc$191$32()) {
                currentLookaheadToken= token4141;
                remainingLookahead= remainingLookahead4141;
                hitFailure= hitFailure4141;
                if (!check$Python_javacc$191$46()) {
                    currentLookaheadToken= token4141;
                    remainingLookahead= remainingLookahead4141;
                    hitFailure= hitFailure4141;
                    return false;
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ImportName() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:193:19
        if (!scanToken(IMPORT)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:193:28
        // NonTerminal DottedName at Python.javacc:193:28
        pushOntoLookaheadStack("ImportName", "Python.javacc", 193, 28);
        boolean prevScanToEnd4142= scanToEnd;
        currentLookaheadProduction= "DottedName";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$DottedName()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4142;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:193:39
        Token token4143= currentLookaheadToken;
        if (!check$Python_javacc$193$40()) {
            currentLookaheadToken= token4143;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:193:53
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4144= currentLookaheadToken;
            if (!check$Python_javacc$193$54()) {
                currentLookaheadToken= token4144;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ImportFrom1() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:195:20
        if (!scanToken(FROM)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:195:27
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4145= currentLookaheadToken;
            if (!scanToken(first_set$Python_javacc$195$28)) {
                currentLookaheadToken= token4145;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:195:42
        // NonTerminal DottedName at Python.javacc:195:42
        pushOntoLookaheadStack("ImportFrom1", "Python.javacc", 195, 42);
        boolean prevScanToEnd4146= scanToEnd;
        currentLookaheadProduction= "DottedName";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$DottedName()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4146;
            --nonTerminalNesting;
        }
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 0;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:195:58
        if (!scanToken(IMPORT)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:195:68
        // NonTerminal ImportFromTargets at Python.javacc:195:68
        pushOntoLookaheadStack("ImportFrom1", "Python.javacc", 195, 68);
        boolean prevScanToEnd4147= scanToEnd;
        currentLookaheadProduction= "ImportFromTargets";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$ImportFromTargets()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4147;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ImportFrom2() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:197:20
        if (!scanToken(FROM)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for OneOrMore specified at Python.javacc:197:27
        if (!scanToken(first_set$Python_javacc$197$28)) {
            return false;
        }
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4148= currentLookaheadToken;
            if (!scanToken(first_set$Python_javacc$197$28)) {
                currentLookaheadToken= token4148;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:197:42
        if (!scanToken(IMPORT)) return false;
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 0;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:197:56
        // NonTerminal ImportFromTargets at Python.javacc:197:56
        pushOntoLookaheadStack("ImportFrom2", "Python.javacc", 197, 56);
        boolean prevScanToEnd4149= scanToEnd;
        currentLookaheadProduction= "ImportFromTargets";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$ImportFromTargets()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4149;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ImportFromTargets() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:200:4
        Token token4150= currentLookaheadToken;
        int remainingLookahead4150= remainingLookahead;
        boolean hitFailure4150= hitFailure;
        if (!scanToken(STAR)) {
            currentLookaheadToken= token4150;
            remainingLookahead= remainingLookahead4150;
            hitFailure= hitFailure4150;
            if (!check$Python_javacc$202$4()) {
                currentLookaheadToken= token4150;
                remainingLookahead= remainingLookahead4150;
                hitFailure= hitFailure4150;
                if (!check$Python_javacc$204$4()) {
                    currentLookaheadToken= token4150;
                    remainingLookahead= remainingLookahead4150;
                    hitFailure= hitFailure4150;
                    return false;
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$StarNamedExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:208:6
        Token token4151= currentLookaheadToken;
        int remainingLookahead4151= remainingLookahead;
        boolean hitFailure4151= hitFailure;
        if (!check$Python_javacc$208$6()) {
            currentLookaheadToken= token4151;
            remainingLookahead= remainingLookahead4151;
            hitFailure= hitFailure4151;
            if (!check$Python_javacc$210$6()) {
                currentLookaheadToken= token4151;
                remainingLookahead= remainingLookahead4151;
                hitFailure= hitFailure4151;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$StarExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:214:5
        Token token4152= currentLookaheadToken;
        int remainingLookahead4152= remainingLookahead;
        boolean hitFailure4152= hitFailure;
        if (!check$Python_javacc$214$5()) {
            currentLookaheadToken= token4152;
            remainingLookahead= remainingLookahead4152;
            hitFailure= hitFailure4152;
            if (!check$Python_javacc$216$5()) {
                currentLookaheadToken= token4152;
                remainingLookahead= remainingLookahead4152;
                hitFailure= hitFailure4152;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$StarExpressions() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:219:19
        // NonTerminal StarExpression at Python.javacc:219:19
        pushOntoLookaheadStack("StarExpressions", "Python.javacc", 219, 19);
        boolean prevScanToEnd4153= scanToEnd;
        currentLookaheadProduction= "StarExpression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$StarExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4153;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:219:34
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4154= currentLookaheadToken;
            if (!check$Python_javacc$219$35()) {
                currentLookaheadToken= token4154;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:219:62
        Token token4155= currentLookaheadToken;
        if (!scanToken(COMMA)) {
            currentLookaheadToken= token4155;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$StarNamedExpressions() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:221:24
        // NonTerminal StarNamedExpression at Python.javacc:221:24
        pushOntoLookaheadStack("StarNamedExpressions", "Python.javacc", 221, 24);
        boolean prevScanToEnd4156= scanToEnd;
        currentLookaheadProduction= "StarNamedExpression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$StarNamedExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4156;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:221:44
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4157= currentLookaheadToken;
            if (!check$Python_javacc$221$45()) {
                currentLookaheadToken= token4157;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:221:77
        Token token4158= currentLookaheadToken;
        if (!scanToken(COMMA)) {
            currentLookaheadToken= token4158;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$BitwiseOr() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:223:13
        // NonTerminal BitwiseXor at Python.javacc:223:13
        pushOntoLookaheadStack("BitwiseOr", "Python.javacc", 223, 13);
        boolean prevScanToEnd4159= scanToEnd;
        currentLookaheadProduction= "BitwiseXor";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$BitwiseXor()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4159;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:223:24
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4160= currentLookaheadToken;
            if (!check$Python_javacc$223$25()) {
                currentLookaheadToken= token4160;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$BitwiseXor() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:225:14
        // NonTerminal BitwiseAnd at Python.javacc:225:14
        pushOntoLookaheadStack("BitwiseXor", "Python.javacc", 225, 14);
        boolean prevScanToEnd4161= scanToEnd;
        currentLookaheadProduction= "BitwiseAnd";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$BitwiseAnd()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4161;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:225:25
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4162= currentLookaheadToken;
            if (!check$Python_javacc$225$26()) {
                currentLookaheadToken= token4162;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$BitwiseAnd() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:227:14
        // NonTerminal ShiftExpression at Python.javacc:227:14
        pushOntoLookaheadStack("BitwiseAnd", "Python.javacc", 227, 14);
        boolean prevScanToEnd4163= scanToEnd;
        currentLookaheadProduction= "ShiftExpression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$ShiftExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4163;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:227:30
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4164= currentLookaheadToken;
            if (!check$Python_javacc$227$31()) {
                currentLookaheadToken= token4164;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ShiftExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:229:19
        // NonTerminal AdditiveExpression at Python.javacc:229:19
        pushOntoLookaheadStack("ShiftExpression", "Python.javacc", 229, 19);
        boolean prevScanToEnd4165= scanToEnd;
        currentLookaheadProduction= "AdditiveExpression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$AdditiveExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4165;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:229:38
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4166= currentLookaheadToken;
            if (!check$Python_javacc$229$39()) {
                currentLookaheadToken= token4166;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$AdditiveExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:231:22
        // NonTerminal MultiplicativeExpression at Python.javacc:231:22
        pushOntoLookaheadStack("AdditiveExpression", "Python.javacc", 231, 22);
        boolean prevScanToEnd4167= scanToEnd;
        currentLookaheadProduction= "MultiplicativeExpression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$MultiplicativeExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4167;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:231:47
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4168= currentLookaheadToken;
            if (!check$Python_javacc$231$48()) {
                currentLookaheadToken= token4168;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$MultiplicativeExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:233:28
        // NonTerminal UnaryExpression at Python.javacc:233:28
        pushOntoLookaheadStack("MultiplicativeExpression", "Python.javacc", 233, 28);
        boolean prevScanToEnd4169= scanToEnd;
        currentLookaheadProduction= "UnaryExpression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$UnaryExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4169;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:233:44
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4170= currentLookaheadToken;
            if (!check$Python_javacc$233$45()) {
                currentLookaheadToken= token4170;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$UnaryExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:235:19
        Token token4171= currentLookaheadToken;
        int remainingLookahead4171= remainingLookahead;
        boolean hitFailure4171= hitFailure;
        if (!check$Python_javacc$235$19()) {
            currentLookaheadToken= token4171;
            remainingLookahead= remainingLookahead4171;
            hitFailure= hitFailure4171;
            if (!check$Python_javacc$235$27()) {
                currentLookaheadToken= token4171;
                remainingLookahead= remainingLookahead4171;
                hitFailure= hitFailure4171;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Power() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:237:9
        // NonTerminal AwaitPrimary at Python.javacc:237:9
        pushOntoLookaheadStack("Power", "Python.javacc", 237, 9);
        boolean prevScanToEnd4172= scanToEnd;
        currentLookaheadProduction= "AwaitPrimary";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$AwaitPrimary()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4172;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:237:22
        Token token4173= currentLookaheadToken;
        if (!check$Python_javacc$237$23()) {
            currentLookaheadToken= token4173;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Tuple() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:241:5
        if (!scanToken(LPAREN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:241:9
        Token token4174= currentLookaheadToken;
        if (!check$Python_javacc$241$10()) {
            currentLookaheadToken= token4174;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:241:58
        if (!scanToken(RPAREN)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Group() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:244:9
        if (!scanToken(LPAREN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:244:14
        Token token4175= currentLookaheadToken;
        int remainingLookahead4175= remainingLookahead;
        boolean hitFailure4175= hitFailure;
        if (!check$Python_javacc$244$14()) {
            currentLookaheadToken= token4175;
            remainingLookahead= remainingLookahead4175;
            hitFailure= hitFailure4175;
            if (!check$Python_javacc$244$32()) {
                currentLookaheadToken= token4175;
                remainingLookahead= remainingLookahead4175;
                hitFailure= hitFailure4175;
                return false;
            }
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:244:49
        if (!scanToken(RPAREN)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$AwaitPrimary() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:246:16
        Token token4176= currentLookaheadToken;
        if (!scanToken(AWAIT)) {
            currentLookaheadToken= token4176;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:246:26
        // NonTerminal PrimaryExpression at Python.javacc:246:26
        pushOntoLookaheadStack("AwaitPrimary", "Python.javacc", 246, 26);
        boolean prevScanToEnd4177= scanToEnd;
        currentLookaheadProduction= "PrimaryExpression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$PrimaryExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4177;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$PrimaryExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:249:4
        // NonTerminal AtomicExpression at Python.javacc:249:4
        pushOntoLookaheadStack("PrimaryExpression", "Python.javacc", 249, 4);
        boolean prevScanToEnd4178= scanToEnd;
        currentLookaheadProduction= "AtomicExpression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$AtomicExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4178;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:250:4
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4179= currentLookaheadToken;
            if (!check$Python_javacc$251$8()) {
                currentLookaheadToken= token4179;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$YieldExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:262:5
        Token token4180= currentLookaheadToken;
        int remainingLookahead4180= remainingLookahead;
        boolean hitFailure4180= hitFailure;
        if (!check$Python_javacc$262$5()) {
            currentLookaheadToken= token4180;
            remainingLookahead= remainingLookahead4180;
            hitFailure= hitFailure4180;
            if (!check$Python_javacc$264$5()) {
                currentLookaheadToken= token4180;
                remainingLookahead= remainingLookahead4180;
                hitFailure= hitFailure4180;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$YieldStatement() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:267:19
        // NonTerminal YieldExpression at Python.javacc:267:19
        pushOntoLookaheadStack("YieldStatement", "Python.javacc", 267, 19);
        boolean prevScanToEnd4181= scanToEnd;
        currentLookaheadProduction= "YieldExpression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$YieldExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4181;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$AnnotatedRhs() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:269:16
        Token token4182= currentLookaheadToken;
        int remainingLookahead4182= remainingLookahead;
        boolean hitFailure4182= hitFailure;
        if (!check$Python_javacc$269$16()) {
            currentLookaheadToken= token4182;
            remainingLookahead= remainingLookahead4182;
            hitFailure= hitFailure4182;
            if (!check$Python_javacc$269$34()) {
                currentLookaheadToken= token4182;
                remainingLookahead= remainingLookahead4182;
                hitFailure= hitFailure4182;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Decorators() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for OneOrMore specified at Python.javacc:271:14
        if (!check$Python_javacc$271$15()) {
            return false;
        }
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4183= currentLookaheadToken;
            if (!check$Python_javacc$271$15()) {
                currentLookaheadToken= token4183;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$InvocationArguments() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:276:4
        if (!scanToken(LPAREN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:277:4
        Token token4185= currentLookaheadToken;
        if (!check$Python_javacc$278$7()) {
            currentLookaheadToken= token4185;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:299:4
        if (!scanToken(RPAREN)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Argument() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:303:4
        Token token4186= currentLookaheadToken;
        int remainingLookahead4186= remainingLookahead;
        boolean hitFailure4186= hitFailure;
        if (!check$Python_javacc$303$4()) {
            currentLookaheadToken= token4186;
            remainingLookahead= remainingLookahead4186;
            hitFailure= hitFailure4186;
            if (!check$Python_javacc$313$4()) {
                currentLookaheadToken= token4186;
                remainingLookahead= remainingLookahead4186;
                hitFailure= hitFailure4186;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$KeyValuePair() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:321:16
        // NonTerminal Expression at Python.javacc:321:16
        pushOntoLookaheadStack("KeyValuePair", "Python.javacc", 321, 16);
        boolean prevScanToEnd4187= scanToEnd;
        currentLookaheadProduction= "Expression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$Expression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4187;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:321:27
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:321:31
        // NonTerminal Expression at Python.javacc:321:31
        pushOntoLookaheadStack("KeyValuePair", "Python.javacc", 321, 31);
        boolean prevScanToEnd4188= scanToEnd;
        currentLookaheadProduction= "Expression";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Expression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4188;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$DoubleStarredKeyValuePair() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:324:5
        Token token4189= currentLookaheadToken;
        int remainingLookahead4189= remainingLookahead;
        boolean hitFailure4189= hitFailure;
        if (!check$Python_javacc$324$5()) {
            currentLookaheadToken= token4189;
            remainingLookahead= remainingLookahead4189;
            hitFailure= hitFailure4189;
            if (!check$Python_javacc$326$5()) {
                currentLookaheadToken= token4189;
                remainingLookahead= remainingLookahead4189;
                hitFailure= hitFailure4189;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$DoubleStarredKeyValuePairs() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:329:30
        // NonTerminal DoubleStarredKeyValuePair at Python.javacc:329:30
        pushOntoLookaheadStack("DoubleStarredKeyValuePairs", "Python.javacc", 329, 30);
        boolean prevScanToEnd4190= scanToEnd;
        currentLookaheadProduction= "DoubleStarredKeyValuePair";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$DoubleStarredKeyValuePair()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4190;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:329:56
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4191= currentLookaheadToken;
            if (!check$Python_javacc$329$57()) {
                currentLookaheadToken= token4191;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:329:95
        Token token4192= currentLookaheadToken;
        if (!scanToken(COMMA)) {
            currentLookaheadToken= token4192;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Dict() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:334:5
        if (!scanToken(LBRACE)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:335:5
        Token token4193= currentLookaheadToken;
        if (!check$Python_javacc$335$6()) {
            currentLookaheadToken= token4193;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:336:5
        if (!scanToken(RBRACE)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$DictComp() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:340:12
        if (!scanToken(LBRACE)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:340:16
        // NonTerminal KeyValuePair at Python.javacc:340:16
        pushOntoLookaheadStack("DictComp", "Python.javacc", 340, 16);
        boolean prevScanToEnd4194= scanToEnd;
        currentLookaheadProduction= "KeyValuePair";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$KeyValuePair()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4194;
            --nonTerminalNesting;
        }
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 2;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for OneOrMore specified at Python.javacc:340:35
        if (!check$Python_javacc$340$36()) {
            return false;
        }
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4195= currentLookaheadToken;
            if (!check$Python_javacc$340$36()) {
                currentLookaheadToken= token4195;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:340:50
        if (!scanToken(RBRACE)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Set() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:342:7
        if (!scanToken(LBRACE)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:342:11
        // NonTerminal StarNamedExpressions at Python.javacc:342:11
        pushOntoLookaheadStack("Set", "Python.javacc", 342, 11);
        boolean prevScanToEnd4196= scanToEnd;
        currentLookaheadProduction= "StarNamedExpressions";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$StarNamedExpressions()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4196;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:342:32
        if (!scanToken(RBRACE)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$SetComp() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:344:11
        if (!scanToken(LBRACE)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:344:15
        // NonTerminal NamedExpression at Python.javacc:344:15
        pushOntoLookaheadStack("SetComp", "Python.javacc", 344, 15);
        boolean prevScanToEnd4197= scanToEnd;
        currentLookaheadProduction= "NamedExpression";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$NamedExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4197;
            --nonTerminalNesting;
        }
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 2;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for OneOrMore specified at Python.javacc:344:37
        if (!check$Python_javacc$344$38()) {
            return false;
        }
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4198= currentLookaheadToken;
            if (!check$Python_javacc$344$38()) {
                currentLookaheadToken= token4198;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:344:52
        if (!scanToken(RBRACE)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ClassDefinition() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:347:5
        Token token4199= currentLookaheadToken;
        if (!check$Python_javacc$347$6()) {
            currentLookaheadToken= token4199;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:347:18
        if (!scanToken(CLASS)) return false;
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 0;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:348:5
        if (!scanToken(NAME)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:348:12
        Token token4200= currentLookaheadToken;
        if (!check$Python_javacc$348$13()) {
            currentLookaheadToken= token4200;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:349:5
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:350:5
        // NonTerminal Block at Python.javacc:350:5
        pushOntoLookaheadStack("ClassDefinition", "Python.javacc", 350, 5);
        boolean prevScanToEnd4201= scanToEnd;
        currentLookaheadProduction= "Block";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Block()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4201;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$FunctionDefinition() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:354:5
        Token token4202= currentLookaheadToken;
        if (!check$Python_javacc$354$6()) {
            currentLookaheadToken= token4202;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:355:5
        Token token4203= currentLookaheadToken;
        if (!scanToken(ASYNC)) {
            currentLookaheadToken= token4203;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:356:5
        if (!scanToken(DEF)) return false;
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 0;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:357:5
        if (!scanToken(NAME)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:358:5
        if (!scanToken(LPAREN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:359:5
        // NonTerminal Parameters at Python.javacc:359:5
        pushOntoLookaheadStack("FunctionDefinition", "Python.javacc", 359, 5);
        boolean prevScanToEnd4204= scanToEnd;
        currentLookaheadProduction= "Parameters";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Parameters()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4204;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:360:5
        if (!scanToken(RPAREN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:361:5
        Token token4205= currentLookaheadToken;
        if (!check$Python_javacc$361$6()) {
            currentLookaheadToken= token4205;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:362:5
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:362:9
        // NonTerminal Block at Python.javacc:362:9
        pushOntoLookaheadStack("FunctionDefinition", "Python.javacc", 362, 9);
        boolean prevScanToEnd4206= scanToEnd;
        currentLookaheadProduction= "Block";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Block()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4206;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$LambdaDefinition() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:365:20
        if (!scanToken(LAMBDA)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:365:29
        // NonTerminal Parameters at Python.javacc:365:29
        pushOntoLookaheadStack("LambdaDefinition", "Python.javacc", 365, 29);
        boolean prevScanToEnd4207= scanToEnd;
        currentLookaheadProduction= "Parameters";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Parameters()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4207;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:365:40
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:365:44
        // NonTerminal Expression at Python.javacc:365:44
        pushOntoLookaheadStack("LambdaDefinition", "Python.javacc", 365, 44);
        boolean prevScanToEnd4208= scanToEnd;
        currentLookaheadProduction= "Expression";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Expression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4208;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Expression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:371:14
        Token token4209= currentLookaheadToken;
        int remainingLookahead4209= remainingLookahead;
        boolean hitFailure4209= hitFailure;
        if (!check$Python_javacc$371$14()) {
            currentLookaheadToken= token4209;
            remainingLookahead= remainingLookahead4209;
            hitFailure= hitFailure4209;
            if (!check$Python_javacc$371$65()) {
                currentLookaheadToken= token4209;
                remainingLookahead= remainingLookahead4209;
                hitFailure= hitFailure4209;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Disjunction() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:373:15
        // NonTerminal Conjunction at Python.javacc:373:15
        pushOntoLookaheadStack("Disjunction", "Python.javacc", 373, 15);
        boolean prevScanToEnd4210= scanToEnd;
        currentLookaheadProduction= "Conjunction";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$Conjunction()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4210;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:373:27
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4211= currentLookaheadToken;
            if (!check$Python_javacc$373$28()) {
                currentLookaheadToken= token4211;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Conjunction() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:375:15
        // NonTerminal Inversion at Python.javacc:375:15
        pushOntoLookaheadStack("Conjunction", "Python.javacc", 375, 15);
        boolean prevScanToEnd4212= scanToEnd;
        currentLookaheadProduction= "Inversion";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$Inversion()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4212;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:375:25
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4213= currentLookaheadToken;
            if (!check$Python_javacc$375$26()) {
                currentLookaheadToken= token4213;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Inversion() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:377:13
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4214= currentLookaheadToken;
            if (!scanToken(NOT)) {
                currentLookaheadToken= token4214;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:377:22
        // NonTerminal Comparison at Python.javacc:377:22
        pushOntoLookaheadStack("Inversion", "Python.javacc", 377, 22);
        boolean prevScanToEnd4215= scanToEnd;
        currentLookaheadProduction= "Comparison";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$Comparison()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4215;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Comparison() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:379:14
        // NonTerminal BitwiseOr at Python.javacc:379:14
        pushOntoLookaheadStack("Comparison", "Python.javacc", 379, 14);
        boolean prevScanToEnd4216= scanToEnd;
        currentLookaheadProduction= "BitwiseOr";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$BitwiseOr()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4216;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:379:24
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4217= currentLookaheadToken;
            if (!check$Python_javacc$379$25()) {
                currentLookaheadToken= token4217;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ComparisonOperator() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:382:4
        Token token4218= currentLookaheadToken;
        int remainingLookahead4218= remainingLookahead;
        boolean hitFailure4218= hitFailure;
        if (!scanToken(LT)) {
            currentLookaheadToken= token4218;
            remainingLookahead= remainingLookahead4218;
            hitFailure= hitFailure4218;
            if (!scanToken(GT)) {
                currentLookaheadToken= token4218;
                remainingLookahead= remainingLookahead4218;
                hitFailure= hitFailure4218;
                if (!scanToken(EQ)) {
                    currentLookaheadToken= token4218;
                    remainingLookahead= remainingLookahead4218;
                    hitFailure= hitFailure4218;
                    if (!scanToken(GE)) {
                        currentLookaheadToken= token4218;
                        remainingLookahead= remainingLookahead4218;
                        hitFailure= hitFailure4218;
                        if (!scanToken(LE)) {
                            currentLookaheadToken= token4218;
                            remainingLookahead= remainingLookahead4218;
                            hitFailure= hitFailure4218;
                            if (!scanToken(NE)) {
                                currentLookaheadToken= token4218;
                                remainingLookahead= remainingLookahead4218;
                                hitFailure= hitFailure4218;
                                if (!check$Python_javacc$384$4()) {
                                    currentLookaheadToken= token4218;
                                    remainingLookahead= remainingLookahead4218;
                                    hitFailure= hitFailure4218;
                                    if (!check$Python_javacc$386$4()) {
                                        currentLookaheadToken= token4218;
                                        remainingLookahead= remainingLookahead4218;
                                        hitFailure= hitFailure4218;
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$StarTarget() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:389:14
        Token token4219= currentLookaheadToken;
        if (!scanToken(STAR)) {
            currentLookaheadToken= token4219;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:389:20
        // NonTerminal PrimaryExpression at Python.javacc:389:20
        pushOntoLookaheadStack("StarTarget", "Python.javacc", 389, 20);
        boolean prevScanToEnd4220= scanToEnd;
        currentLookaheadProduction= "PrimaryExpression";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$PrimaryExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4220;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$StarTargets() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:391:15
        // NonTerminal StarTarget at Python.javacc:391:15
        pushOntoLookaheadStack("StarTargets", "Python.javacc", 391, 15);
        boolean prevScanToEnd4221= scanToEnd;
        currentLookaheadProduction= "StarTarget";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$StarTarget()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4221;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:391:26
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4222= currentLookaheadToken;
            if (!check$Python_javacc$391$27()) {
                currentLookaheadToken= token4222;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:391:50
        Token token4223= currentLookaheadToken;
        if (!scanToken(COMMA)) {
            currentLookaheadToken= token4223;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ForIfClause() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:393:15
        Token token4224= currentLookaheadToken;
        if (!scanToken(ASYNC)) {
            currentLookaheadToken= token4224;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:393:25
        if (!scanToken(FOR)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:393:31
        // NonTerminal StarTargets at Python.javacc:393:31
        pushOntoLookaheadStack("ForIfClause", "Python.javacc", 393, 31);
        boolean prevScanToEnd4225= scanToEnd;
        currentLookaheadProduction= "StarTargets";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$StarTargets()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4225;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:393:43
        if (!scanToken(IN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:393:48
        // NonTerminal Disjunction at Python.javacc:393:48
        pushOntoLookaheadStack("ForIfClause", "Python.javacc", 393, 48);
        boolean prevScanToEnd4226= scanToEnd;
        currentLookaheadProduction= "Disjunction";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Disjunction()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4226;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:393:60
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4227= currentLookaheadToken;
            if (!check$Python_javacc$393$61()) {
                currentLookaheadToken= token4227;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$GenExp() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:395:10
        if (!scanToken(LPAREN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:395:14
        // NonTerminal NamedExpression at Python.javacc:395:14
        pushOntoLookaheadStack("GenExp", "Python.javacc", 395, 14);
        boolean prevScanToEnd4228= scanToEnd;
        currentLookaheadProduction= "NamedExpression";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$NamedExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4228;
            --nonTerminalNesting;
        }
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 2;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for OneOrMore specified at Python.javacc:395:36
        if (!check$Python_javacc$395$37()) {
            return false;
        }
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4229= currentLookaheadToken;
            if (!check$Python_javacc$395$37()) {
                currentLookaheadToken= token4229;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:395:51
        if (!scanToken(RPAREN)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$List() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:397:8
        if (!scanToken(LBRACKET)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:397:12
        Token token4230= currentLookaheadToken;
        if (!check$Python_javacc$397$13()) {
            currentLookaheadToken= token4230;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:397:35
        if (!scanToken(RBRACKET)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ListComp() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:399:12
        if (!scanToken(LBRACKET)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:399:16
        // NonTerminal NamedExpression at Python.javacc:399:16
        pushOntoLookaheadStack("ListComp", "Python.javacc", 399, 16);
        boolean prevScanToEnd4231= scanToEnd;
        currentLookaheadProduction= "NamedExpression";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$NamedExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4231;
            --nonTerminalNesting;
        }
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 2;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for OneOrMore specified at Python.javacc:399:38
        if (!check$Python_javacc$399$39()) {
            return false;
        }
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4232= currentLookaheadToken;
            if (!check$Python_javacc$399$39()) {
                currentLookaheadToken= token4232;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:399:53
        if (!scanToken(RBRACKET)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$StarEtc() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:402:4
        Token token4233= currentLookaheadToken;
        int remainingLookahead4233= remainingLookahead;
        boolean hitFailure4233= hitFailure;
        if (!check$Python_javacc$402$4()) {
            currentLookaheadToken= token4233;
            remainingLookahead= remainingLookahead4233;
            hitFailure= hitFailure4233;
            if (!check$Python_javacc$404$4()) {
                currentLookaheadToken= token4233;
                remainingLookahead= remainingLookahead4233;
                hitFailure= hitFailure4233;
                if (!check$Python_javacc$406$4()) {
                    currentLookaheadToken= token4233;
                    remainingLookahead= remainingLookahead4233;
                    hitFailure= hitFailure4233;
                    return false;
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ParamMaybeDefault() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:409:21
        if (!scanToken(NAME)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:409:28
        Token token4234= currentLookaheadToken;
        if (!check$Python_javacc$409$29()) {
            currentLookaheadToken= token4234;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:409:45
        Token token4235= currentLookaheadToken;
        if (!check$Python_javacc$409$46()) {
            currentLookaheadToken= token4235;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$KeyWords() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:412:4
        if (!scanToken(STAR_STAR)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:412:9
        if (!scanToken(NAME)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:413:4
        Token token4236= currentLookaheadToken;
        if (!check$Python_javacc$414$8()) {
            currentLookaheadToken= token4236;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Parameters() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:421:5
        Token token4237= currentLookaheadToken;
        if (!check$Python_javacc$422$7()) {
            currentLookaheadToken= token4237;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:444:5
        Token token4238= currentLookaheadToken;
        if (!check$Python_javacc$445$7()) {
            currentLookaheadToken= token4238;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:447:5
        Token token4239= currentLookaheadToken;
        if (!scanToken(COMMA)) {
            currentLookaheadToken= token4239;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$SimpleAssignTarget() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:456:4
        Token token4240= currentLookaheadToken;
        int remainingLookahead4240= remainingLookahead;
        boolean hitFailure4240= hitFailure;
        if (!check$Python_javacc$456$4()) {
            currentLookaheadToken= token4240;
            remainingLookahead= remainingLookahead4240;
            hitFailure= hitFailure4240;
            if (!check$Python_javacc$458$4()) {
                currentLookaheadToken= token4240;
                remainingLookahead= remainingLookahead4240;
                hitFailure= hitFailure4240;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Assignment() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:464:3
        Token token4241= currentLookaheadToken;
        int remainingLookahead4241= remainingLookahead;
        boolean hitFailure4241= hitFailure;
        if (!check$Python_javacc$464$3()) {
            currentLookaheadToken= token4241;
            remainingLookahead= remainingLookahead4241;
            hitFailure= hitFailure4241;
            if (!check$Python_javacc$466$3()) {
                currentLookaheadToken= token4241;
                remainingLookahead= remainingLookahead4241;
                hitFailure= hitFailure4241;
                if (!check$Python_javacc$468$3()) {
                    currentLookaheadToken= token4241;
                    remainingLookahead= remainingLookahead4241;
                    hitFailure= hitFailure4241;
                    return false;
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$MatchStatement() {
        EnumSet<TokenType> previousActives4242= EnumSet.copyOf(token_source.activeTokenTypes);
        boolean somethingChanged4243= activateTokenTypes(MATCH);
        try {
            // Applying single-token optimization for expansion of type ExpansionSequence
            // Python.javacc:476:27
            if (!scanToken(MATCH)) return false;
        }
        finally {
            token_source.activeTokenTypes= previousActives4242;
            if (somethingChanged4243) {
                token_source.reset(currentLookaheadToken);
                nextTokenType= null;
            }
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:477:4
        // NonTerminal SubjectExpression at Python.javacc:477:4
        pushOntoLookaheadStack("MatchStatement", "Python.javacc", 477, 4);
        boolean prevScanToEnd4244= scanToEnd;
        currentLookaheadProduction= "SubjectExpression";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$SubjectExpression()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4244;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:478:4
        if (!scanToken(COLON)) return false;
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 0;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:480:4
        if (!scanToken(NEWLINE)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:481:4
        if (!scanToken(INDENT)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for OneOrMore specified at Python.javacc:482:25
        EnumSet<TokenType> previousActives4245= EnumSet.copyOf(token_source.activeTokenTypes);
        boolean somethingChanged4246= activateTokenTypes(CASE);
        try {
            if (!check$Python_javacc$482$26()) {
                return false;
            }
            while (remainingLookahead> 0&&!hitFailure) {
                Token token4247= currentLookaheadToken;
                if (!check$Python_javacc$482$26()) {
                    currentLookaheadToken= token4247;
                    break;
                }
            }
            hitFailure= false;
        }
        finally {
            token_source.activeTokenTypes= previousActives4245;
            if (somethingChanged4246) {
                token_source.reset(currentLookaheadToken);
                nextTokenType= null;
            }
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:483:4
        if (!scanToken(DEDENT)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$CaseBlock() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:487:5
        if (!scanToken(CASE)) return false;
        EnumSet<TokenType> previousActives4248= EnumSet.copyOf(token_source.activeTokenTypes);
        boolean somethingChanged4249= deactivateTokenTypes(CASE);
        try {
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:490:7
            // NonTerminal Patterns at Python.javacc:490:7
            pushOntoLookaheadStack("CaseBlock", "Python.javacc", 490, 7);
            boolean prevScanToEnd4250= scanToEnd;
            currentLookaheadProduction= "Patterns";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Patterns()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4250;
                --nonTerminalNesting;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for ZeroOrOne specified at Python.javacc:491:7
            Token token4251= currentLookaheadToken;
            if (!check$Python_javacc$491$8()) {
                currentLookaheadToken= token4251;
                hitFailure= false;
            }
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for RegexpStringLiteral specified at Python.javacc:492:7
            if (!scanToken(COLON)) return false;
            if (hitFailure||remainingLookahead<=0) return!hitFailure;
            // Lookahead Code for NonTerminal specified at Python.javacc:493:7
            // NonTerminal Block at Python.javacc:493:7
            pushOntoLookaheadStack("CaseBlock", "Python.javacc", 493, 7);
            boolean prevScanToEnd4252= scanToEnd;
            currentLookaheadProduction= "Block";
            scanToEnd= true;
            ++nonTerminalNesting;
            try {
                if (!check$Block()) return false;
            }
            finally {
                popLookaheadStack();
                scanToEnd= prevScanToEnd4252;
                --nonTerminalNesting;
            }
        }
        finally {
            token_source.activeTokenTypes= previousActives4248;
            if (somethingChanged4249) {
                token_source.reset(currentLookaheadToken);
                nextTokenType= null;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Patterns() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:499:4
        Token token4253= currentLookaheadToken;
        int remainingLookahead4253= remainingLookahead;
        boolean hitFailure4253= hitFailure;
        if (!check$Python_javacc$499$4()) {
            currentLookaheadToken= token4253;
            remainingLookahead= remainingLookahead4253;
            hitFailure= hitFailure4253;
            if (!check$Python_javacc$501$4()) {
                currentLookaheadToken= token4253;
                remainingLookahead= remainingLookahead4253;
                hitFailure= hitFailure4253;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$StarPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:505:4
        if (!scanToken(STAR)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:505:8
        if (!scanToken(NAME)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$MaybeStarPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:508:25
        Token token4254= currentLookaheadToken;
        int remainingLookahead4254= remainingLookahead;
        boolean hitFailure4254= hitFailure;
        if (!check$Python_javacc$508$25()) {
            currentLookaheadToken= token4254;
            remainingLookahead= remainingLookahead4254;
            hitFailure= hitFailure4254;
            if (!check$Python_javacc$508$39()) {
                currentLookaheadToken= token4254;
                remainingLookahead= remainingLookahead4254;
                hitFailure= hitFailure4254;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ClosedPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:511:4
        Token token4255= currentLookaheadToken;
        int remainingLookahead4255= remainingLookahead;
        boolean hitFailure4255= hitFailure;
        if (!check$Python_javacc$511$4()) {
            currentLookaheadToken= token4255;
            remainingLookahead= remainingLookahead4255;
            hitFailure= hitFailure4255;
            if (!check$Python_javacc$513$4()) {
                currentLookaheadToken= token4255;
                remainingLookahead= remainingLookahead4255;
                hitFailure= hitFailure4255;
                if (!check$Python_javacc$515$4()) {
                    currentLookaheadToken= token4255;
                    remainingLookahead= remainingLookahead4255;
                    hitFailure= hitFailure4255;
                    if (!check$Python_javacc$517$4()) {
                        currentLookaheadToken= token4255;
                        remainingLookahead= remainingLookahead4255;
                        hitFailure= hitFailure4255;
                        if (!check$Python_javacc$519$4()) {
                            currentLookaheadToken= token4255;
                            remainingLookahead= remainingLookahead4255;
                            hitFailure= hitFailure4255;
                            if (!check$Python_javacc$521$4()) {
                                currentLookaheadToken= token4255;
                                remainingLookahead= remainingLookahead4255;
                                hitFailure= hitFailure4255;
                                return false;
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$GroupPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:524:16
        if (!scanToken(LPAREN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:524:20
        // NonTerminal Pattern at Python.javacc:524:20
        pushOntoLookaheadStack("GroupPattern", "Python.javacc", 524, 20);
        boolean prevScanToEnd4256= scanToEnd;
        currentLookaheadProduction= "Pattern";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Pattern()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4256;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:524:28
        if (!scanToken(RPAREN)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$KeyValuePattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:526:19
        Token token4257= currentLookaheadToken;
        int remainingLookahead4257= remainingLookahead;
        boolean hitFailure4257= hitFailure;
        if (!check$Python_javacc$526$19$()) {
            currentLookaheadToken= token4257;
            remainingLookahead= remainingLookahead4257;
            hitFailure= hitFailure4257;
            if (!check$Python_javacc$526$36()) {
                currentLookaheadToken= token4257;
                remainingLookahead= remainingLookahead4257;
                hitFailure= hitFailure4257;
                return false;
            }
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:526:47
        if (!scanToken(COLON)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:526:51
        // NonTerminal Pattern at Python.javacc:526:51
        pushOntoLookaheadStack("KeyValuePattern", "Python.javacc", 526, 51);
        boolean prevScanToEnd4258= scanToEnd;
        currentLookaheadProduction= "Pattern";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Pattern()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4258;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ItemsPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:528:16
        // NonTerminal KeyValuePattern at Python.javacc:528:16
        pushOntoLookaheadStack("ItemsPattern", "Python.javacc", 528, 16);
        boolean prevScanToEnd4259= scanToEnd;
        currentLookaheadProduction= "KeyValuePattern";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$KeyValuePattern()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4259;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:528:32
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4260= currentLookaheadToken;
            if (!check$Python_javacc$528$33()) {
                currentLookaheadToken= token4260;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$MappingPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:531:3
        if (!scanToken(LBRACE)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:532:6
        Token token4261= currentLookaheadToken;
        if (!check$Python_javacc$533$10()) {
            currentLookaheadToken= token4261;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:537:3
        if (!scanToken(RBRACE)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$DoubleStarPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:540:21
        if (!scanToken(STAR_STAR)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:540:26
        if (!scanToken(NAME)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$LiteralPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:543:4
        Token token4262= currentLookaheadToken;
        int remainingLookahead4262= remainingLookahead;
        boolean hitFailure4262= hitFailure;
        if (!scanToken(NONE)) {
            currentLookaheadToken= token4262;
            remainingLookahead= remainingLookahead4262;
            hitFailure= hitFailure4262;
            if (!scanToken(TRUE)) {
                currentLookaheadToken= token4262;
                remainingLookahead= remainingLookahead4262;
                hitFailure= hitFailure4262;
                if (!scanToken(FALSE)) {
                    currentLookaheadToken= token4262;
                    remainingLookahead= remainingLookahead4262;
                    hitFailure= hitFailure4262;
                    if (!check$Python_javacc$549$4()) {
                        currentLookaheadToken= token4262;
                        remainingLookahead= remainingLookahead4262;
                        hitFailure= hitFailure4262;
                        if (!check$Python_javacc$551$4()) {
                            currentLookaheadToken= token4262;
                            remainingLookahead= remainingLookahead4262;
                            hitFailure= hitFailure4262;
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$MaybeSequencePattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:555:4
        // NonTerminal MaybeStarPattern at Python.javacc:555:4
        pushOntoLookaheadStack("MaybeSequencePattern", "Python.javacc", 555, 4);
        boolean prevScanToEnd4263= scanToEnd;
        currentLookaheadProduction= "MaybeStarPattern";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$MaybeStarPattern()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4263;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:555:21
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4264= currentLookaheadToken;
            if (!check$Python_javacc$555$22()) {
                currentLookaheadToken= token4264;
                break;
            }
        }
        hitFailure= false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:555:51
        Token token4265= currentLookaheadToken;
        if (!scanToken(COMMA)) {
            currentLookaheadToken= token4265;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$OpenSequencePattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:559:4
        // NonTerminal MaybeStarPattern at Python.javacc:559:4
        pushOntoLookaheadStack("OpenSequencePattern", "Python.javacc", 559, 4);
        boolean prevScanToEnd4266= scanToEnd;
        currentLookaheadProduction= "MaybeStarPattern";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$MaybeStarPattern()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4266;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:559:21
        if (!scanToken(COMMA)) return false;
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 0;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:559:30
        Token token4267= currentLookaheadToken;
        if (!check$Python_javacc$559$31()) {
            currentLookaheadToken= token4267;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$SequencePattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:563:5
        Token token4268= currentLookaheadToken;
        int remainingLookahead4268= remainingLookahead;
        boolean hitFailure4268= hitFailure;
        if (!check$Python_javacc$563$5()) {
            currentLookaheadToken= token4268;
            remainingLookahead= remainingLookahead4268;
            hitFailure= hitFailure4268;
            if (!check$Python_javacc$565$5()) {
                currentLookaheadToken= token4268;
                remainingLookahead= remainingLookahead4268;
                hitFailure= hitFailure4268;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$ClassPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:569:4
        // NonTerminal NameOrAttribute at Python.javacc:569:4
        pushOntoLookaheadStack("ClassPattern", "Python.javacc", 569, 4);
        boolean prevScanToEnd4269= scanToEnd;
        currentLookaheadProduction= "NameOrAttribute";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$NameOrAttribute()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4269;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:570:4
        if (!scanToken(LPAREN)) return false;
        if (!scanToEnd&&lookaheadRoutineNesting<=1&&nonTerminalNesting<=1) {
            remainingLookahead= 0;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:572:7
        Token token4270= currentLookaheadToken;
        if (!check$Python_javacc$573$11$()) {
            currentLookaheadToken= token4270;
            hitFailure= false;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:578:4
        if (!scanToken(RPAREN)) return false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$PositionalPatterns() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:582:4
        // NonTerminal Pattern at Python.javacc:582:4
        pushOntoLookaheadStack("PositionalPatterns", "Python.javacc", 582, 4);
        boolean prevScanToEnd4271= scanToEnd;
        currentLookaheadProduction= "Pattern";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$Pattern()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4271;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:583:4
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4272= currentLookaheadToken;
            if (!check$Python_javacc$586$8()) {
                currentLookaheadToken= token4272;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$KeywordPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:591:18
        if (!scanToken(NAME)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpStringLiteral specified at Python.javacc:591:25
        if (!scanToken(ASSIGN)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:591:29
        // NonTerminal Pattern at Python.javacc:591:29
        pushOntoLookaheadStack("KeywordPattern", "Python.javacc", 591, 29);
        boolean prevScanToEnd4273= scanToEnd;
        currentLookaheadProduction= "Pattern";
        scanToEnd= true;
        ++nonTerminalNesting;
        try {
            if (!check$Pattern()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4273;
            --nonTerminalNesting;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$KeywordPatterns() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:593:19
        // NonTerminal KeywordPattern at Python.javacc:593:19
        pushOntoLookaheadStack("KeywordPatterns", "Python.javacc", 593, 19);
        boolean prevScanToEnd4274= scanToEnd;
        currentLookaheadProduction= "KeywordPattern";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$KeywordPattern()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4274;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:593:34
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4275= currentLookaheadToken;
            if (!check$Python_javacc$593$35()) {
                currentLookaheadToken= token4275;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$OrPattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:595:13
        // NonTerminal ClosedPattern at Python.javacc:595:13
        pushOntoLookaheadStack("OrPattern", "Python.javacc", 595, 13);
        boolean prevScanToEnd4276= scanToEnd;
        currentLookaheadProduction= "ClosedPattern";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$ClosedPattern()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4276;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:595:27
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4277= currentLookaheadToken;
            if (!check$Python_javacc$595$28()) {
                currentLookaheadToken= token4277;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Pattern() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for NonTerminal specified at Python.javacc:597:11
        // NonTerminal OrPattern at Python.javacc:597:11
        pushOntoLookaheadStack("Pattern", "Python.javacc", 597, 11);
        boolean prevScanToEnd4278= scanToEnd;
        currentLookaheadProduction= "OrPattern";
        scanToEnd= false;
        ++nonTerminalNesting;
        try {
            if (!check$OrPattern()) return false;
        }
        finally {
            popLookaheadStack();
            scanToEnd= prevScanToEnd4278;
            --nonTerminalNesting;
        }
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrOne specified at Python.javacc:597:21
        Token token4279= currentLookaheadToken;
        if (!check$Python_javacc$597$22()) {
            currentLookaheadToken= token4279;
            hitFailure= false;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$SubjectExpression() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ExpansionChoice specified at Python.javacc:600:4
        Token token4280= currentLookaheadToken;
        int remainingLookahead4280= remainingLookahead;
        boolean hitFailure4280= hitFailure;
        if (!check$Python_javacc$600$4()) {
            currentLookaheadToken= token4280;
            remainingLookahead= remainingLookahead4280;
            hitFailure= hitFailure4280;
            if (!check$Python_javacc$602$4()) {
                currentLookaheadToken= token4280;
                remainingLookahead= remainingLookahead4280;
                hitFailure= hitFailure4280;
                return false;
            }
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$Attribute() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:605:13
        if (!scanToken(NAME)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for OneOrMore specified at Python.javacc:605:20
        if (!check$Python_javacc$605$21()) {
            return false;
        }
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4281= currentLookaheadToken;
            if (!check$Python_javacc$605$21()) {
                currentLookaheadToken= token4281;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$NameOrAttribute() {
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for RegexpRef specified at Python.javacc:607:34
        if (!scanToken(NAME)) return false;
        if (hitFailure||remainingLookahead<=0) return!hitFailure;
        // Lookahead Code for ZeroOrMore specified at Python.javacc:607:41
        while (remainingLookahead> 0&&!hitFailure) {
            Token token4282= currentLookaheadToken;
            if (!check$Python_javacc$607$42()) {
                currentLookaheadToken= token4282;
                break;
            }
        }
        hitFailure= false;
        return true;
    }

    ArrayList<NonTerminalCall> parsingStack= new ArrayList<> ();
    private ArrayList<NonTerminalCall> lookaheadStack= new ArrayList<> ();
    /**
 * Inner class that represents entering a grammar production
 */
    class NonTerminalCall {
        final String sourceFile;
        final String productionName;
        final int line, column;
        NonTerminalCall(String sourceFile, String productionName, int line, int column) {
            this.sourceFile= sourceFile;
            this.productionName= productionName;
            this.line= line;
            this.column= column;
        }

        final PythonLexer getTokenSource() {
            return PythonParser.this.token_source;
        }

        StackTraceElement createStackTraceElement() {
            return new StackTraceElement("PythonParser", productionName, sourceFile, line);
        }

        void dump(PrintStream ps) {
            ps.println(productionName+":"+line+":"+column);
        }

    }
    private final void pushOntoCallStack(String methodName, String fileName, int line, int column) {
        parsingStack.add(new NonTerminalCall(fileName, methodName, line, column));
    }

    private final void popCallStack() {
        NonTerminalCall ntc= parsingStack.remove(parsingStack.size()-1);
        this.currentlyParsedProduction= ntc.productionName;
    }

    private final void restoreCallStack(int prevSize) {
        while (parsingStack.size()> prevSize) {
            popCallStack();
        }
    }

    private ListIterator<NonTerminalCall> stackIteratorBackward() {
        final ListIterator<NonTerminalCall> parseStackIterator= parsingStack.listIterator(parsingStack.size());
        final ListIterator<NonTerminalCall> lookaheadStackIterator= lookaheadStack.listIterator(lookaheadStack.size());
        return new ListIterator<NonTerminalCall> () {
            public boolean hasNext() {
                return parseStackIterator.hasPrevious()||lookaheadStackIterator.hasPrevious();
            }

            public NonTerminalCall next() {
                return lookaheadStackIterator.hasPrevious()?lookaheadStackIterator.previous():
                parseStackIterator.previous();
            }

            public NonTerminalCall previous() {
                return lookaheadStackIterator.hasNext()?lookaheadStackIterator.next():
                parseStackIterator.next();
            }

            public boolean hasPrevious() {
                return lookaheadStackIterator.hasNext()||parseStackIterator.hasNext();
            }

            public void add(NonTerminalCall ntc) {
                throw new UnsupportedOperationException();
            }

            public void set(NonTerminalCall ntc) {
                throw new UnsupportedOperationException();
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }

            public int previousIndex() {
                throw new UnsupportedOperationException();
            }

            public int nextIndex() {
                throw new UnsupportedOperationException();
            }

        }
        ;
    }

    private final void pushOntoLookaheadStack(String methodName, String fileName, int line, int column) {
        lookaheadStack.add(new NonTerminalCall(fileName, methodName, line, column));
    }

    private final void popLookaheadStack() {
        NonTerminalCall ntc= lookaheadStack.remove(lookaheadStack.size()-1);
        this.currentLookaheadProduction= ntc.productionName;
    }

    void dumpLookaheadStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= lookaheadStack.listIterator(lookaheadStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpCallStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it= parsingStack.listIterator(parsingStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpLookaheadCallStack(PrintStream ps) {
        ps.println("Current Parser Production is: "+currentlyParsedProduction);
        ps.println("Current Lookahead Production is: "+currentLookaheadProduction);
        ps.println("---Lookahead Stack---");
        dumpLookaheadStack(ps);
        ps.println("---Call Stack---");
        dumpCallStack(ps);
    }

    public boolean isParserTolerant() {
        return false;
    }

    public void setParserTolerant(boolean tolerantParsing) {
        if (tolerantParsing) {
            throw new UnsupportedOperationException("This parser was not built with that feature!");
        }
    }

    private Token consumeToken(TokenType expectedType) {
        Token oldToken= lastConsumedToken;
        Token nextToken= nextToken(lastConsumedToken);
        if (nextToken.getType()!=expectedType) {
            nextToken= handleUnexpectedTokenType(expectedType, nextToken);
        }
        this.lastConsumedToken= nextToken;
        this.nextTokenType= null;
        if (buildTree&&tokensAreNodes) {
            pushNode(lastConsumedToken);
        }
        return lastConsumedToken;
    }

    private Token handleUnexpectedTokenType(TokenType expectedType, Token nextToken) {
        throw new ParseException(this, nextToken, EnumSet.of(expectedType), parsingStack);
    }

    private class ParseState {
        Token lastConsumed;
        ArrayList<NonTerminalCall> parsingStack;
        NodeScope nodeScope;
        ParseState() {
            this.lastConsumed= PythonParser.this.lastConsumedToken;
            @SuppressWarnings("unchecked")
            ArrayList<NonTerminalCall> parsingStack= (ArrayList<NonTerminalCall> ) PythonParser.this.parsingStack.clone();
            this.parsingStack= parsingStack;
            this.nodeScope= (NodeScope) currentNodeScope.clone();
        }

    }
    private boolean buildTree= true;
    private boolean tokensAreNodes= true;
    private boolean unparsedTokensAreNodes= false;
    public boolean isTreeBuildingEnabled() {
        return buildTree;
    }

    public void setUnparsedTokensAreNodes(boolean unparsedTokensAreNodes) {
        this.unparsedTokensAreNodes= unparsedTokensAreNodes;
    }

    public void setTokensAreNodes(boolean tokensAreNodes) {
        this.tokensAreNodes= tokensAreNodes;
    }

    NodeScope currentNodeScope= new NodeScope();
    /** 
         * @return the root node of the AST. It only makes sense to call
         * this after a successful parse. 
         */
    public Node rootNode() {
        return currentNodeScope.rootNode();
    }

    /**
     * push a node onto the top of the node stack
     * @param n the node to push
     */
    public void pushNode(Node n) {
        currentNodeScope.add(n);
    }

    /** 
     * @return the node on the top of the stack, and remove it from the
     * stack.  
     */
    public Node popNode() {
        return currentNodeScope.pop();
    }

    /** 
     * @return the node currently on the top of the tree-building stack. 
     */
    public Node peekNode() {
        return currentNodeScope.peek();
    }

    /**
     * Puts the node on the top of the stack. However, unlike pushNode()
     * it replaces the node that is currently on the top of the stack.
     * This is effectively equivalent to popNode() followed by pushNode(n)
     * @param n the node to poke
     */
    public void pokeNode(Node n) {
        currentNodeScope.poke(n);
    }

    /** 
     * @return the number of Nodes on the tree-building stack in the current node
         * scope. 
         */
    public int nodeArity() {
        return currentNodeScope.size();
    }

    private void clearNodeScope() {
        currentNodeScope.clear();
    }

    private void openNodeScope(Node n) {
        new NodeScope();
        if (n!=null) {
            Token next= nextToken(lastConsumedToken);
            n.setTokenSource(lastConsumedToken.getTokenSource());
            n.setBeginOffset(next.getBeginOffset());
            n.open();
        }
    }

    /* A definite node is constructed from a specified number of
         * children.  That number of nodes are popped from the stack and
         * made the children of the definite node.  Then the definite node
         * is pushed on to the stack.
         */
    private void closeNodeScope(Node n, int num) {
        n.setEndOffset(lastConsumedToken.getEndOffset());
        currentNodeScope.close();
        ArrayList<Node> nodes= new ArrayList<Node> ();
        for (int i= 0; i<num; i++) {
            nodes.add(popNode());
        }
        Collections.reverse(nodes);
        for (Node child : nodes) {
            // FIXME deal with the UNPARSED_TOKENS_ARE_NODES case
            n.addChild(child);
        }
        n.close();
        pushNode(n);
    }

    /**
         * A conditional node is constructed if the condition is true.  All
         * the nodes that have been pushed since the node was opened are
         * made children of the conditional node, which is then pushed
         * on to the stack.  If the condition is false the node is not
         * constructed and they are left on the stack. 
         */
    private void closeNodeScope(Node n, boolean condition) {
        if (n!=null&&condition) {
            n.setEndOffset(lastConsumedToken.getEndOffset());
            int a= nodeArity();
            currentNodeScope.close();
            ArrayList<Node> nodes= new ArrayList<Node> ();
            while (a--> 0) {
                nodes.add(popNode());
            }
            Collections.reverse(nodes);
            for (Node child : nodes) {
                if (unparsedTokensAreNodes&&child instanceof Token) {
                    Token tok= (Token) child;
                    while (tok.previousCachedToken()!=null&&tok.previousCachedToken().isUnparsed()) {
                        tok= tok.previousCachedToken();
                    }
                    while (tok.isUnparsed()) {
                        n.addChild(tok);
                        tok= tok.nextCachedToken();
                    }
                }
                n.addChild(child);
            }
            n.close();
            pushNode(n);
        }
        else  {
            currentNodeScope.close();
        }
    }

    public boolean getBuildTree() {
        return buildTree;
    }

    public void setBuildTree(boolean buildTree) {
        this.buildTree= buildTree;
    }

    /**
     * Just a kludge so that existing jjtree-based code that uses
     * parser.jjtree.foo can work without change.
     */
    PythonParser jjtree= this;
    @SuppressWarnings("serial")
    class NodeScope extends ArrayList<Node>  {
        NodeScope parentScope;
        NodeScope() {
            this.parentScope= PythonParser.this.currentNodeScope;
            PythonParser.this.currentNodeScope= this;
        }

        boolean isRootScope() {
            return parentScope== null;
        }

        Node rootNode() {
            NodeScope ns= this;
            while (ns.parentScope!=null) {
                ns= ns.parentScope;
            }
            return ns.isEmpty()?null:
            ns.get(0);
        }

        Node peek() {
            return isEmpty()?parentScope.peek():
            get(size()-1);
        }

        Node pop() {
            return isEmpty()?parentScope.pop():
            remove(size()-1);
        }

        void poke(Node n) {
            if (isEmpty()) {
                parentScope.poke(n);
            }
            else  {
                set(size()-1, n);
            }
        }

        void close() {
            parentScope.addAll(this);
            PythonParser.this.currentNodeScope= parentScope;
        }

        int nestingLevel() {
            int result= 0;
            NodeScope parent= this;
            while (parent.parentScope!=null) {
                result++;
                parent= parent.parentScope;
            }
            return result;
        }

        public NodeScope clone() {
            NodeScope clone= (NodeScope) super.clone();
            if (parentScope!=null) {
                clone.parentScope= (NodeScope) parentScope.clone();
            }
            return clone;
        }

    }
}
