/* Generated by: JavaCC 21 Parser Generator. Token.java */
package org.parsers.python;

import org.parsers.python.ast.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
public class Token implements PythonConstants, Node {
    public java.util.List<Integer> getIndents() {
        return null;
    }

    boolean startsLine() {
        for (java.util.Iterator<Token> toks= precedingTokens(); toks.hasNext(); ) {
            Token t= toks.next();
            if (t.getType()== TokenType.CONTINUE_LINE) return false;
            if (!t.isUnparsed()) return t.getEndLine()!=this.getBeginLine();
        }
        return true;
    }

    public Token getPreviousToken() {
        return previousCachedToken();
    }

    public void setImage(String image) {
        this.image= image;
    }

    private TokenType type;
    private PythonLexer tokenSource;
    private int beginOffset, endOffset;
    private boolean unparsed;
    private Node parent;
    private String image;
    private Token prependedToken, appendedToken;
    private boolean inserted;
    public boolean isInserted() {
        return inserted;
    }

    public void preInsert(Token prependedToken) {
        if (prependedToken== this.prependedToken) return;
        prependedToken.appendedToken= this;
        Token existingPreviousToken= this.previousCachedToken();
        if (existingPreviousToken!=null) {
            existingPreviousToken.appendedToken= prependedToken;
            prependedToken.prependedToken= existingPreviousToken;
        }
        prependedToken.inserted= true;
        prependedToken.beginOffset= prependedToken.endOffset= this.beginOffset;
        this.prependedToken= prependedToken;
    }

    void unsetAppendedToken() {
        this.appendedToken= null;
    }

    /**
     * @param type the #TokenType of the token being constructed
     * @param image the String content of the token
     * @param tokenSource the object that vended this token.
     */
    public Token(TokenType type, String image, PythonLexer tokenSource) {
        this.type= type;
        this.image= image;
        this.tokenSource= tokenSource;
    }

    public static Token newToken(TokenType type, String image, PythonLexer tokenSource) {
        Token result= newToken(type, tokenSource, 0, 0);
        result.setImage(image);
        return result;
    }

    /**
     * It would be extremely rare that an application
     * programmer would use this method. It needs to
     * be public because it is part of the org.parsers.python.Node interface.
     */
    public void setBeginOffset(int beginOffset) {
        this.beginOffset= beginOffset;
    }

    /**
     * It would be extremely rare that an application
     * programmer would use this method. It needs to
     * be public because it is part of the org.parsers.python.Node interface.
     */
    public void setEndOffset(int endOffset) {
        this.endOffset= endOffset;
    }

    /**
     * @return the PythonLexer object that handles 
     * location info for the tokens. 
     */
    public PythonLexer getTokenSource() {
        PythonLexer flm= this.tokenSource;
        // If this is null and we have chained tokens,
        // we try to get it from there! (Why not?)
        if (flm== null) {
            if (prependedToken!=null) {
                flm= prependedToken.getTokenSource();
            }
            if (flm== null&&appendedToken!=null) {
                flm= appendedToken.getTokenSource();
            }
        }
        return flm;
    }

    /**
     * It should be exceedingly rare that an application
     * programmer needs to use this method.
     */
    public void setTokenSource(PythonLexer tokenSource) {
        this.tokenSource= tokenSource;
    }

    /**
     * Return the TokenType of this Token object
     */
    public TokenType getType() {
        return type;
    }

    protected void setType(TokenType type) {
        this.type= type;
    }

    /**
     * @return whether this Token represent actual input or was it inserted somehow?
     */
    public boolean isVirtual() {
        return type== TokenType.EOF;
    }

    /**
     * @return Did we skip this token in parsing?
     */
    public boolean isSkipped() {
        return false;
    }

    public int getBeginOffset() {
        return beginOffset;
    }

    public int getEndOffset() {
        return endOffset;
    }

    /**
     * @return the string image of the token.
     */
    public String getImage() {
        return image!=null?image:
        getSource();
    }

    /**
     * @return the next _cached_ regular (i.e. parsed) token
     * or null
     */
    public final Token getNext() {
        return getNextParsedToken();
    }

    /**
     * @return the previous regular (i.e. parsed) token
     * or null
     */
    public final Token getPrevious() {
        Token result= previousCachedToken();
        while (result!=null&&result.isUnparsed()) {
            result= result.previousCachedToken();
        }
        return result;
    }

    /**
     * @return the next regular (i.e. parsed) token
     */
    private Token getNextParsedToken() {
        Token result= nextCachedToken();
        while (result!=null&&result.isUnparsed()) {
            result= result.nextCachedToken();
        }
        return result;
    }

    /**
     * @return the next token of any sort (parsed or unparsed or invalid)
     */
    public Token nextCachedToken() {
        if (appendedToken!=null) return appendedToken;
        PythonLexer tokenSource= getTokenSource();
        return tokenSource!=null?tokenSource.nextCachedToken(getEndOffset()):
        null;
    }

    public Token previousCachedToken() {
        if (prependedToken!=null) return prependedToken;
        if (getTokenSource()== null) return null;
        return getTokenSource().previousCachedToken(getBeginOffset());
    }

    public Token replaceType(TokenType type) {
        Token result= newToken(type, getTokenSource(), getBeginOffset(), getEndOffset());
        result.prependedToken= this.prependedToken;
        result.appendedToken= this.appendedToken;
        result.inserted= this.inserted;
        if (result.appendedToken!=null) {
            result.appendedToken.prependedToken= result;
        }
        if (result.prependedToken!=null) {
            result.prependedToken.appendedToken= result;
        }
        if (!result.inserted) {
            getTokenSource().cacheToken(result);
        }
        return result;
    }

    public String getSource() {
        if (type== TokenType.EOF) return"";
        PythonLexer flm= getTokenSource();
        return flm== null?null:
        flm.getText(getBeginOffset(), getEndOffset());
    }

    protected Token() {
    }

    public Token(TokenType type, PythonLexer tokenSource, int beginOffset, int endOffset) {
        this.type= type;
        this.tokenSource= tokenSource;
        this.beginOffset= beginOffset;
        this.endOffset= endOffset;
    }

    public boolean isUnparsed() {
        return unparsed;
    }

    public void setUnparsed(boolean unparsed) {
        this.unparsed= unparsed;
    }

    public void clearChildren() {
    }

    public String getNormalizedText() {
        if (getType()== TokenType.EOF) {
            return"EOF";
        }
        return getImage();
    }

    public String toString() {
        return getNormalizedText();
    }

    /**
     * @return An iterator of the tokens preceding this one.
     */
    public Iterator<Token> precedingTokens() {
        return new Iterator<Token> () {
            Token currentPoint= Token.this;
            public boolean hasNext() {
                return currentPoint.previousCachedToken()!=null;
            }

            public Token next() {
                Token previous= currentPoint.previousCachedToken();
                if (previous== null) throw new java.util.NoSuchElementException("No previous token!");
                return currentPoint= previous;
            }

        }
        ;
    }

    /**
     * @return a list of the unparsed tokens preceding this one in the order they appear in the input
     */
    public List<Token> precedingUnparsedTokens() {
        List<Token> result= new ArrayList<> ();
        Token t= this.previousCachedToken();
        while (t!=null&&t.isUnparsed()) {
            result.add(t);
            t= t.previousCachedToken();
        }
        Collections.reverse(result);
        return result;
    }

    /**
     * @return An iterator of the (cached) tokens that follow this one.
     */
    public Iterator<Token> followingTokens() {
        return new java.util.Iterator<Token> () {
            Token currentPoint= Token.this;
            public boolean hasNext() {
                return currentPoint.nextCachedToken()!=null;
            }

            public Token next() {
                Token next= currentPoint.nextCachedToken();
                if (next== null) throw new java.util.NoSuchElementException("No next token!");
                return currentPoint= next;
            }

        }
        ;
    }

    /**
     * Copy the location info from a Node
     */
    public void copyLocationInfo(Node from) {
        Node.super.copyLocationInfo(from);
        if (from instanceof Token) {
            Token otherTok= (Token) from;
            appendedToken= otherTok.appendedToken;
            prependedToken= otherTok.prependedToken;
        }
        setTokenSource(from.getTokenSource());
    }

    public void copyLocationInfo(Node start, Node end) {
        Node.super.copyLocationInfo(start, end);
        if (start instanceof Token) {
            prependedToken= ((Token) start).prependedToken;
        }
        if (end instanceof Token) {
            Token endToken= (Token) end;
            appendedToken= endToken.appendedToken;
        }
    }

    public static Token newToken(TokenType type, PythonLexer tokenSource, int beginOffset, int endOffset) {
        switch(type) {
            case SPACE:
            return new SPACE(TokenType.SPACE, tokenSource, beginOffset, endOffset);
            case CONTINUE_LINE:
            return new Whitespace(TokenType.CONTINUE_LINE, tokenSource, beginOffset, endOffset);
            case COMMENT:
            return new Comment(TokenType.COMMENT, tokenSource, beginOffset, endOffset);
            case NEWLINE:
            return new Newline(TokenType.NEWLINE, tokenSource, beginOffset, endOffset);
            case ASSIGN:
            return new Delimiter(TokenType.ASSIGN, tokenSource, beginOffset, endOffset);
            case AT:
            return new Delimiter(TokenType.AT, tokenSource, beginOffset, endOffset);
            case COLON:
            return new Delimiter(TokenType.COLON, tokenSource, beginOffset, endOffset);
            case COMMA:
            return new Delimiter(TokenType.COMMA, tokenSource, beginOffset, endOffset);
            case EQ:
            return new Delimiter(TokenType.EQ, tokenSource, beginOffset, endOffset);
            case LBRACE:
            return new Delimiter(TokenType.LBRACE, tokenSource, beginOffset, endOffset);
            case RBRACE:
            return new Delimiter(TokenType.RBRACE, tokenSource, beginOffset, endOffset);
            case LBRACKET:
            return new Delimiter(TokenType.LBRACKET, tokenSource, beginOffset, endOffset);
            case RBRACKET:
            return new Delimiter(TokenType.RBRACKET, tokenSource, beginOffset, endOffset);
            case LPAREN:
            return new Delimiter(TokenType.LPAREN, tokenSource, beginOffset, endOffset);
            case RPAREN:
            return new Delimiter(TokenType.RPAREN, tokenSource, beginOffset, endOffset);
            case SEMICOLON:
            return new Delimiter(TokenType.SEMICOLON, tokenSource, beginOffset, endOffset);
            case STAR:
            return new Delimiter(TokenType.STAR, tokenSource, beginOffset, endOffset);
            case STAR_STAR:
            return new Delimiter(TokenType.STAR_STAR, tokenSource, beginOffset, endOffset);
            case MINUSASSIGN:
            return new Delimiter(TokenType.MINUSASSIGN, tokenSource, beginOffset, endOffset);
            case PLUSASSIGN:
            return new Delimiter(TokenType.PLUSASSIGN, tokenSource, beginOffset, endOffset);
            case STARASSIGN:
            return new Delimiter(TokenType.STARASSIGN, tokenSource, beginOffset, endOffset);
            case ATASSIGN:
            return new Delimiter(TokenType.ATASSIGN, tokenSource, beginOffset, endOffset);
            case SLASHASSIGN:
            return new Delimiter(TokenType.SLASHASSIGN, tokenSource, beginOffset, endOffset);
            case REMASSIGN:
            return new Delimiter(TokenType.REMASSIGN, tokenSource, beginOffset, endOffset);
            case ANDASSIGN:
            return new Delimiter(TokenType.ANDASSIGN, tokenSource, beginOffset, endOffset);
            case ORASSIGN:
            return new Delimiter(TokenType.ORASSIGN, tokenSource, beginOffset, endOffset);
            case XORASSIGN:
            return new Delimiter(TokenType.XORASSIGN, tokenSource, beginOffset, endOffset);
            case LSHIFTASSIGN:
            return new Delimiter(TokenType.LSHIFTASSIGN, tokenSource, beginOffset, endOffset);
            case RSHIFTASSIGN:
            return new Delimiter(TokenType.RSHIFTASSIGN, tokenSource, beginOffset, endOffset);
            case STARSTARASSIGN:
            return new Delimiter(TokenType.STARSTARASSIGN, tokenSource, beginOffset, endOffset);
            case SLASHSLASHASSIGN:
            return new Delimiter(TokenType.SLASHSLASHASSIGN, tokenSource, beginOffset, endOffset);
            case BIT_AND:
            return new Operator(TokenType.BIT_AND, tokenSource, beginOffset, endOffset);
            case BIT_OR:
            return new Operator(TokenType.BIT_OR, tokenSource, beginOffset, endOffset);
            case XOR:
            return new Operator(TokenType.XOR, tokenSource, beginOffset, endOffset);
            case TILDE:
            return new Operator(TokenType.TILDE, tokenSource, beginOffset, endOffset);
            case COLONEQUALS:
            return new Operator(TokenType.COLONEQUALS, tokenSource, beginOffset, endOffset);
            case DOT:
            return new Operator(TokenType.DOT, tokenSource, beginOffset, endOffset);
            case ELLIPSIS:
            return new Operator(TokenType.ELLIPSIS, tokenSource, beginOffset, endOffset);
            case LE:
            return new Operator(TokenType.LE, tokenSource, beginOffset, endOffset);
            case GE:
            return new Operator(TokenType.GE, tokenSource, beginOffset, endOffset);
            case NE:
            return new Operator(TokenType.NE, tokenSource, beginOffset, endOffset);
            case GT:
            return new Operator(TokenType.GT, tokenSource, beginOffset, endOffset);
            case LT:
            return new Operator(TokenType.LT, tokenSource, beginOffset, endOffset);
            case MINUS:
            return new Operator(TokenType.MINUS, tokenSource, beginOffset, endOffset);
            case PLUS:
            return new Operator(TokenType.PLUS, tokenSource, beginOffset, endOffset);
            case SLASH:
            return new Operator(TokenType.SLASH, tokenSource, beginOffset, endOffset);
            case PERCENT:
            return new Operator(TokenType.PERCENT, tokenSource, beginOffset, endOffset);
            case LSHIFT:
            return new Operator(TokenType.LSHIFT, tokenSource, beginOffset, endOffset);
            case RSHIFT:
            return new Operator(TokenType.RSHIFT, tokenSource, beginOffset, endOffset);
            case HOOK:
            return new Operator(TokenType.HOOK, tokenSource, beginOffset, endOffset);
            case RARROW:
            return new Operator(TokenType.RARROW, tokenSource, beginOffset, endOffset);
            case AND:
            return new Keyword(TokenType.AND, tokenSource, beginOffset, endOffset);
            case AS:
            return new Keyword(TokenType.AS, tokenSource, beginOffset, endOffset);
            case _ASSERT:
            return new Keyword(TokenType._ASSERT, tokenSource, beginOffset, endOffset);
            case ASYNC:
            return new Keyword(TokenType.ASYNC, tokenSource, beginOffset, endOffset);
            case AWAIT:
            return new Keyword(TokenType.AWAIT, tokenSource, beginOffset, endOffset);
            case BREAK:
            return new Keyword(TokenType.BREAK, tokenSource, beginOffset, endOffset);
            case CASE:
            return new Keyword(TokenType.CASE, tokenSource, beginOffset, endOffset);
            case CLASS:
            return new Keyword(TokenType.CLASS, tokenSource, beginOffset, endOffset);
            case CONTINUE:
            return new Keyword(TokenType.CONTINUE, tokenSource, beginOffset, endOffset);
            case DEF:
            return new Keyword(TokenType.DEF, tokenSource, beginOffset, endOffset);
            case DEL:
            return new Keyword(TokenType.DEL, tokenSource, beginOffset, endOffset);
            case EXCEPT:
            return new Keyword(TokenType.EXCEPT, tokenSource, beginOffset, endOffset);
            case FINALLY:
            return new Keyword(TokenType.FINALLY, tokenSource, beginOffset, endOffset);
            case FOR:
            return new Keyword(TokenType.FOR, tokenSource, beginOffset, endOffset);
            case FROM:
            return new Keyword(TokenType.FROM, tokenSource, beginOffset, endOffset);
            case GLOBAL:
            return new Keyword(TokenType.GLOBAL, tokenSource, beginOffset, endOffset);
            case IF:
            return new Keyword(TokenType.IF, tokenSource, beginOffset, endOffset);
            case IN:
            return new Keyword(TokenType.IN, tokenSource, beginOffset, endOffset);
            case IS:
            return new Keyword(TokenType.IS, tokenSource, beginOffset, endOffset);
            case ELIF:
            return new Keyword(TokenType.ELIF, tokenSource, beginOffset, endOffset);
            case ELSE:
            return new Keyword(TokenType.ELSE, tokenSource, beginOffset, endOffset);
            case FALSE:
            return new Keyword(TokenType.FALSE, tokenSource, beginOffset, endOffset);
            case IMPORT:
            return new Keyword(TokenType.IMPORT, tokenSource, beginOffset, endOffset);
            case LAMBDA:
            return new Keyword(TokenType.LAMBDA, tokenSource, beginOffset, endOffset);
            case MATCH:
            return new Keyword(TokenType.MATCH, tokenSource, beginOffset, endOffset);
            case NONLOCAL:
            return new Keyword(TokenType.NONLOCAL, tokenSource, beginOffset, endOffset);
            case NONE:
            return new Keyword(TokenType.NONE, tokenSource, beginOffset, endOffset);
            case NOT:
            return new Keyword(TokenType.NOT, tokenSource, beginOffset, endOffset);
            case OR:
            return new Keyword(TokenType.OR, tokenSource, beginOffset, endOffset);
            case PASS:
            return new Keyword(TokenType.PASS, tokenSource, beginOffset, endOffset);
            case PEG_PARSER:
            return new Keyword(TokenType.PEG_PARSER, tokenSource, beginOffset, endOffset);
            case RAISE:
            return new Keyword(TokenType.RAISE, tokenSource, beginOffset, endOffset);
            case RETURN:
            return new Keyword(TokenType.RETURN, tokenSource, beginOffset, endOffset);
            case TRUE:
            return new Keyword(TokenType.TRUE, tokenSource, beginOffset, endOffset);
            case TRY:
            return new Keyword(TokenType.TRY, tokenSource, beginOffset, endOffset);
            case WHILE:
            return new Keyword(TokenType.WHILE, tokenSource, beginOffset, endOffset);
            case WITH:
            return new Keyword(TokenType.WITH, tokenSource, beginOffset, endOffset);
            case YIELD:
            return new Keyword(TokenType.YIELD, tokenSource, beginOffset, endOffset);
            case DECNUMBER:
            return new NumericalLiteral(TokenType.DECNUMBER, tokenSource, beginOffset, endOffset);
            case BADDECNUMBER:
            return new NumericalLiteral(TokenType.BADDECNUMBER, tokenSource, beginOffset, endOffset);
            case HEXNUMBER:
            return new NumericalLiteral(TokenType.HEXNUMBER, tokenSource, beginOffset, endOffset);
            case OCTNUMBER:
            return new NumericalLiteral(TokenType.OCTNUMBER, tokenSource, beginOffset, endOffset);
            case BINNUMBER:
            return new NumericalLiteral(TokenType.BINNUMBER, tokenSource, beginOffset, endOffset);
            case FLOAT:
            return new NumericalLiteral(TokenType.FLOAT, tokenSource, beginOffset, endOffset);
            case COMPLEX:
            return new NumericalLiteral(TokenType.COMPLEX, tokenSource, beginOffset, endOffset);
            case STRING_LITERAL:
            return new StringLiteral(TokenType.STRING_LITERAL, tokenSource, beginOffset, endOffset);
            case NAME:
            return new Name(TokenType.NAME, tokenSource, beginOffset, endOffset);
            case BADNAME:
            return new BADNAME(TokenType.BADNAME, tokenSource, beginOffset, endOffset);
            case INDENT:
            return new IndentToken(TokenType.INDENT, tokenSource, beginOffset, endOffset);
            case DEDENT:
            return new DedentToken(TokenType.DEDENT, tokenSource, beginOffset, endOffset);
            case INVALID:
            return new InvalidToken(tokenSource, beginOffset, endOffset);
            default:
            return new Token(type, tokenSource, beginOffset, endOffset);
        }
    }

    public String getLocation() {
        return getInputSource()+":"+getBeginLine()+":"+getBeginColumn();
    }

    public void setChild(int i, Node n) {
        throw new UnsupportedOperationException();
    }

    public void addChild(Node n) {
        throw new UnsupportedOperationException();
    }

    public void addChild(int i, Node n) {
        throw new UnsupportedOperationException();
    }

    public Node removeChild(int i) {
        throw new UnsupportedOperationException();
    }

    public final int indexOf(Node n) {
        return-1;
    }

    public Node getParent() {
        return parent;
    }

    public void setParent(Node parent) {
        this.parent= parent;
    }

    public final int getChildCount() {
        return 0;
    }

    public final Node getChild(int i) {
        return null;
    }

    public final List<Node> children() {
        return java.util.Collections.emptyList();
    }

}
